package main

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"os"
	"strings"
)

var maxKey int

func die(why string, args ...interface{}) {
	fmt.Fprintf(os.Stderr, why+"\n", args...)
	os.Exit(1)
}

type (
	// LineWriter writes lines at a time.
	LineWriter struct {
		buf *bytes.Buffer
	}

	Type interface {
		WriteAppend(*LineWriter)
		WriteDecode(*LineWriter)
		TypeName() string
	}

	Bool           struct{}
	Int8           struct{}
	Int16          struct{}
	Int32          struct{}
	Int64          struct{}
	Uint32         struct{}
	Varint         struct{}
	Varlong        struct{}
	String         struct{}
	NullableString struct{}
	Bytes          struct{}
	NullableBytes  struct{}
	VarintString   struct{}
	VarintBytes    struct{}

	FieldLengthMinusBytes struct {
		Field       string
		LengthMinus int
	}

	Array struct {
		Inner           Type
		IsVarintArray   bool
		IsNullableArray bool
		NullableVersion int
	}

	StructField struct {
		Comment    string
		MinVersion int
		MaxVersion int
		FieldName  string
		Type       Type
	}

	Struct struct {
		TopLevel         bool
		WithVersionField bool // if not top level
		WithNoEncoding   bool // if not top level
		Anonymous        bool // if inner struct
		Comment          string
		Name             string

		Fields []StructField

		// Only TopLevel relevant fields:
		Admin            bool
		GroupCoordinator bool
		TxnCoordinator   bool
		Key              int
		MaxVersion       int
		ResponseKind     string
	}
)

func (l *LineWriter) Write(line string, args ...interface{}) {
	fmt.Fprintf(l.buf, line, args...)
	l.buf.WriteByte('\n')
}

//go:generate sh -c "go run . | gofmt > ../pkg/kmsg/messages.go"
func main() {
	f, err := ioutil.ReadFile("DEFINITIONS")
	if err != nil {
		die("unable to read DEFINITIONS file: %v", err)
	}
	Parse(f)

	l := &LineWriter{bytes.NewBuffer(make([]byte, 0, 300<<10))}
	l.Write("package kmsg")
	l.Write(`import "github.com/twmb/kafka-go/pkg/kbin"`)
	l.Write("// Code generated by kafka-go/generate. DO NOT EDIT.\n")

	l.Write("// MaxKey is the maximum key used for any messages in this package.")
	l.Write("// Note that this value will change as Kafka adds more messages.")
	l.Write("const MaxKey = %d\n", maxKey)

	var keys2structs []Struct

	for _, s := range newStructs {
		s.WriteDefn(l)
		if s.TopLevel {
			if s.ResponseKind != "" {
				keys2structs = append(keys2structs, s)
				s.WriteKeyFunc(l)
				s.WriteMaxVersionFunc(l)
				s.WriteSetVersionFunc(l)
				s.WriteGetVersionFunc(l)
				if s.Admin {
					s.WriteAdminFunc(l)
				} else if s.GroupCoordinator {
					s.WriteGroupCoordinatorFunc(l)
				} else if s.TxnCoordinator {
					s.WriteTxnCoordinatorFunc(l)
				}
				s.WriteResponseKindFunc(l)
				l.Write("") // newline before append func
				s.WriteAppendFunc(l)
			} else {
				s.WriteDecodeFunc(l)
			}
		} else if !s.Anonymous && !s.WithNoEncoding {
			s.WriteAppendFunc(l)
			s.WriteDecodeFunc(l)
		}
	}

	l.Write("// RequestForKey returns the request corresponding to the given request key")
	l.Write("// or nil if the key is unknown.")
	l.Write("func RequestForKey(key int16) Request {")
	l.Write("switch key {")
	l.Write("default: return nil")
	for _, key2struct := range keys2structs {
		l.Write("case %d: return new(%s)", key2struct.Key, key2struct.Name)
	}
	l.Write("}")
	l.Write("}")

	l.Write("// NameForKey returns the name (e.g., \"Fetch\") corresponding to a given request key")
	l.Write("// or \"\" if the key is unknown.")
	l.Write("func NameForKey(key int16) string {")
	l.Write("switch key {")
	l.Write("default: return \"\"")
	for _, key2struct := range keys2structs {
		l.Write("case %d: return \"%s\"", key2struct.Key, strings.TrimSuffix(key2struct.Name, "Request"))
	}
	l.Write("}")
	l.Write("}")

	fmt.Println(l.buf.String())
}
