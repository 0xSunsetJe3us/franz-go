package main

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"os"
	"strings"
)

var maxKey int

func die(why string, args ...interface{}) {
	fmt.Fprintf(os.Stderr, why+"\n", args...)
	os.Exit(1)
}

type (
	// LineWriter writes lines at a time.
	LineWriter struct {
		buf *bytes.Buffer
	}

	Type interface {
		WriteAppend(*LineWriter)
		WriteDecode(*LineWriter)
		TypeName() string
	}

	Bool         struct{}
	Int8         struct{}
	Int16        struct{}
	Int32        struct{}
	Int64        struct{}
	Uint32       struct{}
	Varint       struct{}
	Varlong      struct{}
	VarintString struct{}
	VarintBytes  struct{}

	FieldLengthMinusBytes struct {
		Field       string
		LengthMinus int
	}

	// The following four types can be encoded "compact"; this happens on
	// flexible versions.
	String         struct{ FromFlexible bool }
	NullableString struct{ FromFlexible bool }
	Bytes          struct{ FromFlexible bool }
	NullableBytes  struct{ FromFlexible bool }

	Array struct {
		Inner           Type
		IsVarintArray   bool
		IsNullableArray bool
		NullableVersion int

		// FromFlexible is true if this is inside a struct that has
		// flexible versions.
		FromFlexible bool
	}

	StructField struct {
		Comment    string
		MinVersion int
		MaxVersion int
		Tag        int
		FieldName  string
		Type       Type
	}

	Struct struct {
		TopLevel         bool
		WithVersionField bool // if not top level
		WithNoEncoding   bool // if not top level
		Anonymous        bool // if inner struct
		Comment          string
		Name             string

		// FromFlexible tracks if this struct is either
		// (a) top level and has flexible versions, or
		// (b) nested in a top level struct that has flexible versions
		FromFlexible bool

		Fields []StructField

		// Only TopLevel relevant fields:
		Admin            bool
		GroupCoordinator bool
		TxnCoordinator   bool
		Key              int
		MaxVersion       int
		FlexibleAt       int
		ResponseKind     string
	}
)

type FlexibleSetter interface {
	AsFromFlexible() Type
}

func (s String) AsFromFlexible() Type         { dup := s; s.FromFlexible = true; return dup }
func (s NullableString) AsFromFlexible() Type { dup := s; s.FromFlexible = true; return dup }
func (s Bytes) AsFromFlexible() Type          { dup := s; s.FromFlexible = true; return dup }
func (s NullableBytes) AsFromFlexible() Type  { dup := s; s.FromFlexible = true; return dup }
func (s Array) AsFromFlexible() Type          { dup := s; s.FromFlexible = true; return dup }
func (s Struct) AsFromFlexible() Type         { dup := s; s.FromFlexible = true; return dup }

func (l *LineWriter) Write(line string, args ...interface{}) {
	fmt.Fprintf(l.buf, line, args...)
	l.buf.WriteByte('\n')
}

//go:generate sh -c "go run . | gofmt > ../pkg/kmsg/generated.go"
func main() {
	f, err := ioutil.ReadFile("DEFINITIONS")
	if err != nil {
		die("unable to read DEFINITIONS file: %v", err)
	}
	Parse(f)

	l := &LineWriter{bytes.NewBuffer(make([]byte, 0, 300<<10))}
	l.Write("package kmsg")
	l.Write(`import "github.com/twmb/kafka-go/pkg/kbin"`)
	l.Write("// Code generated by kafka-go/generate. DO NOT EDIT.\n")

	l.Write("// MaxKey is the maximum key used for any messages in this package.")
	l.Write("// Note that this value will change as Kafka adds more messages.")
	l.Write("const MaxKey = %d\n", maxKey)

	var keys2structs []Struct

	for _, s := range newStructs {
		s.WriteDefn(l)
		if s.TopLevel {
			if s.ResponseKind != "" {
				keys2structs = append(keys2structs, s)
				s.WriteKeyFunc(l)
				s.WriteMaxVersionFunc(l)
				s.WriteSetVersionFunc(l)
				s.WriteGetVersionFunc(l)
				s.WriteIsFlexibleFunc(l)

				if s.Admin {
					s.WriteAdminFunc(l)
				} else if s.GroupCoordinator {
					s.WriteGroupCoordinatorFunc(l)
				} else if s.TxnCoordinator {
					s.WriteTxnCoordinatorFunc(l)
				}
				s.WriteResponseKindFunc(l)
				l.Write("") // newline before append func
				s.WriteAppendFunc(l)
			} else {
				s.WriteDecodeFunc(l)
			}
		} else if !s.Anonymous && !s.WithNoEncoding {
			s.WriteAppendFunc(l)
			s.WriteDecodeFunc(l)
		}
	}

	l.Write("// RequestForKey returns the request corresponding to the given request key")
	l.Write("// or nil if the key is unknown.")
	l.Write("func RequestForKey(key int16) Request {")
	l.Write("switch key {")
	l.Write("default: return nil")
	for _, key2struct := range keys2structs {
		l.Write("case %d: return new(%s)", key2struct.Key, key2struct.Name)
	}
	l.Write("}")
	l.Write("}")

	l.Write("// NameForKey returns the name (e.g., \"Fetch\") corresponding to a given request key")
	l.Write("// or \"\" if the key is unknown.")
	l.Write("func NameForKey(key int16) string {")
	l.Write("switch key {")
	l.Write("default: return \"\"")
	for _, key2struct := range keys2structs {
		l.Write("case %d: return \"%s\"", key2struct.Key, strings.TrimSuffix(key2struct.Name, "Request"))
	}
	l.Write("}")
	l.Write("}")

	fmt.Println(l.buf.String())
}
