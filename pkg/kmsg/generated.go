package kmsg

import "github.com/twmb/kafka-go/pkg/kbin"

// Code generated by kafka-go/generate. DO NOT EDIT.

// MaxKey is the maximum key used for any messages in this package.
// Note that this value will change as Kafka adds more messages.
const MaxKey = 51

// MessageV0 is the message format Kafka used prior to 0.10.
//
// To produce or fetch messages, Kafka would write many messages contiguously
// as an array without specifying the array length.
type MessageV0 struct {
	// Offset is the offset of this record.
	//
	// If this is the outer message of a recursive message set (i.e. a
	// message set has been compressed and this is the outer message),
	// then the offset should be the offset of the last inner value.
	Offset int64

	// MessageSize is the size of everything that follows in this message.
	MessageSize int32

	// CRC is the crc of everything that follows this field (NOT using the
	// Castagnoli polynomial, as is the case in the 0.11+ RecordBatch).
	CRC int32

	// Magic is 0.
	Magic int8

	// Attributes describe the attributes of this message.
	//
	// Bits 0 thru 2 correspond to compression:
	//   - 00 is no compression
	//   - 01 is gzip compression
	//   - 10 is snappy compression
	//
	// The remaining bits are unused and must be 0.
	Attributes int8

	// Key is an blob of data for a record.
	//
	// Key's are usually used for hashing the record to specific Kafka partitions.
	Key []byte

	// Value is  a blob of data. This field is the main "message" portion of a
	// record.
	Value []byte
}

func (v *MessageV0) AppendTo(dst []byte) []byte {
	{
		v := v.Offset
		dst = kbin.AppendInt64(dst, v)
	}
	{
		v := v.MessageSize
		dst = kbin.AppendInt32(dst, v)
	}
	{
		v := v.CRC
		dst = kbin.AppendInt32(dst, v)
	}
	{
		v := v.Magic
		dst = kbin.AppendInt8(dst, v)
	}
	{
		v := v.Attributes
		dst = kbin.AppendInt8(dst, v)
	}
	{
		v := v.Key
		dst = kbin.AppendNullableBytes(dst, v)
	}
	{
		v := v.Value
		dst = kbin.AppendNullableBytes(dst, v)
	}
	return dst
}
func (v *MessageV0) ReadFrom(src []byte) error {
	b := kbin.Reader{Src: src}
	s := v
	{
		v := b.Int64()
		s.Offset = v
	}
	{
		v := b.Int32()
		s.MessageSize = v
	}
	{
		v := b.Int32()
		s.CRC = v
	}
	{
		v := b.Int8()
		s.Magic = v
	}
	{
		v := b.Int8()
		s.Attributes = v
	}
	{
		v := b.NullableBytes()
		s.Key = v
	}
	{
		v := b.NullableBytes()
		s.Value = v
	}
	return b.Complete()
}

// MessageV1 is the message format Kafka used prior to 0.11.
//
// To produce or fetch messages, Kafka would write many messages contiguously
// as an array without specifying the array length.
//
// To support compression, an entire message set would be compressed and used
// as the Value in another message set (thus being "recursive"). The key for
// this outer message set must be null.
type MessageV1 struct {
	// Offset is the offset of this record.
	//
	// Different from v0, if this message set is a recursive message set
	// (that is, compressed and inside another message set), the offset
	// on the inner set is relative to the offset of the outer set.
	Offset int64

	// MessageSize is the size of everything that follows in this message.
	MessageSize int32

	// CRC is the crc of everything that follows this field (NOT using the
	// Castagnoli polynomial, as is the case in the 0.11+ RecordBatch).
	CRC int32

	// Magic is 1.
	Magic int8

	// Attributes describe the attributes of this message.
	//
	// Bits 0 thru 2 correspond to compression:
	//   - 00 is no compression
	//   - 01 is gzip compression
	//   - 10 is snappy compression
	//
	// Bit 3 is the timestamp type, with 0 meaning CreateTime corresponding
	// to the timestamp being from the producer, and 1 meaning LogAppendTime
	// corresponding to the timestamp being from the broker.
	// Setting this to LogAppendTime will cause batches to be rejected.
	//
	// The remaining bits are unused and must be 0.
	Attributes int8

	// Timestamp is the millisecond timestamp of this message.
	Timestamp int64

	// Key is an blob of data for a record.
	//
	// Key's are usually used for hashing the record to specific Kafka partitions.
	Key []byte

	// Value is  a blob of data. This field is the main "message" portion of a
	// record.
	Value []byte
}

func (v *MessageV1) AppendTo(dst []byte) []byte {
	{
		v := v.Offset
		dst = kbin.AppendInt64(dst, v)
	}
	{
		v := v.MessageSize
		dst = kbin.AppendInt32(dst, v)
	}
	{
		v := v.CRC
		dst = kbin.AppendInt32(dst, v)
	}
	{
		v := v.Magic
		dst = kbin.AppendInt8(dst, v)
	}
	{
		v := v.Attributes
		dst = kbin.AppendInt8(dst, v)
	}
	{
		v := v.Timestamp
		dst = kbin.AppendInt64(dst, v)
	}
	{
		v := v.Key
		dst = kbin.AppendNullableBytes(dst, v)
	}
	{
		v := v.Value
		dst = kbin.AppendNullableBytes(dst, v)
	}
	return dst
}
func (v *MessageV1) ReadFrom(src []byte) error {
	b := kbin.Reader{Src: src}
	s := v
	{
		v := b.Int64()
		s.Offset = v
	}
	{
		v := b.Int32()
		s.MessageSize = v
	}
	{
		v := b.Int32()
		s.CRC = v
	}
	{
		v := b.Int8()
		s.Magic = v
	}
	{
		v := b.Int8()
		s.Attributes = v
	}
	{
		v := b.Int64()
		s.Timestamp = v
	}
	{
		v := b.NullableBytes()
		s.Key = v
	}
	{
		v := b.NullableBytes()
		s.Value = v
	}
	return b.Complete()
}

// Header is user provided metadata for a record. Kafka does not look at
// headers at all; they are solely for producers and consumers.
type Header struct {
	Key string

	Value []byte
}

func (v *Header) AppendTo(dst []byte) []byte {
	{
		v := v.Key
		dst = kbin.AppendVarintString(dst, v)
	}
	{
		v := v.Value
		dst = kbin.AppendVarintBytes(dst, v)
	}
	return dst
}
func (v *Header) ReadFrom(src []byte) error {
	b := kbin.Reader{Src: src}
	s := v
	{
		v := b.VarintString()
		s.Key = v
	}
	{
		v := b.VarintBytes()
		s.Value = v
	}
	return b.Complete()
}

// A Record is a Kafka v0.11.0.0 record. It corresponds to an individual
// message as it is written on the wire.
type Record struct {
	// Length is the length of this record on the wire of everything that
	// follows this field. It is an int32 encoded as a varint.
	Length int32

	// Attributes are record level attributes. This field currently is unused.
	Attributes int8

	// TimestampDelta is the millisecond delta of this record's timestamp
	// from the record's RecordBatch's FirstTimestamp.
	TimestampDelta int32

	// OffsetDelta is the delta of this record's offset from the record's
	// RecordBatch's FirstOffset.
	//
	// For producing, this is usually equal to the index of the record in
	// the record batch.
	OffsetDelta int32

	// Key is an blob of data for a record.
	//
	// Key's are usually used for hashing the record to specific Kafka partitions.
	Key []byte

	// Value is  a blob of data. This field is the main "message" portion of a
	// record.
	Value []byte

	// Headers are optional user provided metadata for records. Unlike normal
	// arrays, the number of headers is encoded as a varint.
	Headers []Header
}

func (v *Record) AppendTo(dst []byte) []byte {
	{
		v := v.Length
		dst = kbin.AppendVarint(dst, v)
	}
	{
		v := v.Attributes
		dst = kbin.AppendInt8(dst, v)
	}
	{
		v := v.TimestampDelta
		dst = kbin.AppendVarint(dst, v)
	}
	{
		v := v.OffsetDelta
		dst = kbin.AppendVarint(dst, v)
	}
	{
		v := v.Key
		dst = kbin.AppendVarintBytes(dst, v)
	}
	{
		v := v.Value
		dst = kbin.AppendVarintBytes(dst, v)
	}
	{
		v := v.Headers
		dst = kbin.AppendVarint(dst, int32(len(v)))
		for i := range v {
			v := &v[i]
			{
				v := v.Key
				dst = kbin.AppendVarintString(dst, v)
			}
			{
				v := v.Value
				dst = kbin.AppendVarintBytes(dst, v)
			}
		}
	}
	return dst
}
func (v *Record) ReadFrom(src []byte) error {
	b := kbin.Reader{Src: src}
	s := v
	{
		v := b.Varint()
		s.Length = v
	}
	{
		v := b.Int8()
		s.Attributes = v
	}
	{
		v := b.Varint()
		s.TimestampDelta = v
	}
	{
		v := b.Varint()
		s.OffsetDelta = v
	}
	{
		v := b.VarintBytes()
		s.Key = v
	}
	{
		v := b.VarintBytes()
		s.Value = v
	}
	{
		v := s.Headers
		a := v
		var l int32
		l = b.VarintArrayLen()
		if !b.Ok() {
			return b.Complete()
		}
		if l > 0 {
			a = make([]Header, l)
		}
		for i := int32(0); i < l; i++ {
			v := &a[i]
			s := v
			{
				v := b.VarintString()
				s.Key = v
			}
			{
				v := b.VarintBytes()
				s.Value = v
			}
		}
		v = a
		s.Headers = v
	}
	return b.Complete()
}

// RecordBatch is a Kafka concept that groups many individual records together
// in a more optimized format.
type RecordBatch struct {
	// FirstOffset is the first offset in a record batch.
	//
	// For producing, this is usually 0.
	FirstOffset int64

	// Length is the wire length of everything that follows this field.
	Length int32

	// PartitionLeaderEpoch is the leader epoch of the broker at the time
	// this batch was written. Kafka uses this for cluster communication,
	// but clients can also use this to better aid truncation detection.
	// See KIP-320. Producers should set this to -1.
	PartitionLeaderEpoch int32

	// Magic is the current "magic" number of this message format.
	// The current magic number is 2.
	Magic int8

	// CRC is the crc of everything that follows this field using the
	// Castagnoli polynomial.
	CRC int32

	// Attributes describe the records array of this batch.
	//
	// Bits 0 thru 3 correspond to compression:
	//   - 000 is no compression
	//   - 001 is gzip compression
	//   - 010 is snappy compression
	//   - 011 is lz4 compression
	//   - 100 is zstd compression (produce request version 7+)
	//
	// Bit 4 is the timestamp type, with 0 meaning CreateTime corresponding
	// to the timestamp being from the producer, and 1 meaning LogAppendTime
	// corresponding to the timestamp being from the broker.
	// Setting this to LogAppendTime will cause batches to be rejected.
	//
	// Bit 5 indicates whether the batch is part of a transaction (1 is yes).
	//
	// Bit 6 indicates if the batch includes a control message (1 is yes).
	// Control messages are used to enable transactions and are generated from
	// the broker. Clients should not return control batches to applications.
	Attributes int16

	// LastOffsetDelta is the offset of the last message in a batch. This is used
	// by the broker to ensure correct behavior even with batch compaction.
	LastOffsetDelta int32

	// FirstTimestamp is the timestamp (in milliseconds) of the first record
	// in a batch.
	FirstTimestamp int64

	// MaxTimestamp is the timestamp (in milliseconds) of the last record
	// in a batch. Similar to LastOffsetDelta, this is used to ensure correct
	// behavior with compacting.
	MaxTimestamp int64

	// ProducerID is the broker assigned producerID from an InitProducerID
	// request.
	//
	// Clients that wish to support idempotent messages and transactions must
	// set this field.
	//
	// Note that when not using transactions, any producer here is always
	// accepted (and the epoch is always zero). Outside transactions, the ID
	// is used only to deduplicate requests (and there must be at max 5
	// concurrent requests).
	ProducerID int64

	// ProducerEpoch is the broker assigned producerEpoch from an InitProducerID
	// request.
	//
	// Clients that wish to support idempotent messages and transactions must
	// set this field.
	ProducerEpoch int16

	// FirstSequence is the producer assigned sequence number used by the
	// broker to deduplicate messages.
	//
	// Clients that wish to support idempotent messages and transactions must
	// set this field.
	//
	// The sequence number for each record in a batch is OffsetDelta + FirstSequence.
	FirstSequence int32

	// NumRecords is the number of records in the array below.
	//
	// This is separate from Records due to the potential for records to be
	// compressed.
	NumRecords int32

	// Records contains records, either compressed or uncompressed.
	//
	// For uncompressed records, this is an array of records ([Record]).
	//
	// For compressed records, the length of the uncompressed array is kept
	// but everything that follows is compressed.
	//
	// The number of bytes is expected to be the Length field minus 49.
	Records []byte
}

func (v *RecordBatch) AppendTo(dst []byte) []byte {
	{
		v := v.FirstOffset
		dst = kbin.AppendInt64(dst, v)
	}
	{
		v := v.Length
		dst = kbin.AppendInt32(dst, v)
	}
	{
		v := v.PartitionLeaderEpoch
		dst = kbin.AppendInt32(dst, v)
	}
	{
		v := v.Magic
		dst = kbin.AppendInt8(dst, v)
	}
	{
		v := v.CRC
		dst = kbin.AppendInt32(dst, v)
	}
	{
		v := v.Attributes
		dst = kbin.AppendInt16(dst, v)
	}
	{
		v := v.LastOffsetDelta
		dst = kbin.AppendInt32(dst, v)
	}
	{
		v := v.FirstTimestamp
		dst = kbin.AppendInt64(dst, v)
	}
	{
		v := v.MaxTimestamp
		dst = kbin.AppendInt64(dst, v)
	}
	{
		v := v.ProducerID
		dst = kbin.AppendInt64(dst, v)
	}
	{
		v := v.ProducerEpoch
		dst = kbin.AppendInt16(dst, v)
	}
	{
		v := v.FirstSequence
		dst = kbin.AppendInt32(dst, v)
	}
	{
		v := v.NumRecords
		dst = kbin.AppendInt32(dst, v)
	}
	{
		v := v.Records
		dst = append(dst, v...)
	}
	return dst
}
func (v *RecordBatch) ReadFrom(src []byte) error {
	b := kbin.Reader{Src: src}
	s := v
	{
		v := b.Int64()
		s.FirstOffset = v
	}
	{
		v := b.Int32()
		s.Length = v
	}
	{
		v := b.Int32()
		s.PartitionLeaderEpoch = v
	}
	{
		v := b.Int8()
		s.Magic = v
	}
	{
		v := b.Int32()
		s.CRC = v
	}
	{
		v := b.Int16()
		s.Attributes = v
	}
	{
		v := b.Int32()
		s.LastOffsetDelta = v
	}
	{
		v := b.Int64()
		s.FirstTimestamp = v
	}
	{
		v := b.Int64()
		s.MaxTimestamp = v
	}
	{
		v := b.Int64()
		s.ProducerID = v
	}
	{
		v := b.Int16()
		s.ProducerEpoch = v
	}
	{
		v := b.Int32()
		s.FirstSequence = v
	}
	{
		v := b.Int32()
		s.NumRecords = v
	}
	{
		v := b.Span(int(s.Length) - 49)
		s.Records = v
	}
	return b.Complete()
}

type ProduceRequestTopicPartition struct {
	// Partition is a partition to send a record batch to.
	Partition int32

	// Records is a batch of records to write to a topic's partition.
	//
	// For Kafka pre 0.11.0, the contents of the byte array is a serialized
	// message set. At or after 0.11.0, the contents of the byte array is a
	// serialized RecordBatch.
	Records []byte
}
type ProduceRequestTopic struct {
	// Topic is a topic to send record batches to.
	Topic string

	// Partitions is an array of partitions to send record batches to.
	Partitions []ProduceRequestTopicPartition
}

// ProduceRequest issues records to be created to Kafka.
//
// Kafka 0.9.0 (v1) changed Records from MessageSet v0 to MessageSet v1.
// Kafka 0.11.0 (v3) again changed Records to RecordBatch.
//
// Note that the special client ID "__admin_client" will allow you to produce
// records to internal topics. This is generally recommended if you want to
// break your Kafka cluster.
type ProduceRequest struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	// TransactionID is the transaction ID to use for this request, allowing for
	// exactly once semantics.
	TransactionID *string // v3+

	// Acks specifies the number of acks that the partition leaders must receive
	// from in sync replicas before considering a record batch fully written.
	//
	// Valid values are -1, 0, or 1 corresponding to all, none, or the leader only.
	//
	// Note that if no acks are requested, Kafka will close the connection
	// if any topic or partition errors to trigger a client metadata refresh.
	Acks int16

	// TimeoutMillis is the millisecond timeout of this request.
	TimeoutMillis int32

	// Topics is an array of topics to send record batches to.
	Topics []ProduceRequestTopic
}

func (*ProduceRequest) Key() int16                 { return 0 }
func (*ProduceRequest) MaxVersion() int16          { return 8 }
func (v *ProduceRequest) SetVersion(version int16) { v.Version = version }
func (v *ProduceRequest) GetVersion() int16        { return v.Version }
func (v *ProduceRequest) IsFlexible() bool         { return false }
func (v *ProduceRequest) ResponseKind() Response   { return &ProduceResponse{Version: v.Version} }

func (v *ProduceRequest) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	if version >= 3 {
		v := v.TransactionID
		dst = kbin.AppendNullableString(dst, v)
	}
	{
		v := v.Acks
		dst = kbin.AppendInt16(dst, v)
	}
	{
		v := v.TimeoutMillis
		dst = kbin.AppendInt32(dst, v)
	}
	{
		v := v.Topics
		dst = kbin.AppendArrayLen(dst, len(v))
		for i := range v {
			v := &v[i]
			{
				v := v.Topic
				dst = kbin.AppendString(dst, v)
			}
			{
				v := v.Partitions
				dst = kbin.AppendArrayLen(dst, len(v))
				for i := range v {
					v := &v[i]
					{
						v := v.Partition
						dst = kbin.AppendInt32(dst, v)
					}
					{
						v := v.Records
						dst = kbin.AppendNullableBytes(dst, v)
					}
				}
			}
		}
	}
	return dst
}
func (v *ProduceRequest) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	b := kbin.Reader{Src: src}
	s := v
	if version >= 3 {
		v := b.NullableString()
		s.TransactionID = v
	}
	{
		v := b.Int16()
		s.Acks = v
	}
	{
		v := b.Int32()
		s.TimeoutMillis = v
	}
	{
		v := s.Topics
		a := v
		var l int32
		l = b.ArrayLen()
		if !b.Ok() {
			return b.Complete()
		}
		if l > 0 {
			a = make([]ProduceRequestTopic, l)
		}
		for i := int32(0); i < l; i++ {
			v := &a[i]
			s := v
			{
				v := b.String()
				s.Topic = v
			}
			{
				v := s.Partitions
				a := v
				var l int32
				l = b.ArrayLen()
				if !b.Ok() {
					return b.Complete()
				}
				if l > 0 {
					a = make([]ProduceRequestTopicPartition, l)
				}
				for i := int32(0); i < l; i++ {
					v := &a[i]
					s := v
					{
						v := b.Int32()
						s.Partition = v
					}
					{
						v := b.NullableBytes()
						s.Records = v
					}
				}
				v = a
				s.Partitions = v
			}
		}
		v = a
		s.Topics = v
	}
	return b.Complete()
}

type ProduceResponseTopicPartitionErrorRecord struct {
	// RelativeOffset is the offset of the record that caused problems.
	RelativeOffset int32

	// ErrorMessage is the error of this record.
	ErrorMessage *string
}
type ProduceResponseTopicPartition struct {
	// Partition is the partition this response pertains to.
	Partition int32

	// ErrorCode is any error for a topic/partition in the request.
	// There are many error codes for produce requests.
	//
	// TRANSACTIONAL_ID_AUTHORIZATION_FAILED is returned for all topics and
	// partitions if the request had a transactional ID but the client
	// is not authorized for transactions.
	//
	// CLUSTER_AUTHORIZATION_FAILED is returned for all topics and partitions
	// if the request was idempotent but the client is not authorized
	// for idempotent requests.
	//
	// TOPIC_AUTHORIZATION_FAILED is returned for all topics the client
	// is not authorized to talk to.
	//
	// INVALID_REQUIRED_ACKS is returned if the request contained an invalid
	// number for "acks".
	//
	// CORRUPT_MESSAGE is returned for many reasons, generally related to
	// problems with messages (invalid magic, size mismatch, etc.).
	//
	// MESSAGE_TOO_LARGE is returned if a record batch is larger than the
	// broker's configured max.message.size.
	//
	// RECORD_LIST_TOO_LARGE is returned if the record batch is larger than
	// the broker's segment.bytes.
	//
	// INVALID_TIMESTAMP is returned if the record batch uses LogAppendTime
	// or if the timestamp delta from when the broker receives the message
	// is more than the broker's log.message.timestamp.difference.max.ms.
	//
	// UNSUPPORTED_FOR_MESSAGE_FORMAT is returned if using a Kafka v2 message
	// format (i.e. RecordBatch) feature (idempotence) while sending v1
	// messages (i.e. a MessageSet).
	//
	// KAFKA_STORAGE_ERROR is returned if the log directory for a partition
	// is offline.
	//
	// NOT_ENOUGH_REPLICAS is returned if all acks are required, but there
	// are not enough in sync replicas yet.
	//
	// NOT_ENOUGH_REPLICAS_AFTER_APPEND is returned on old Kafka versions
	// (pre 0.11.0.0) when a message was written to disk and then Kafka
	// noticed not enough replicas existed to replicate the message.
	//
	// DUPLICATE_SEQUENCE_NUMBER is returned for Kafka <1.1.0 when a
	// sequence number is detected as a duplicate. After, out of order
	// is returned.
	//
	// UNKNOWN_TOPIC_OR_PARTITION is returned if the topic or partition
	// is unknown.
	//
	// NOT_LEADER_FOR_PARTITION is returned if the broker is not a leader
	// for this partition. This means that the client has stale metadata.
	//
	// INVALID_PRODUCER_EPOCH is returned if the produce request was
	// attempted with an old epoch. Either there is a newer producer using
	// the same transaction ID, or the transaction ID used has expired.
	//
	// UNKNOWN_PRODUCER_ID, added in Kafka 1.0.0 (message format v5+) is
	// returned if the producer used an ID that Kafka does not know about or
	// if the request has a larger sequence number than Kafka expects.  The
	// LogStartOffset must be checked in this case. If the offset is greater
	// than the last acknowledged offset, then no data loss has occurred; the
	// client just sent data so long ago that Kafka rotated the partition out
	// of existence and no longer knows of this producer ID. In this case,
	// reset your sequence numbers to 0. If the log start offset is equal to
	// or less than what the client sent prior, then data loss has occurred.
	// See KAFKA-5793 for more details. NOTE: Unfortunately, even UNKNOWN_PRODUCER_ID
	// is unsafe to handle, so this error should likely be treated the same
	// as OUT_OF_ORDER_SEQUENCE_NUMER. See KIP-360 for more details.
	//
	// OUT_OF_ORDER_SEQUENCE_NUMBER is sent if the batch's FirstSequence was
	// not what it should be (the last FirstSequence, plus the number of
	// records in the last batch, plus one). After 1.0.0, this generally
	// means data loss. Before, there could be confusion on if the broker
	// actually rotated the partition out of existence (this is why
	// UNKNOWN_PRODUCER_ID was introduced).
	ErrorCode int16

	// BaseOffset is the offset that the records in the produce request began
	// at in the partition.
	BaseOffset int64

	// LogAppendTime is the millisecond that records were appended to the
	// partition inside Kafka. This is only not -1 if records were written
	// with the log append time flag (which producers cannot do).
	LogAppendTime int64 // v2+

	// LogStartOffset, introduced in Kafka 1.0.0, can be used to see if an
	// UNKNOWN_PRODUCER_ID means Kafka rotated records containing the used
	// producer ID out of existence, or if Kafka lost data.
	LogStartOffset int64 // v5+

	// ErrorRecords are indices of individual records that caused a batch
	// to error. This was added for KIP-467.
	ErrorRecords []ProduceResponseTopicPartitionErrorRecord // v8+

	// ErrorMessage is the global error message of of what caused this batch
	// to error.
	ErrorMessage *string // v8+
}
type ProduceResponseTopic struct {
	// Topic is the topic this response pertains to.
	Topic string

	// Partitions is an array of responses for the partition's that
	// batches were sent to.
	Partitions []ProduceResponseTopicPartition
}

// ProduceResponse is returned from a ProduceRequest.
type ProduceResponse struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	// Topics is an array of responses for the topic's that batches were sent
	// to.
	Topics []ProduceResponseTopic

	// ThrottleMillis is how long of a throttle Kafka will apply to the client
	// after this request.
	// For Kafka < 2.0.0, the throttle is applied before issuing a response.
	// For Kafka >= 2.0.0, the throttle is applied after issuing a response.
	ThrottleMillis int32 // v1+
}

func (*ProduceResponse) Key() int16                 { return 0 }
func (*ProduceResponse) MaxVersion() int16          { return 8 }
func (v *ProduceResponse) SetVersion(version int16) { v.Version = version }
func (v *ProduceResponse) GetVersion() int16        { return v.Version }
func (v *ProduceResponse) IsFlexible() bool         { return false }
func (v *ProduceResponse) RequestKind() Request     { return &ProduceRequest{Version: v.Version} }

func (v *ProduceResponse) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	{
		v := v.Topics
		dst = kbin.AppendArrayLen(dst, len(v))
		for i := range v {
			v := &v[i]
			{
				v := v.Topic
				dst = kbin.AppendString(dst, v)
			}
			{
				v := v.Partitions
				dst = kbin.AppendArrayLen(dst, len(v))
				for i := range v {
					v := &v[i]
					{
						v := v.Partition
						dst = kbin.AppendInt32(dst, v)
					}
					{
						v := v.ErrorCode
						dst = kbin.AppendInt16(dst, v)
					}
					{
						v := v.BaseOffset
						dst = kbin.AppendInt64(dst, v)
					}
					if version >= 2 {
						v := v.LogAppendTime
						dst = kbin.AppendInt64(dst, v)
					}
					if version >= 5 {
						v := v.LogStartOffset
						dst = kbin.AppendInt64(dst, v)
					}
					if version >= 8 {
						v := v.ErrorRecords
						dst = kbin.AppendArrayLen(dst, len(v))
						for i := range v {
							v := &v[i]
							{
								v := v.RelativeOffset
								dst = kbin.AppendInt32(dst, v)
							}
							{
								v := v.ErrorMessage
								dst = kbin.AppendNullableString(dst, v)
							}
						}
					}
					if version >= 8 {
						v := v.ErrorMessage
						dst = kbin.AppendNullableString(dst, v)
					}
				}
			}
		}
	}
	if version >= 1 {
		v := v.ThrottleMillis
		dst = kbin.AppendInt32(dst, v)
	}
	return dst
}
func (v *ProduceResponse) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	b := kbin.Reader{Src: src}
	s := v
	{
		v := s.Topics
		a := v
		var l int32
		l = b.ArrayLen()
		if !b.Ok() {
			return b.Complete()
		}
		if l > 0 {
			a = make([]ProduceResponseTopic, l)
		}
		for i := int32(0); i < l; i++ {
			v := &a[i]
			s := v
			{
				v := b.String()
				s.Topic = v
			}
			{
				v := s.Partitions
				a := v
				var l int32
				l = b.ArrayLen()
				if !b.Ok() {
					return b.Complete()
				}
				if l > 0 {
					a = make([]ProduceResponseTopicPartition, l)
				}
				for i := int32(0); i < l; i++ {
					v := &a[i]
					s := v
					{
						v := b.Int32()
						s.Partition = v
					}
					{
						v := b.Int16()
						s.ErrorCode = v
					}
					{
						v := b.Int64()
						s.BaseOffset = v
					}
					if version >= 2 {
						v := b.Int64()
						s.LogAppendTime = v
					}
					if version >= 5 {
						v := b.Int64()
						s.LogStartOffset = v
					}
					if version >= 8 {
						v := s.ErrorRecords
						a := v
						var l int32
						l = b.ArrayLen()
						if !b.Ok() {
							return b.Complete()
						}
						if l > 0 {
							a = make([]ProduceResponseTopicPartitionErrorRecord, l)
						}
						for i := int32(0); i < l; i++ {
							v := &a[i]
							s := v
							{
								v := b.Int32()
								s.RelativeOffset = v
							}
							{
								v := b.NullableString()
								s.ErrorMessage = v
							}
						}
						v = a
						s.ErrorRecords = v
					}
					if version >= 8 {
						v := b.NullableString()
						s.ErrorMessage = v
					}
				}
				v = a
				s.Partitions = v
			}
		}
		v = a
		s.Topics = v
	}
	if version >= 1 {
		v := b.Int32()
		s.ThrottleMillis = v
	}
	return b.Complete()
}

type FetchRequestTopicPartition struct {
	// Partition is a partition in a topic to try to fetch records for.
	Partition int32

	// CurrentLeaderEpoch, proposed in KIP-320 and introduced in Kafka 2.1.0,
	// allows brokers to check if the client is fenced (has an out of date
	// leader) or is using an unknown leader.
	//
	// The initial leader epoch can be determined from a MetadataResponse.
	// To skip log truncation checking, use -1.
	CurrentLeaderEpoch int32 // v9+

	// FetchOffset is the offset to begin the fetch from. Kafka will
	// return records at and after this offset.
	FetchOffset int64

	// LogStartOffset is a broker-follower only field added for KIP-107.
	// This is the start offset of the partition in a follower.
	LogStartOffset int64 // v5+

	// PartitionMaxBytes is the maximum bytes to return for this partition.
	// This can be used to limit how many bytes an individual partition in
	// a request is allotted so that it does not dominate all of MaxBytes.
	PartitionMaxBytes int32
}
type FetchRequestTopic struct {
	// Topic is a topic to try to fetch records for.
	Topic string

	// Partitions contains partitions in a topic to try to fetch records for.
	Partitions []FetchRequestTopicPartition
}
type FetchRequestForgottenTopic struct {
	// Topic is a topic to remove from being tracked (with the partitions below).
	Topic string

	// Partitions are partitions to remove from tracking for a topic.
	Partitions []int32
}

// FetchRequest is a long-poll request of records from Kafka.
//
// Kafka 0.11.0.0 released v4 and changed the returned RecordBatches to contain
// the RecordBatch type. Prior, Kafka used the MessageSet type (and, for v0 and
// v1, Kafka used a different type).
//
// Note that starting in v3, Kafka began processing partitions in order,
// meaning the order of partitions in the fetch request is important due to
// potential size constraints.
type FetchRequest struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	// ReplicaID is the broker ID of performing the fetch request. Standard
	// clients should use -1. To be a "debug" replica, use -2. The debug
	// replica can be used to fetch messages from non-leaders.
	ReplicaID int32

	// MaxWaitMillis is how long to wait for MinBytes to be hit before a broker
	// responds to a fetch request.
	MaxWaitMillis int32

	// MinBytes is the minimum amount of bytes to attempt to read before a broker
	// responds to a fetch request.
	MinBytes int32

	// MaxBytes is the maximum amount of bytes to read in a fetch request. The
	// response can exceed MaxBytes if the first record in the first non-empty
	// partition is larger than MaxBytes.
	MaxBytes int32 // v3+

	// IsolationLevel changes which messages are fetched. Follower replica ID's
	// (non-negative, non-standard-client) fetch from the end.
	//
	// Standard clients fetch from the high watermark, which corresponds to
	// IsolationLevel 0, READ_UNCOMMITTED.
	//
	// To only read committed records, use IsolationLevel 1, corresponding to
	// READ_COMMITTED.
	IsolationLevel int8 // v4+

	// SessionID is used to potentially reduce the amount of back and forth
	// data between a client and a broker. If opting in to sessions, the first
	// ID used should be 0, and thereafter (until session resets) the ID should
	// be the ID returned in the fetch response.
	//
	// Read KIP-227 for more details. Use -1 if you want to disable sessions.
	SessionID int32 // v7+

	// SessionEpoch is the session epoch for this request if using sessions.
	//
	// Read KIP-227 for more details. Use -1 if you are not using sessions.
	SessionEpoch int32 // v7+

	// Topic contains topics to try to fetch records for.
	Topics []FetchRequestTopic

	// ForgottenTopics contains topics and partitions that a fetch session
	// wants to remove from its session.
	//
	// See KIP-227 for more details.
	ForgottenTopics []FetchRequestForgottenTopic // v7+

	// Rack of the consumer making this request (see KIP-392; introduced in
	// Kafka 2.2.0).
	Rack string // v11+
}

func (*FetchRequest) Key() int16                 { return 1 }
func (*FetchRequest) MaxVersion() int16          { return 11 }
func (v *FetchRequest) SetVersion(version int16) { v.Version = version }
func (v *FetchRequest) GetVersion() int16        { return v.Version }
func (v *FetchRequest) IsFlexible() bool         { return false }
func (v *FetchRequest) ResponseKind() Response   { return &FetchResponse{Version: v.Version} }

func (v *FetchRequest) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	{
		v := v.ReplicaID
		dst = kbin.AppendInt32(dst, v)
	}
	{
		v := v.MaxWaitMillis
		dst = kbin.AppendInt32(dst, v)
	}
	{
		v := v.MinBytes
		dst = kbin.AppendInt32(dst, v)
	}
	if version >= 3 {
		v := v.MaxBytes
		dst = kbin.AppendInt32(dst, v)
	}
	if version >= 4 {
		v := v.IsolationLevel
		dst = kbin.AppendInt8(dst, v)
	}
	if version >= 7 {
		v := v.SessionID
		dst = kbin.AppendInt32(dst, v)
	}
	if version >= 7 {
		v := v.SessionEpoch
		dst = kbin.AppendInt32(dst, v)
	}
	{
		v := v.Topics
		dst = kbin.AppendArrayLen(dst, len(v))
		for i := range v {
			v := &v[i]
			{
				v := v.Topic
				dst = kbin.AppendString(dst, v)
			}
			{
				v := v.Partitions
				dst = kbin.AppendArrayLen(dst, len(v))
				for i := range v {
					v := &v[i]
					{
						v := v.Partition
						dst = kbin.AppendInt32(dst, v)
					}
					if version >= 9 {
						v := v.CurrentLeaderEpoch
						dst = kbin.AppendInt32(dst, v)
					}
					{
						v := v.FetchOffset
						dst = kbin.AppendInt64(dst, v)
					}
					if version >= 5 {
						v := v.LogStartOffset
						dst = kbin.AppendInt64(dst, v)
					}
					{
						v := v.PartitionMaxBytes
						dst = kbin.AppendInt32(dst, v)
					}
				}
			}
		}
	}
	if version >= 7 {
		v := v.ForgottenTopics
		dst = kbin.AppendArrayLen(dst, len(v))
		for i := range v {
			v := &v[i]
			{
				v := v.Topic
				dst = kbin.AppendString(dst, v)
			}
			{
				v := v.Partitions
				dst = kbin.AppendArrayLen(dst, len(v))
				for i := range v {
					v := v[i]
					dst = kbin.AppendInt32(dst, v)
				}
			}
		}
	}
	if version >= 11 {
		v := v.Rack
		dst = kbin.AppendString(dst, v)
	}
	return dst
}
func (v *FetchRequest) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	b := kbin.Reader{Src: src}
	s := v
	{
		v := b.Int32()
		s.ReplicaID = v
	}
	{
		v := b.Int32()
		s.MaxWaitMillis = v
	}
	{
		v := b.Int32()
		s.MinBytes = v
	}
	if version >= 3 {
		v := b.Int32()
		s.MaxBytes = v
	}
	if version >= 4 {
		v := b.Int8()
		s.IsolationLevel = v
	}
	if version >= 7 {
		v := b.Int32()
		s.SessionID = v
	}
	if version >= 7 {
		v := b.Int32()
		s.SessionEpoch = v
	}
	{
		v := s.Topics
		a := v
		var l int32
		l = b.ArrayLen()
		if !b.Ok() {
			return b.Complete()
		}
		if l > 0 {
			a = make([]FetchRequestTopic, l)
		}
		for i := int32(0); i < l; i++ {
			v := &a[i]
			s := v
			{
				v := b.String()
				s.Topic = v
			}
			{
				v := s.Partitions
				a := v
				var l int32
				l = b.ArrayLen()
				if !b.Ok() {
					return b.Complete()
				}
				if l > 0 {
					a = make([]FetchRequestTopicPartition, l)
				}
				for i := int32(0); i < l; i++ {
					v := &a[i]
					s := v
					{
						v := b.Int32()
						s.Partition = v
					}
					if version >= 9 {
						v := b.Int32()
						s.CurrentLeaderEpoch = v
					}
					{
						v := b.Int64()
						s.FetchOffset = v
					}
					if version >= 5 {
						v := b.Int64()
						s.LogStartOffset = v
					}
					{
						v := b.Int32()
						s.PartitionMaxBytes = v
					}
				}
				v = a
				s.Partitions = v
			}
		}
		v = a
		s.Topics = v
	}
	if version >= 7 {
		v := s.ForgottenTopics
		a := v
		var l int32
		l = b.ArrayLen()
		if !b.Ok() {
			return b.Complete()
		}
		if l > 0 {
			a = make([]FetchRequestForgottenTopic, l)
		}
		for i := int32(0); i < l; i++ {
			v := &a[i]
			s := v
			{
				v := b.String()
				s.Topic = v
			}
			{
				v := s.Partitions
				a := v
				var l int32
				l = b.ArrayLen()
				if !b.Ok() {
					return b.Complete()
				}
				if l > 0 {
					a = make([]int32, l)
				}
				for i := int32(0); i < l; i++ {
					v := b.Int32()
					a[i] = v
				}
				v = a
				s.Partitions = v
			}
		}
		v = a
		s.ForgottenTopics = v
	}
	if version >= 11 {
		v := b.String()
		s.Rack = v
	}
	return b.Complete()
}

type FetchResponseTopicPartitionAbortedTransaction struct {
	// ProducerID is the producer ID that caused this aborted transaction.
	ProducerID int64

	// FirstOffset is the offset where this aborted transaction began.
	FirstOffset int64
}
type FetchResponseTopicPartition struct {
	// Partition is a partition in a topic that records may have been
	// received for.
	Partition int32

	// ErrorCode is an error returned for an individual partition in a
	// fetch request.
	//
	// TOPIC_AUTHORIZATION_FAILED is returned if the client is not
	// authorized to read the partition.
	//
	// UNKNOWN_TOPIC_OR_PARTITION is returned if the topic or partition
	// does not exist on this broker.
	//
	// UNSUPPORTED_COMPRESSION_TYPE is returned if the request version was
	// under 10 and the batch is compressed with zstd.
	//
	// UNSUPPORTED_VERSION is returned if the broker has records newer than
	// the client can support (magic value) and the broker has disabled
	// message downconversion.
	//
	// NOT_LEADER_FOR_PARTITION is returned if requesting data for this
	// partition as a follower (non-negative ReplicaID) and the broker
	// is not the leader for this partition.
	//
	// REPLICA_NOT_AVAILABLE is returned if the partition exists but
	// the requested broker is not the leader for it.
	//
	// KAFKA_STORAGE_EXCEPTION is returned if the requested partition is
	// offline.
	//
	// UNKNOWN_LEADER_EPOCH is returned if the request used a larger leader
	// epoch than the broker knows of.
	//
	// FENCED_LEADER_EPOCH is returned if the request used a smaller leader
	// epoch than the broker is at (see KIP-320).
	//
	// OFFSET_OUT_OF_RANGE is returned if requesting an offset past the
	// current end offset or before the beginning offset.
	ErrorCode int16

	// HighWatermark is the current high watermark for this partition,
	// that is, the current offset that is on all in sync replicas.
	HighWatermark int64

	// LastStableOffset is the offset at which all prior offsets have
	// been "decided". Non transactional records are always decided
	// immediately, but transactional records are only decided once
	// they are commited or aborted.
	//
	// The LastStableOffset will always be at or under the HighWatermark.
	LastStableOffset int64 // v4+

	// LogStartOffset is the beginning offset for this partition.
	// This field was added for KIP-107.
	LogStartOffset int64 // v5+

	// AbortedTransactions is an array of aborted transactions within the
	// returned offset range. This is only returned if the requested
	// isolation level was READ_COMMITTED.
	AbortedTransactions []FetchResponseTopicPartitionAbortedTransaction // v4+

	// PreferredReadReplica is the preferred replica for the consumer
	// to use on its next fetch request. See KIP-392.
	PreferredReadReplica int32 // v11+

	// RecordBatches is an array of record batches for a topic partition.
	//
	// This is encoded as a raw byte array, with the standard int32 size
	// prefix. One important catch to note is that the final element of the
	// array may be **partial**. This is an optimization in Kafka that
	// clients must deal with by discarding a partial trailing batch.
	//
	// Starting v2, this transitioned to the MessageSet v1 format (and this
	// would contain many MessageV1 structs).
	//
	// Starting v4, this transitioned to the RecordBatch format (thus this
	// contains many RecordBatch structs).
	RecordBatches []byte
}
type FetchResponseTopic struct {
	// Topic is a topic that records may have been received for.
	Topic string

	// Partitions contains partitions in a topic that records may have
	// been received for.
	Partitions []FetchResponseTopicPartition
}

// FetchResponse is returned from a FetchRequest.
type FetchResponse struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	// ThrottleMillis is how long of a throttle Kafka will apply to the client
	// after this request.
	// For Kafka < 2.0.0, the throttle is applied before issuing a response.
	// For Kafka >= 2.0.0, the throttle is applied after issuing a response.
	ThrottleMillis int32 // v1+

	// ErrorCode is a full-response error code for a fetch request. This was
	// added in support of KIP-227. This error is only non-zero if using fetch
	// sessions.
	//
	// FETCH_SESSION_ID_NOT_FOUND is returned if the request used a
	// session ID that the broker does not know of.
	//
	// INVALID_FETCH_SESSION_EPOCH is returned if the request used an
	// invalid session epoch.
	ErrorCode int16 // v7+

	// SessionID is the id for this session if using sessions.
	//
	// See KIP-227 for more details.
	SessionID int32 // v7+

	// Topics contains an array of topic partitions and the records received
	// for them.
	Topics []FetchResponseTopic
}

func (*FetchResponse) Key() int16                 { return 1 }
func (*FetchResponse) MaxVersion() int16          { return 11 }
func (v *FetchResponse) SetVersion(version int16) { v.Version = version }
func (v *FetchResponse) GetVersion() int16        { return v.Version }
func (v *FetchResponse) IsFlexible() bool         { return false }
func (v *FetchResponse) RequestKind() Request     { return &FetchRequest{Version: v.Version} }

func (v *FetchResponse) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	if version >= 1 {
		v := v.ThrottleMillis
		dst = kbin.AppendInt32(dst, v)
	}
	if version >= 7 {
		v := v.ErrorCode
		dst = kbin.AppendInt16(dst, v)
	}
	if version >= 7 {
		v := v.SessionID
		dst = kbin.AppendInt32(dst, v)
	}
	{
		v := v.Topics
		dst = kbin.AppendArrayLen(dst, len(v))
		for i := range v {
			v := &v[i]
			{
				v := v.Topic
				dst = kbin.AppendString(dst, v)
			}
			{
				v := v.Partitions
				dst = kbin.AppendArrayLen(dst, len(v))
				for i := range v {
					v := &v[i]
					{
						v := v.Partition
						dst = kbin.AppendInt32(dst, v)
					}
					{
						v := v.ErrorCode
						dst = kbin.AppendInt16(dst, v)
					}
					{
						v := v.HighWatermark
						dst = kbin.AppendInt64(dst, v)
					}
					if version >= 4 {
						v := v.LastStableOffset
						dst = kbin.AppendInt64(dst, v)
					}
					if version >= 5 {
						v := v.LogStartOffset
						dst = kbin.AppendInt64(dst, v)
					}
					if version >= 4 {
						v := v.AbortedTransactions
						dst = kbin.AppendNullableArrayLen(dst, len(v), v == nil)
						for i := range v {
							v := &v[i]
							{
								v := v.ProducerID
								dst = kbin.AppendInt64(dst, v)
							}
							{
								v := v.FirstOffset
								dst = kbin.AppendInt64(dst, v)
							}
						}
					}
					if version >= 11 {
						v := v.PreferredReadReplica
						dst = kbin.AppendInt32(dst, v)
					}
					{
						v := v.RecordBatches
						dst = kbin.AppendNullableBytes(dst, v)
					}
				}
			}
		}
	}
	return dst
}
func (v *FetchResponse) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	b := kbin.Reader{Src: src}
	s := v
	if version >= 1 {
		v := b.Int32()
		s.ThrottleMillis = v
	}
	if version >= 7 {
		v := b.Int16()
		s.ErrorCode = v
	}
	if version >= 7 {
		v := b.Int32()
		s.SessionID = v
	}
	{
		v := s.Topics
		a := v
		var l int32
		l = b.ArrayLen()
		if !b.Ok() {
			return b.Complete()
		}
		if l > 0 {
			a = make([]FetchResponseTopic, l)
		}
		for i := int32(0); i < l; i++ {
			v := &a[i]
			s := v
			{
				v := b.String()
				s.Topic = v
			}
			{
				v := s.Partitions
				a := v
				var l int32
				l = b.ArrayLen()
				if !b.Ok() {
					return b.Complete()
				}
				if l > 0 {
					a = make([]FetchResponseTopicPartition, l)
				}
				for i := int32(0); i < l; i++ {
					v := &a[i]
					s := v
					{
						v := b.Int32()
						s.Partition = v
					}
					{
						v := b.Int16()
						s.ErrorCode = v
					}
					{
						v := b.Int64()
						s.HighWatermark = v
					}
					if version >= 4 {
						v := b.Int64()
						s.LastStableOffset = v
					}
					if version >= 5 {
						v := b.Int64()
						s.LogStartOffset = v
					}
					if version >= 4 {
						v := s.AbortedTransactions
						a := v
						var l int32
						l = b.ArrayLen()
						if version < 0 || l == 0 {
							a = []FetchResponseTopicPartitionAbortedTransaction{}
						}
						if !b.Ok() {
							return b.Complete()
						}
						if l > 0 {
							a = make([]FetchResponseTopicPartitionAbortedTransaction, l)
						}
						for i := int32(0); i < l; i++ {
							v := &a[i]
							s := v
							{
								v := b.Int64()
								s.ProducerID = v
							}
							{
								v := b.Int64()
								s.FirstOffset = v
							}
						}
						v = a
						s.AbortedTransactions = v
					}
					if version >= 11 {
						v := b.Int32()
						s.PreferredReadReplica = v
					}
					{
						v := b.NullableBytes()
						s.RecordBatches = v
					}
				}
				v = a
				s.Partitions = v
			}
		}
		v = a
		s.Topics = v
	}
	return b.Complete()
}

type ListOffsetsRequestTopicPartition struct {
	// Partition is a partition of a topic to get offsets for.
	Partition int32

	// CurrentLeaderEpoch, proposed in KIP-320 and introduced in Kafka 2.1.0,
	// allows brokers to check if the client is fenced (has an out of date
	// leader) or is using an unknown leader.
	//
	// The initial leader epoch can be determined from a MetadataResponse.
	// To skip log truncation checking, use -1.
	CurrentLeaderEpoch int32 // v4+

	// Timestamp controls which offset to return in a response for this
	// partition.
	//
	// The offset returned will be the one of the message whose timestamp is
	// the first timestamp greater than or equal to this requested timestamp.
	//
	// If no such message is found, the log end offset is returned.
	//
	// There exist two special timestamps: -2 corresponds to the earliest
	// timestamp, and -1 corresponds to the latest.
	Timestamp int64

	// MaxNumOffsets is the maximum number of offsets to report.
	// This was removed after v0.
	MaxNumOffsets int32
}
type ListOffsetsRequestTopic struct {
	// Topic is a topic to get offsets for.
	Topic string

	// Partitions is an array of partitions in a topic to get offsets for.
	Partitions []ListOffsetsRequestTopicPartition
}

// ListOffsetsRequest requests partition offsets from Kafka for use in
// consuming records.
//
// Version 5, introduced in Kafka 2.2.0, is the same as version 4. Using
// version 5 implies you support Kafka's OffsetNotAvailableException
// See KIP-207 for details.
type ListOffsetsRequest struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	// ReplicaID is the broker ID to get offsets from. As a Kafka client, use -1.
	// The consumer replica ID (-1) causes requests to only succeed if issued
	// against the leader broker.
	ReplicaID int32

	// IsolationLevel configures which record offsets are visible in the
	// response. READ_UNCOMMITTED (0) makes all records visible. READ_COMMITTED
	// (1) makes non-transactional and committed transactional records visible.
	// READ_COMMITTED means all offsets smaller than the last stable offset and
	// includes aborted transactions (allowing consumers to discard aborted
	// records).
	IsolationLevel int8 // v2+

	// Topics is an array of topics to get offsets for.
	Topics []ListOffsetsRequestTopic
}

func (*ListOffsetsRequest) Key() int16                 { return 2 }
func (*ListOffsetsRequest) MaxVersion() int16          { return 5 }
func (v *ListOffsetsRequest) SetVersion(version int16) { v.Version = version }
func (v *ListOffsetsRequest) GetVersion() int16        { return v.Version }
func (v *ListOffsetsRequest) IsFlexible() bool         { return false }
func (v *ListOffsetsRequest) ResponseKind() Response   { return &ListOffsetsResponse{Version: v.Version} }

func (v *ListOffsetsRequest) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	{
		v := v.ReplicaID
		dst = kbin.AppendInt32(dst, v)
	}
	if version >= 2 {
		v := v.IsolationLevel
		dst = kbin.AppendInt8(dst, v)
	}
	{
		v := v.Topics
		dst = kbin.AppendArrayLen(dst, len(v))
		for i := range v {
			v := &v[i]
			{
				v := v.Topic
				dst = kbin.AppendString(dst, v)
			}
			{
				v := v.Partitions
				dst = kbin.AppendArrayLen(dst, len(v))
				for i := range v {
					v := &v[i]
					{
						v := v.Partition
						dst = kbin.AppendInt32(dst, v)
					}
					if version >= 4 {
						v := v.CurrentLeaderEpoch
						dst = kbin.AppendInt32(dst, v)
					}
					{
						v := v.Timestamp
						dst = kbin.AppendInt64(dst, v)
					}
					if version >= 0 && version <= 0 {
						v := v.MaxNumOffsets
						dst = kbin.AppendInt32(dst, v)
					}
				}
			}
		}
	}
	return dst
}
func (v *ListOffsetsRequest) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	b := kbin.Reader{Src: src}
	s := v
	{
		v := b.Int32()
		s.ReplicaID = v
	}
	if version >= 2 {
		v := b.Int8()
		s.IsolationLevel = v
	}
	{
		v := s.Topics
		a := v
		var l int32
		l = b.ArrayLen()
		if !b.Ok() {
			return b.Complete()
		}
		if l > 0 {
			a = make([]ListOffsetsRequestTopic, l)
		}
		for i := int32(0); i < l; i++ {
			v := &a[i]
			s := v
			{
				v := b.String()
				s.Topic = v
			}
			{
				v := s.Partitions
				a := v
				var l int32
				l = b.ArrayLen()
				if !b.Ok() {
					return b.Complete()
				}
				if l > 0 {
					a = make([]ListOffsetsRequestTopicPartition, l)
				}
				for i := int32(0); i < l; i++ {
					v := &a[i]
					s := v
					{
						v := b.Int32()
						s.Partition = v
					}
					if version >= 4 {
						v := b.Int32()
						s.CurrentLeaderEpoch = v
					}
					{
						v := b.Int64()
						s.Timestamp = v
					}
					if version >= 0 && version <= 0 {
						v := b.Int32()
						s.MaxNumOffsets = v
					}
				}
				v = a
				s.Partitions = v
			}
		}
		v = a
		s.Topics = v
	}
	return b.Complete()
}

type ListOffsetsResponseTopicPartition struct {
	// Partition is the partition this array slot is for.
	Partition int32

	// ErrorCode is any error for a topic partition in a ListOffsets request.
	//
	// TOPIC_AUTHORIZATION_FAILED is returned if the client is not authorized
	// to describe the topic.
	//
	// INVALID_REQUEST is returned if the requested topic partitions had
	// contained duplicates.
	//
	// KAFKA_STORAGE_EXCEPTION is returned if the topic / partition is in
	// an offline log directory.
	//
	// UNSUPPORTED_FOR_MESSAGE_FORMAT is returned if the broker is using
	// Kafka 0.10.0 messages and the requested timestamp was not -1 nor -2.
	//
	// NOT_LEADER_FOR_PARTITION is returned if the broker is not a leader
	// for this partition. This means that the client has stale metadata.
	// If the request used the debug replica ID, the returned error will
	// be REPLICA_NOT_AVAILABLE.
	//
	// UNKNOWN_TOPIC_OR_PARTITION is returned if the broker does not know
	// of the requested topic or partition.
	//
	// FENCED_LEADER_EPOCH is returned if the broker has a higher leader
	// epoch than what the request sent.
	//
	// UNKNOWN_LEADER_EPOCH is returned if the request used a leader epoch
	// that the broker does not know about.
	//
	// OFFSET_NOT_AVAILABLE, introduced in Kafka 2.2.0 with produce request
	// v5+, is returned when talking to a broker that is a new leader while
	// that broker's high water mark catches up. This avoids situations where
	// the old broker returned higher offsets than the new broker would. Note
	// that if unclean leader election is allowed, you could still run into
	// the situation where offsets returned from list offsets requests are
	// not monotonically increasing. This error is only returned if the
	// request used the consumer replica ID (-1). If the client did not use
	// a v5+ list offsets request, LEADER_NOT_AVAILABLE is returned.
	// See KIP-207 for more details.
	ErrorCode int16

	// OldStyleOffsets is a list of offsets. This was removed after
	// version 0 and, since it is so historic, is undocumented.
	OldStyleOffsets []int64

	// If the request was for the earliest or latest timestamp (-2 or -1), or
	// if an offset could not be found after the requested one, this will be -1.
	Timestamp int64 // v1+

	// Offset is the offset corresponding to the record on or after the
	// requested timestamp. If one could not be found, this will be -1.
	Offset int64 // v1+

	// LeaderEpoch is the leader epoch of the record at this offset,
	// or -1 if there was no leader epoch.
	LeaderEpoch int32 // v4+
}
type ListOffsetsResponseTopic struct {
	// Topic is the topic this array slot is for.
	Topic string

	// Partitions is an array of partition responses corresponding to
	// the requested partitions for a topic.
	Partitions []ListOffsetsResponseTopicPartition
}

// ListOffsetsResponse is returned from a ListOffsetsRequest.
type ListOffsetsResponse struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	// ThrottleMillis is how long of a throttle Kafka will apply to the client
	// after this request.
	// For Kafka < 2.0.0, the throttle is applied before issuing a response.
	// For Kafka >= 2.0.0, the throttle is applied after issuing a response.
	ThrottleMillis int32 // v2+

	// Topics is an array of topic / partition responses corresponding to
	// the requested topics and partitions.
	Topics []ListOffsetsResponseTopic
}

func (*ListOffsetsResponse) Key() int16                 { return 2 }
func (*ListOffsetsResponse) MaxVersion() int16          { return 5 }
func (v *ListOffsetsResponse) SetVersion(version int16) { v.Version = version }
func (v *ListOffsetsResponse) GetVersion() int16        { return v.Version }
func (v *ListOffsetsResponse) IsFlexible() bool         { return false }
func (v *ListOffsetsResponse) RequestKind() Request     { return &ListOffsetsRequest{Version: v.Version} }

func (v *ListOffsetsResponse) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	if version >= 2 {
		v := v.ThrottleMillis
		dst = kbin.AppendInt32(dst, v)
	}
	{
		v := v.Topics
		dst = kbin.AppendArrayLen(dst, len(v))
		for i := range v {
			v := &v[i]
			{
				v := v.Topic
				dst = kbin.AppendString(dst, v)
			}
			{
				v := v.Partitions
				dst = kbin.AppendArrayLen(dst, len(v))
				for i := range v {
					v := &v[i]
					{
						v := v.Partition
						dst = kbin.AppendInt32(dst, v)
					}
					{
						v := v.ErrorCode
						dst = kbin.AppendInt16(dst, v)
					}
					if version >= 0 && version <= 0 {
						v := v.OldStyleOffsets
						dst = kbin.AppendArrayLen(dst, len(v))
						for i := range v {
							v := v[i]
							dst = kbin.AppendInt64(dst, v)
						}
					}
					if version >= 1 {
						v := v.Timestamp
						dst = kbin.AppendInt64(dst, v)
					}
					if version >= 1 {
						v := v.Offset
						dst = kbin.AppendInt64(dst, v)
					}
					if version >= 4 {
						v := v.LeaderEpoch
						dst = kbin.AppendInt32(dst, v)
					}
				}
			}
		}
	}
	return dst
}
func (v *ListOffsetsResponse) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	b := kbin.Reader{Src: src}
	s := v
	if version >= 2 {
		v := b.Int32()
		s.ThrottleMillis = v
	}
	{
		v := s.Topics
		a := v
		var l int32
		l = b.ArrayLen()
		if !b.Ok() {
			return b.Complete()
		}
		if l > 0 {
			a = make([]ListOffsetsResponseTopic, l)
		}
		for i := int32(0); i < l; i++ {
			v := &a[i]
			s := v
			{
				v := b.String()
				s.Topic = v
			}
			{
				v := s.Partitions
				a := v
				var l int32
				l = b.ArrayLen()
				if !b.Ok() {
					return b.Complete()
				}
				if l > 0 {
					a = make([]ListOffsetsResponseTopicPartition, l)
				}
				for i := int32(0); i < l; i++ {
					v := &a[i]
					s := v
					{
						v := b.Int32()
						s.Partition = v
					}
					{
						v := b.Int16()
						s.ErrorCode = v
					}
					if version >= 0 && version <= 0 {
						v := s.OldStyleOffsets
						a := v
						var l int32
						l = b.ArrayLen()
						if !b.Ok() {
							return b.Complete()
						}
						if l > 0 {
							a = make([]int64, l)
						}
						for i := int32(0); i < l; i++ {
							v := b.Int64()
							a[i] = v
						}
						v = a
						s.OldStyleOffsets = v
					}
					if version >= 1 {
						v := b.Int64()
						s.Timestamp = v
					}
					if version >= 1 {
						v := b.Int64()
						s.Offset = v
					}
					if version >= 4 {
						v := b.Int32()
						s.LeaderEpoch = v
					}
				}
				v = a
				s.Partitions = v
			}
		}
		v = a
		s.Topics = v
	}
	return b.Complete()
}

type MetadataRequestTopic struct {
	// Topic is the topic to request metadata for.
	Topic string
}

// MetadataRequest requests metadata from Kafka.
type MetadataRequest struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	// Topics is a list of topics to return metadata about. If this is null
	// in v1+, all topics are included. If this is empty, no topics are.
	// For v0 (<Kafka 0.10.0.0), if this is empty, all topics are included.
	Topics []MetadataRequestTopic

	// AllowAutoTopicCreation, introduced in Kafka 0.11.0.0, allows topic
	// auto creation of the topics in this request if they do not exist.
	AllowAutoTopicCreation bool // v4+

	// IncludeClusterAuthorizedOperations, introduced in Kakfa 2.3.0, specifies
	// whether to return a bitfield of AclOperations that this client can perform
	// on the cluster. See KIP-430 for more details.
	IncludeClusterAuthorizedOperations bool // v8+

	// IncludeTopicAuthorizedOperations, introduced in Kakfa 2.3.0, specifies
	// whether to return a bitfield of AclOperations that this client can perform
	// on individual topics. See KIP-430 for more details.
	IncludeTopicAuthorizedOperations bool // v8+
}

func (*MetadataRequest) Key() int16                 { return 3 }
func (*MetadataRequest) MaxVersion() int16          { return 9 }
func (v *MetadataRequest) SetVersion(version int16) { v.Version = version }
func (v *MetadataRequest) GetVersion() int16        { return v.Version }
func (v *MetadataRequest) IsFlexible() bool         { return v.Version >= 9 }
func (v *MetadataRequest) ResponseKind() Response   { return &MetadataResponse{Version: v.Version} }

func (v *MetadataRequest) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	isFlexible := version >= 9
	_ = isFlexible
	{
		v := v.Topics
		if version > 1 {
			if isFlexible {
				dst = kbin.AppendCompactNullableArrayLen(dst, len(v), v == nil)
			} else {
				dst = kbin.AppendNullableArrayLen(dst, len(v), v == nil)
			}
		} else {
			if isFlexible {
				dst = kbin.AppendCompactArrayLen(dst, len(v))
			} else {
				dst = kbin.AppendArrayLen(dst, len(v))
			}
		}
		for i := range v {
			v := &v[i]
			{
				v := v.Topic
				if isFlexible {
					dst = kbin.AppendCompactString(dst, v)
				} else {
					dst = kbin.AppendString(dst, v)
				}
			}
			if isFlexible {
				dst = kbin.AppendUvarint(dst, 0)
			}
		}
	}
	if version >= 4 {
		v := v.AllowAutoTopicCreation
		dst = kbin.AppendBool(dst, v)
	}
	if version >= 8 {
		v := v.IncludeClusterAuthorizedOperations
		dst = kbin.AppendBool(dst, v)
	}
	if version >= 8 {
		v := v.IncludeTopicAuthorizedOperations
		dst = kbin.AppendBool(dst, v)
	}
	if isFlexible {
		dst = kbin.AppendUvarint(dst, 0)
	}
	return dst
}
func (v *MetadataRequest) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	isFlexible := version >= 9
	_ = isFlexible
	b := kbin.Reader{Src: src}
	s := v
	{
		v := s.Topics
		a := v
		var l int32
		if isFlexible {
			l = b.CompactArrayLen()
		} else {
			l = b.ArrayLen()
		}
		if version < 1 || l == 0 {
			a = []MetadataRequestTopic{}
		}
		if !b.Ok() {
			return b.Complete()
		}
		if l > 0 {
			a = make([]MetadataRequestTopic, l)
		}
		for i := int32(0); i < l; i++ {
			v := &a[i]
			s := v
			{
				var v string
				if isFlexible {
					v = b.CompactString()
				} else {
					v = b.String()
				}
				s.Topic = v
			}
			if isFlexible {
				SkipTags(&b)
			}
		}
		v = a
		s.Topics = v
	}
	if version >= 4 {
		v := b.Bool()
		s.AllowAutoTopicCreation = v
	}
	if version >= 8 {
		v := b.Bool()
		s.IncludeClusterAuthorizedOperations = v
	}
	if version >= 8 {
		v := b.Bool()
		s.IncludeTopicAuthorizedOperations = v
	}
	if isFlexible {
		SkipTags(&b)
	}
	return b.Complete()
}

type MetadataResponseBroker struct {
	// NodeID is the node ID of a Kafka broker.
	NodeID int32

	// Host is the hostname of a Kafka broker.
	Host string

	// Port is the port of a Kafka broker.
	Port int32

	// Rack is the rack this Kafka broker is in.
	Rack *string // v1+
}
type MetadataResponseTopicPartition struct {
	// ErrorCode is any error for a partition in topic metadata.
	//
	// LEADER_NOT_AVAILABLE is returned if a leader is unavailable for this
	// partition. For v0 metadata responses, this is also returned if a
	// partition leader's listener does not exist.
	//
	// LISTENER_NOT_FOUND is returned if a leader ID is known but the
	// listener for it is not (v1+).
	//
	// REPLICA_NOT_AVAILABLE is returned in v0 responses if any replica is
	// unavailable.
	ErrorCode int16

	// Partition is a partition number for a topic.
	Partition int32

	// Leader is the broker leader for this partition. This will be -1
	// on leader / listener error.
	Leader int32

	// LeaderEpoch, proposed in KIP-320 and introduced in Kafka 2.1.0 is the
	// epoch of the broker leader.
	LeaderEpoch int32 // v7+

	// Replicas returns all broker IDs containing replicas of this partition.
	Replicas []int32

	// ISR returns all broker IDs of in-sync replicas of this partition.
	ISR []int32

	// OfflineReplicas, proposed in KIP-112 and introduced in Kafka 1.0,
	// returns all offline broker IDs that should be replicating this partition.
	OfflineReplicas []int32 // v5+
}
type MetadataResponseTopic struct {
	// ErrorCode is any error for a topic in a metadata request.
	//
	// TOPIC_AUTHORIZATION_FAILED is returned if the client is not authorized
	// to describe the topic, or if the metadata request specified topic auto
	// creation, the topic did not exist, and the user lacks permission to create.
	//
	// UNKNOWN_TOPIC_OR_PARTITION is returned if a topic does not exist and
	// the request did not specify autocreation.
	//
	// LEADER_NOT_AVAILABLE is returned if a new topic is created successfully
	// (since there is no leader on an immediately new topic).
	//
	// There can be a myriad of other errors for unsuccessful topic creation.
	ErrorCode int16

	// Topic is the topic this metadata corresponds to.
	Topic string

	// IsInternal signifies whether this topic is a Kafka internal topic.
	IsInternal bool // v1+

	// Partitions contains metadata about partitions for a topic.
	Partitions []MetadataResponseTopicPartition

	// AuthorizedOperations, proposed in KIP-430 and introduced in Kafka 2.3.0,
	// is a bitfield (corresponding to AclOperation) containing which operations
	// the client is allowed to perform on this topic.
	// This is only returned if requested.
	AuthorizedOperations int32 // v8+
}

// MetadataResponse is returned from a MetdataRequest.
type MetadataResponse struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	// ThrottleMillis is how long of a throttle Kafka will apply to the client
	// after this request.
	// For Kafka < 2.0.0, the throttle is applied before issuing a response.
	// For Kafka >= 2.0.0, the throttle is applied after issuing a response.
	ThrottleMillis int32 // v3+

	// Brokers is a set of alive Kafka brokers.
	Brokers []MetadataResponseBroker

	// ClusterID, proposed in KIP-78 and introduced in Kafka 0.10.1.0, is a
	// unique string specifying the cluster that the replying Kafka belongs to.
	ClusterID *string // v2+

	// ControllerID is the ID of the controller broker (the admin broker).
	ControllerID int32 // v1+

	// Topics contains metadata about each topic requested in the
	// MetadataRequest.
	Topics []MetadataResponseTopic

	// AuthorizedOperations is a bitfield containing which operations the client
	// is allowed to perform on this cluster.
	AuthorizedOperations int32 // v8+
}

func (*MetadataResponse) Key() int16                 { return 3 }
func (*MetadataResponse) MaxVersion() int16          { return 9 }
func (v *MetadataResponse) SetVersion(version int16) { v.Version = version }
func (v *MetadataResponse) GetVersion() int16        { return v.Version }
func (v *MetadataResponse) IsFlexible() bool         { return v.Version >= 9 }
func (v *MetadataResponse) RequestKind() Request     { return &MetadataRequest{Version: v.Version} }

func (v *MetadataResponse) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	isFlexible := version >= 9
	_ = isFlexible
	if version >= 3 {
		v := v.ThrottleMillis
		dst = kbin.AppendInt32(dst, v)
	}
	{
		v := v.Brokers
		if isFlexible {
			dst = kbin.AppendCompactArrayLen(dst, len(v))
		} else {
			dst = kbin.AppendArrayLen(dst, len(v))
		}
		for i := range v {
			v := &v[i]
			{
				v := v.NodeID
				dst = kbin.AppendInt32(dst, v)
			}
			{
				v := v.Host
				if isFlexible {
					dst = kbin.AppendCompactString(dst, v)
				} else {
					dst = kbin.AppendString(dst, v)
				}
			}
			{
				v := v.Port
				dst = kbin.AppendInt32(dst, v)
			}
			if version >= 1 {
				v := v.Rack
				if isFlexible {
					dst = kbin.AppendCompactNullableString(dst, v)
				} else {
					dst = kbin.AppendNullableString(dst, v)
				}
			}
			if isFlexible {
				dst = kbin.AppendUvarint(dst, 0)
			}
		}
	}
	if version >= 2 {
		v := v.ClusterID
		if isFlexible {
			dst = kbin.AppendCompactNullableString(dst, v)
		} else {
			dst = kbin.AppendNullableString(dst, v)
		}
	}
	if version >= 1 {
		v := v.ControllerID
		dst = kbin.AppendInt32(dst, v)
	}
	{
		v := v.Topics
		if isFlexible {
			dst = kbin.AppendCompactArrayLen(dst, len(v))
		} else {
			dst = kbin.AppendArrayLen(dst, len(v))
		}
		for i := range v {
			v := &v[i]
			{
				v := v.ErrorCode
				dst = kbin.AppendInt16(dst, v)
			}
			{
				v := v.Topic
				if isFlexible {
					dst = kbin.AppendCompactString(dst, v)
				} else {
					dst = kbin.AppendString(dst, v)
				}
			}
			if version >= 1 {
				v := v.IsInternal
				dst = kbin.AppendBool(dst, v)
			}
			{
				v := v.Partitions
				if isFlexible {
					dst = kbin.AppendCompactArrayLen(dst, len(v))
				} else {
					dst = kbin.AppendArrayLen(dst, len(v))
				}
				for i := range v {
					v := &v[i]
					{
						v := v.ErrorCode
						dst = kbin.AppendInt16(dst, v)
					}
					{
						v := v.Partition
						dst = kbin.AppendInt32(dst, v)
					}
					{
						v := v.Leader
						dst = kbin.AppendInt32(dst, v)
					}
					if version >= 7 {
						v := v.LeaderEpoch
						dst = kbin.AppendInt32(dst, v)
					}
					{
						v := v.Replicas
						if isFlexible {
							dst = kbin.AppendCompactArrayLen(dst, len(v))
						} else {
							dst = kbin.AppendArrayLen(dst, len(v))
						}
						for i := range v {
							v := v[i]
							dst = kbin.AppendInt32(dst, v)
						}
					}
					{
						v := v.ISR
						if isFlexible {
							dst = kbin.AppendCompactArrayLen(dst, len(v))
						} else {
							dst = kbin.AppendArrayLen(dst, len(v))
						}
						for i := range v {
							v := v[i]
							dst = kbin.AppendInt32(dst, v)
						}
					}
					if version >= 5 {
						v := v.OfflineReplicas
						if isFlexible {
							dst = kbin.AppendCompactArrayLen(dst, len(v))
						} else {
							dst = kbin.AppendArrayLen(dst, len(v))
						}
						for i := range v {
							v := v[i]
							dst = kbin.AppendInt32(dst, v)
						}
					}
					if isFlexible {
						dst = kbin.AppendUvarint(dst, 0)
					}
				}
			}
			if version >= 8 {
				v := v.AuthorizedOperations
				dst = kbin.AppendInt32(dst, v)
			}
			if isFlexible {
				dst = kbin.AppendUvarint(dst, 0)
			}
		}
	}
	if version >= 8 {
		v := v.AuthorizedOperations
		dst = kbin.AppendInt32(dst, v)
	}
	if isFlexible {
		dst = kbin.AppendUvarint(dst, 0)
	}
	return dst
}
func (v *MetadataResponse) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	isFlexible := version >= 9
	_ = isFlexible
	b := kbin.Reader{Src: src}
	s := v
	if version >= 3 {
		v := b.Int32()
		s.ThrottleMillis = v
	}
	{
		v := s.Brokers
		a := v
		var l int32
		if isFlexible {
			l = b.CompactArrayLen()
		} else {
			l = b.ArrayLen()
		}
		if !b.Ok() {
			return b.Complete()
		}
		if l > 0 {
			a = make([]MetadataResponseBroker, l)
		}
		for i := int32(0); i < l; i++ {
			v := &a[i]
			s := v
			{
				v := b.Int32()
				s.NodeID = v
			}
			{
				var v string
				if isFlexible {
					v = b.CompactString()
				} else {
					v = b.String()
				}
				s.Host = v
			}
			{
				v := b.Int32()
				s.Port = v
			}
			if version >= 1 {
				var v *string
				if isFlexible {
					v = b.CompactNullableString()
				} else {
					v = b.NullableString()
				}
				s.Rack = v
			}
			if isFlexible {
				SkipTags(&b)
			}
		}
		v = a
		s.Brokers = v
	}
	if version >= 2 {
		var v *string
		if isFlexible {
			v = b.CompactNullableString()
		} else {
			v = b.NullableString()
		}
		s.ClusterID = v
	}
	if version >= 1 {
		v := b.Int32()
		s.ControllerID = v
	}
	{
		v := s.Topics
		a := v
		var l int32
		if isFlexible {
			l = b.CompactArrayLen()
		} else {
			l = b.ArrayLen()
		}
		if !b.Ok() {
			return b.Complete()
		}
		if l > 0 {
			a = make([]MetadataResponseTopic, l)
		}
		for i := int32(0); i < l; i++ {
			v := &a[i]
			s := v
			{
				v := b.Int16()
				s.ErrorCode = v
			}
			{
				var v string
				if isFlexible {
					v = b.CompactString()
				} else {
					v = b.String()
				}
				s.Topic = v
			}
			if version >= 1 {
				v := b.Bool()
				s.IsInternal = v
			}
			{
				v := s.Partitions
				a := v
				var l int32
				if isFlexible {
					l = b.CompactArrayLen()
				} else {
					l = b.ArrayLen()
				}
				if !b.Ok() {
					return b.Complete()
				}
				if l > 0 {
					a = make([]MetadataResponseTopicPartition, l)
				}
				for i := int32(0); i < l; i++ {
					v := &a[i]
					s := v
					{
						v := b.Int16()
						s.ErrorCode = v
					}
					{
						v := b.Int32()
						s.Partition = v
					}
					{
						v := b.Int32()
						s.Leader = v
					}
					if version >= 7 {
						v := b.Int32()
						s.LeaderEpoch = v
					}
					{
						v := s.Replicas
						a := v
						var l int32
						if isFlexible {
							l = b.CompactArrayLen()
						} else {
							l = b.ArrayLen()
						}
						if !b.Ok() {
							return b.Complete()
						}
						if l > 0 {
							a = make([]int32, l)
						}
						for i := int32(0); i < l; i++ {
							v := b.Int32()
							a[i] = v
						}
						v = a
						s.Replicas = v
					}
					{
						v := s.ISR
						a := v
						var l int32
						if isFlexible {
							l = b.CompactArrayLen()
						} else {
							l = b.ArrayLen()
						}
						if !b.Ok() {
							return b.Complete()
						}
						if l > 0 {
							a = make([]int32, l)
						}
						for i := int32(0); i < l; i++ {
							v := b.Int32()
							a[i] = v
						}
						v = a
						s.ISR = v
					}
					if version >= 5 {
						v := s.OfflineReplicas
						a := v
						var l int32
						if isFlexible {
							l = b.CompactArrayLen()
						} else {
							l = b.ArrayLen()
						}
						if !b.Ok() {
							return b.Complete()
						}
						if l > 0 {
							a = make([]int32, l)
						}
						for i := int32(0); i < l; i++ {
							v := b.Int32()
							a[i] = v
						}
						v = a
						s.OfflineReplicas = v
					}
					if isFlexible {
						SkipTags(&b)
					}
				}
				v = a
				s.Partitions = v
			}
			if version >= 8 {
				v := b.Int32()
				s.AuthorizedOperations = v
			}
			if isFlexible {
				SkipTags(&b)
			}
		}
		v = a
		s.Topics = v
	}
	if version >= 8 {
		v := b.Int32()
		s.AuthorizedOperations = v
	}
	if isFlexible {
		SkipTags(&b)
	}
	return b.Complete()
}

// LeaderAndISRRequestTopicPartition is a common struct that is used across
// different versions of LeaderAndISRRequest.
type LeaderAndISRRequestTopicPartition struct {
	Topic string

	Partition int32

	ControllerEpoch int32

	Leader int32

	LeaderEpoch int32

	ISR []int32

	ZKVersion int32

	Replicas []int32

	AddingReplicas []int32 // v3+

	RemovingReplicas []int32 // v3+

	IsNew bool // v1+
}
type LeaderAndISRRequestTopicState struct {
	Topic string

	PartitionStates []LeaderAndISRRequestTopicPartition
}
type LeaderAndISRRequestLiveLeader struct {
	BrokerID int32

	Host string

	Port int32
}

// LeaderAndISRRequest is an advanced request that controller brokers use
// to broadcast state to other brokers. Manually using this request is a
// great way to break your cluster.
//
// As this is an advanced request and there is little reason to issue it as a
// client, this request is undocumented.
//
// Kafka 1.0.0 introduced version 1. Kafka 2.2.0 introduced version 2, proposed
// in KIP-380, which changed the layout of the struct to be more memory
// efficient. Kafka 2.4.0 introduced version 3 with KIP-455.
type LeaderAndISRRequest struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	ControllerID int32

	ControllerEpoch int32

	BrokerEpoch int64 // v2+

	PartitionStates []LeaderAndISRRequestTopicPartition

	TopicStates []LeaderAndISRRequestTopicState // v2+

	LiveLeaders []LeaderAndISRRequestLiveLeader
}

func (*LeaderAndISRRequest) Key() int16                 { return 4 }
func (*LeaderAndISRRequest) MaxVersion() int16          { return 4 }
func (v *LeaderAndISRRequest) SetVersion(version int16) { v.Version = version }
func (v *LeaderAndISRRequest) GetVersion() int16        { return v.Version }
func (v *LeaderAndISRRequest) IsFlexible() bool         { return v.Version >= 4 }
func (v *LeaderAndISRRequest) ResponseKind() Response {
	return &LeaderAndISRResponse{Version: v.Version}
}

func (v *LeaderAndISRRequest) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	isFlexible := version >= 4
	_ = isFlexible
	{
		v := v.ControllerID
		dst = kbin.AppendInt32(dst, v)
	}
	{
		v := v.ControllerEpoch
		dst = kbin.AppendInt32(dst, v)
	}
	if version >= 2 {
		v := v.BrokerEpoch
		dst = kbin.AppendInt64(dst, v)
	}
	if version >= 0 && version <= 1 {
		v := v.PartitionStates
		if isFlexible {
			dst = kbin.AppendCompactArrayLen(dst, len(v))
		} else {
			dst = kbin.AppendArrayLen(dst, len(v))
		}
		for i := range v {
			v := &v[i]
			if version >= 0 && version <= 1 {
				v := v.Topic
				dst = kbin.AppendString(dst, v)
			}
			{
				v := v.Partition
				dst = kbin.AppendInt32(dst, v)
			}
			{
				v := v.ControllerEpoch
				dst = kbin.AppendInt32(dst, v)
			}
			{
				v := v.Leader
				dst = kbin.AppendInt32(dst, v)
			}
			{
				v := v.LeaderEpoch
				dst = kbin.AppendInt32(dst, v)
			}
			{
				v := v.ISR
				dst = kbin.AppendArrayLen(dst, len(v))
				for i := range v {
					v := v[i]
					dst = kbin.AppendInt32(dst, v)
				}
			}
			{
				v := v.ZKVersion
				dst = kbin.AppendInt32(dst, v)
			}
			{
				v := v.Replicas
				dst = kbin.AppendArrayLen(dst, len(v))
				for i := range v {
					v := v[i]
					dst = kbin.AppendInt32(dst, v)
				}
			}
			if version >= 3 {
				v := v.AddingReplicas
				dst = kbin.AppendArrayLen(dst, len(v))
				for i := range v {
					v := v[i]
					dst = kbin.AppendInt32(dst, v)
				}
			}
			if version >= 3 {
				v := v.RemovingReplicas
				dst = kbin.AppendArrayLen(dst, len(v))
				for i := range v {
					v := v[i]
					dst = kbin.AppendInt32(dst, v)
				}
			}
			if version >= 1 {
				v := v.IsNew
				dst = kbin.AppendBool(dst, v)
			}
			if isFlexible {
				dst = kbin.AppendUvarint(dst, 0)
			}
		}
	}
	if version >= 2 {
		v := v.TopicStates
		if isFlexible {
			dst = kbin.AppendCompactArrayLen(dst, len(v))
		} else {
			dst = kbin.AppendArrayLen(dst, len(v))
		}
		for i := range v {
			v := &v[i]
			{
				v := v.Topic
				if isFlexible {
					dst = kbin.AppendCompactString(dst, v)
				} else {
					dst = kbin.AppendString(dst, v)
				}
			}
			{
				v := v.PartitionStates
				if isFlexible {
					dst = kbin.AppendCompactArrayLen(dst, len(v))
				} else {
					dst = kbin.AppendArrayLen(dst, len(v))
				}
				for i := range v {
					v := &v[i]
					if version >= 0 && version <= 1 {
						v := v.Topic
						dst = kbin.AppendString(dst, v)
					}
					{
						v := v.Partition
						dst = kbin.AppendInt32(dst, v)
					}
					{
						v := v.ControllerEpoch
						dst = kbin.AppendInt32(dst, v)
					}
					{
						v := v.Leader
						dst = kbin.AppendInt32(dst, v)
					}
					{
						v := v.LeaderEpoch
						dst = kbin.AppendInt32(dst, v)
					}
					{
						v := v.ISR
						dst = kbin.AppendArrayLen(dst, len(v))
						for i := range v {
							v := v[i]
							dst = kbin.AppendInt32(dst, v)
						}
					}
					{
						v := v.ZKVersion
						dst = kbin.AppendInt32(dst, v)
					}
					{
						v := v.Replicas
						dst = kbin.AppendArrayLen(dst, len(v))
						for i := range v {
							v := v[i]
							dst = kbin.AppendInt32(dst, v)
						}
					}
					if version >= 3 {
						v := v.AddingReplicas
						dst = kbin.AppendArrayLen(dst, len(v))
						for i := range v {
							v := v[i]
							dst = kbin.AppendInt32(dst, v)
						}
					}
					if version >= 3 {
						v := v.RemovingReplicas
						dst = kbin.AppendArrayLen(dst, len(v))
						for i := range v {
							v := v[i]
							dst = kbin.AppendInt32(dst, v)
						}
					}
					if version >= 1 {
						v := v.IsNew
						dst = kbin.AppendBool(dst, v)
					}
					if isFlexible {
						dst = kbin.AppendUvarint(dst, 0)
					}
				}
			}
			if isFlexible {
				dst = kbin.AppendUvarint(dst, 0)
			}
		}
	}
	{
		v := v.LiveLeaders
		if isFlexible {
			dst = kbin.AppendCompactArrayLen(dst, len(v))
		} else {
			dst = kbin.AppendArrayLen(dst, len(v))
		}
		for i := range v {
			v := &v[i]
			{
				v := v.BrokerID
				dst = kbin.AppendInt32(dst, v)
			}
			{
				v := v.Host
				if isFlexible {
					dst = kbin.AppendCompactString(dst, v)
				} else {
					dst = kbin.AppendString(dst, v)
				}
			}
			{
				v := v.Port
				dst = kbin.AppendInt32(dst, v)
			}
			if isFlexible {
				dst = kbin.AppendUvarint(dst, 0)
			}
		}
	}
	if isFlexible {
		dst = kbin.AppendUvarint(dst, 0)
	}
	return dst
}
func (v *LeaderAndISRRequest) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	isFlexible := version >= 4
	_ = isFlexible
	b := kbin.Reader{Src: src}
	s := v
	{
		v := b.Int32()
		s.ControllerID = v
	}
	{
		v := b.Int32()
		s.ControllerEpoch = v
	}
	if version >= 2 {
		v := b.Int64()
		s.BrokerEpoch = v
	}
	if version >= 0 && version <= 1 {
		v := s.PartitionStates
		a := v
		var l int32
		if isFlexible {
			l = b.CompactArrayLen()
		} else {
			l = b.ArrayLen()
		}
		if !b.Ok() {
			return b.Complete()
		}
		if l > 0 {
			a = make([]LeaderAndISRRequestTopicPartition, l)
		}
		for i := int32(0); i < l; i++ {
			v := &a[i]
			s := v
			if version >= 0 && version <= 1 {
				v := b.String()
				s.Topic = v
			}
			{
				v := b.Int32()
				s.Partition = v
			}
			{
				v := b.Int32()
				s.ControllerEpoch = v
			}
			{
				v := b.Int32()
				s.Leader = v
			}
			{
				v := b.Int32()
				s.LeaderEpoch = v
			}
			{
				v := s.ISR
				a := v
				var l int32
				l = b.ArrayLen()
				if !b.Ok() {
					return b.Complete()
				}
				if l > 0 {
					a = make([]int32, l)
				}
				for i := int32(0); i < l; i++ {
					v := b.Int32()
					a[i] = v
				}
				v = a
				s.ISR = v
			}
			{
				v := b.Int32()
				s.ZKVersion = v
			}
			{
				v := s.Replicas
				a := v
				var l int32
				l = b.ArrayLen()
				if !b.Ok() {
					return b.Complete()
				}
				if l > 0 {
					a = make([]int32, l)
				}
				for i := int32(0); i < l; i++ {
					v := b.Int32()
					a[i] = v
				}
				v = a
				s.Replicas = v
			}
			if version >= 3 {
				v := s.AddingReplicas
				a := v
				var l int32
				l = b.ArrayLen()
				if !b.Ok() {
					return b.Complete()
				}
				if l > 0 {
					a = make([]int32, l)
				}
				for i := int32(0); i < l; i++ {
					v := b.Int32()
					a[i] = v
				}
				v = a
				s.AddingReplicas = v
			}
			if version >= 3 {
				v := s.RemovingReplicas
				a := v
				var l int32
				l = b.ArrayLen()
				if !b.Ok() {
					return b.Complete()
				}
				if l > 0 {
					a = make([]int32, l)
				}
				for i := int32(0); i < l; i++ {
					v := b.Int32()
					a[i] = v
				}
				v = a
				s.RemovingReplicas = v
			}
			if version >= 1 {
				v := b.Bool()
				s.IsNew = v
			}
			if isFlexible {
				SkipTags(&b)
			}
		}
		v = a
		s.PartitionStates = v
	}
	if version >= 2 {
		v := s.TopicStates
		a := v
		var l int32
		if isFlexible {
			l = b.CompactArrayLen()
		} else {
			l = b.ArrayLen()
		}
		if !b.Ok() {
			return b.Complete()
		}
		if l > 0 {
			a = make([]LeaderAndISRRequestTopicState, l)
		}
		for i := int32(0); i < l; i++ {
			v := &a[i]
			s := v
			{
				var v string
				if isFlexible {
					v = b.CompactString()
				} else {
					v = b.String()
				}
				s.Topic = v
			}
			{
				v := s.PartitionStates
				a := v
				var l int32
				if isFlexible {
					l = b.CompactArrayLen()
				} else {
					l = b.ArrayLen()
				}
				if !b.Ok() {
					return b.Complete()
				}
				if l > 0 {
					a = make([]LeaderAndISRRequestTopicPartition, l)
				}
				for i := int32(0); i < l; i++ {
					v := &a[i]
					s := v
					if version >= 0 && version <= 1 {
						v := b.String()
						s.Topic = v
					}
					{
						v := b.Int32()
						s.Partition = v
					}
					{
						v := b.Int32()
						s.ControllerEpoch = v
					}
					{
						v := b.Int32()
						s.Leader = v
					}
					{
						v := b.Int32()
						s.LeaderEpoch = v
					}
					{
						v := s.ISR
						a := v
						var l int32
						l = b.ArrayLen()
						if !b.Ok() {
							return b.Complete()
						}
						if l > 0 {
							a = make([]int32, l)
						}
						for i := int32(0); i < l; i++ {
							v := b.Int32()
							a[i] = v
						}
						v = a
						s.ISR = v
					}
					{
						v := b.Int32()
						s.ZKVersion = v
					}
					{
						v := s.Replicas
						a := v
						var l int32
						l = b.ArrayLen()
						if !b.Ok() {
							return b.Complete()
						}
						if l > 0 {
							a = make([]int32, l)
						}
						for i := int32(0); i < l; i++ {
							v := b.Int32()
							a[i] = v
						}
						v = a
						s.Replicas = v
					}
					if version >= 3 {
						v := s.AddingReplicas
						a := v
						var l int32
						l = b.ArrayLen()
						if !b.Ok() {
							return b.Complete()
						}
						if l > 0 {
							a = make([]int32, l)
						}
						for i := int32(0); i < l; i++ {
							v := b.Int32()
							a[i] = v
						}
						v = a
						s.AddingReplicas = v
					}
					if version >= 3 {
						v := s.RemovingReplicas
						a := v
						var l int32
						l = b.ArrayLen()
						if !b.Ok() {
							return b.Complete()
						}
						if l > 0 {
							a = make([]int32, l)
						}
						for i := int32(0); i < l; i++ {
							v := b.Int32()
							a[i] = v
						}
						v = a
						s.RemovingReplicas = v
					}
					if version >= 1 {
						v := b.Bool()
						s.IsNew = v
					}
					if isFlexible {
						SkipTags(&b)
					}
				}
				v = a
				s.PartitionStates = v
			}
			if isFlexible {
				SkipTags(&b)
			}
		}
		v = a
		s.TopicStates = v
	}
	{
		v := s.LiveLeaders
		a := v
		var l int32
		if isFlexible {
			l = b.CompactArrayLen()
		} else {
			l = b.ArrayLen()
		}
		if !b.Ok() {
			return b.Complete()
		}
		if l > 0 {
			a = make([]LeaderAndISRRequestLiveLeader, l)
		}
		for i := int32(0); i < l; i++ {
			v := &a[i]
			s := v
			{
				v := b.Int32()
				s.BrokerID = v
			}
			{
				var v string
				if isFlexible {
					v = b.CompactString()
				} else {
					v = b.String()
				}
				s.Host = v
			}
			{
				v := b.Int32()
				s.Port = v
			}
			if isFlexible {
				SkipTags(&b)
			}
		}
		v = a
		s.LiveLeaders = v
	}
	if isFlexible {
		SkipTags(&b)
	}
	return b.Complete()
}

type LeaderAndISRResponsePartition struct {
	Topic string

	Partition int32

	ErrorCode int16
}

// LeaderAndISRResponse is returned from a LeaderAndISRRequest.
type LeaderAndISRResponse struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	ErrorCode int16

	Partitions []LeaderAndISRResponsePartition
}

func (*LeaderAndISRResponse) Key() int16                 { return 4 }
func (*LeaderAndISRResponse) MaxVersion() int16          { return 4 }
func (v *LeaderAndISRResponse) SetVersion(version int16) { v.Version = version }
func (v *LeaderAndISRResponse) GetVersion() int16        { return v.Version }
func (v *LeaderAndISRResponse) IsFlexible() bool         { return v.Version >= 4 }
func (v *LeaderAndISRResponse) RequestKind() Request     { return &LeaderAndISRRequest{Version: v.Version} }

func (v *LeaderAndISRResponse) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	isFlexible := version >= 4
	_ = isFlexible
	{
		v := v.ErrorCode
		dst = kbin.AppendInt16(dst, v)
	}
	{
		v := v.Partitions
		if isFlexible {
			dst = kbin.AppendCompactArrayLen(dst, len(v))
		} else {
			dst = kbin.AppendArrayLen(dst, len(v))
		}
		for i := range v {
			v := &v[i]
			{
				v := v.Topic
				if isFlexible {
					dst = kbin.AppendCompactString(dst, v)
				} else {
					dst = kbin.AppendString(dst, v)
				}
			}
			{
				v := v.Partition
				dst = kbin.AppendInt32(dst, v)
			}
			{
				v := v.ErrorCode
				dst = kbin.AppendInt16(dst, v)
			}
			if isFlexible {
				dst = kbin.AppendUvarint(dst, 0)
			}
		}
	}
	if isFlexible {
		dst = kbin.AppendUvarint(dst, 0)
	}
	return dst
}
func (v *LeaderAndISRResponse) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	isFlexible := version >= 4
	_ = isFlexible
	b := kbin.Reader{Src: src}
	s := v
	{
		v := b.Int16()
		s.ErrorCode = v
	}
	{
		v := s.Partitions
		a := v
		var l int32
		if isFlexible {
			l = b.CompactArrayLen()
		} else {
			l = b.ArrayLen()
		}
		if !b.Ok() {
			return b.Complete()
		}
		if l > 0 {
			a = make([]LeaderAndISRResponsePartition, l)
		}
		for i := int32(0); i < l; i++ {
			v := &a[i]
			s := v
			{
				var v string
				if isFlexible {
					v = b.CompactString()
				} else {
					v = b.String()
				}
				s.Topic = v
			}
			{
				v := b.Int32()
				s.Partition = v
			}
			{
				v := b.Int16()
				s.ErrorCode = v
			}
			if isFlexible {
				SkipTags(&b)
			}
		}
		v = a
		s.Partitions = v
	}
	if isFlexible {
		SkipTags(&b)
	}
	return b.Complete()
}

type StopReplicaRequestTopicPartitionState struct {
	Partition int32

	LeaderEpoch int32

	Delete bool
}
type StopReplicaRequestTopic struct {
	Topic string

	Partition int32

	Partitions []int32 // v1+

	PartitionStates []StopReplicaRequestTopicPartitionState // v3+
}

// StopReplicaRequest is an advanced request that brokers use to stop replicas.
//
// As this is an advanced request and there is little reason to issue it as a
// client, this request is undocumented.
//
// Kafka 2.2.0 introduced version 1, proposed in KIP-380, which changed the
// layout of the struct to be more memory efficient.
//
// Kafka 2.6.0 introduced version 3, proposed in KIP-570, reorganizes partitions
// to be stored and adds the leader epoch and delete partition fields per partition.
type StopReplicaRequest struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	ControllerID int32

	ControllerEpoch int32

	BrokerEpoch int64 // v1+

	DeletePartitions bool

	Topics []StopReplicaRequestTopic
}

func (*StopReplicaRequest) Key() int16                 { return 5 }
func (*StopReplicaRequest) MaxVersion() int16          { return 3 }
func (v *StopReplicaRequest) SetVersion(version int16) { v.Version = version }
func (v *StopReplicaRequest) GetVersion() int16        { return v.Version }
func (v *StopReplicaRequest) IsFlexible() bool         { return v.Version >= 2 }
func (v *StopReplicaRequest) ResponseKind() Response   { return &StopReplicaResponse{Version: v.Version} }

func (v *StopReplicaRequest) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	isFlexible := version >= 2
	_ = isFlexible
	{
		v := v.ControllerID
		dst = kbin.AppendInt32(dst, v)
	}
	{
		v := v.ControllerEpoch
		dst = kbin.AppendInt32(dst, v)
	}
	if version >= 1 {
		v := v.BrokerEpoch
		dst = kbin.AppendInt64(dst, v)
	}
	if version >= 0 && version <= 2 {
		v := v.DeletePartitions
		dst = kbin.AppendBool(dst, v)
	}
	{
		v := v.Topics
		if isFlexible {
			dst = kbin.AppendCompactArrayLen(dst, len(v))
		} else {
			dst = kbin.AppendArrayLen(dst, len(v))
		}
		for i := range v {
			v := &v[i]
			{
				v := v.Topic
				if isFlexible {
					dst = kbin.AppendCompactString(dst, v)
				} else {
					dst = kbin.AppendString(dst, v)
				}
			}
			if version >= 0 && version <= 0 {
				v := v.Partition
				dst = kbin.AppendInt32(dst, v)
			}
			if version >= 1 && version <= 2 {
				v := v.Partitions
				if isFlexible {
					dst = kbin.AppendCompactArrayLen(dst, len(v))
				} else {
					dst = kbin.AppendArrayLen(dst, len(v))
				}
				for i := range v {
					v := v[i]
					dst = kbin.AppendInt32(dst, v)
				}
			}
			if version >= 3 {
				v := v.PartitionStates
				if isFlexible {
					dst = kbin.AppendCompactArrayLen(dst, len(v))
				} else {
					dst = kbin.AppendArrayLen(dst, len(v))
				}
				for i := range v {
					v := &v[i]
					{
						v := v.Partition
						dst = kbin.AppendInt32(dst, v)
					}
					{
						v := v.LeaderEpoch
						dst = kbin.AppendInt32(dst, v)
					}
					{
						v := v.Delete
						dst = kbin.AppendBool(dst, v)
					}
					if isFlexible {
						dst = kbin.AppendUvarint(dst, 0)
					}
				}
			}
			if isFlexible {
				dst = kbin.AppendUvarint(dst, 0)
			}
		}
	}
	if isFlexible {
		dst = kbin.AppendUvarint(dst, 0)
	}
	return dst
}
func (v *StopReplicaRequest) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	isFlexible := version >= 2
	_ = isFlexible
	b := kbin.Reader{Src: src}
	s := v
	{
		v := b.Int32()
		s.ControllerID = v
	}
	{
		v := b.Int32()
		s.ControllerEpoch = v
	}
	if version >= 1 {
		v := b.Int64()
		s.BrokerEpoch = v
	}
	if version >= 0 && version <= 2 {
		v := b.Bool()
		s.DeletePartitions = v
	}
	{
		v := s.Topics
		a := v
		var l int32
		if isFlexible {
			l = b.CompactArrayLen()
		} else {
			l = b.ArrayLen()
		}
		if !b.Ok() {
			return b.Complete()
		}
		if l > 0 {
			a = make([]StopReplicaRequestTopic, l)
		}
		for i := int32(0); i < l; i++ {
			v := &a[i]
			s := v
			{
				var v string
				if isFlexible {
					v = b.CompactString()
				} else {
					v = b.String()
				}
				s.Topic = v
			}
			if version >= 0 && version <= 0 {
				v := b.Int32()
				s.Partition = v
			}
			if version >= 1 && version <= 2 {
				v := s.Partitions
				a := v
				var l int32
				if isFlexible {
					l = b.CompactArrayLen()
				} else {
					l = b.ArrayLen()
				}
				if !b.Ok() {
					return b.Complete()
				}
				if l > 0 {
					a = make([]int32, l)
				}
				for i := int32(0); i < l; i++ {
					v := b.Int32()
					a[i] = v
				}
				v = a
				s.Partitions = v
			}
			if version >= 3 {
				v := s.PartitionStates
				a := v
				var l int32
				if isFlexible {
					l = b.CompactArrayLen()
				} else {
					l = b.ArrayLen()
				}
				if !b.Ok() {
					return b.Complete()
				}
				if l > 0 {
					a = make([]StopReplicaRequestTopicPartitionState, l)
				}
				for i := int32(0); i < l; i++ {
					v := &a[i]
					s := v
					{
						v := b.Int32()
						s.Partition = v
					}
					{
						v := b.Int32()
						s.LeaderEpoch = v
					}
					{
						v := b.Bool()
						s.Delete = v
					}
					if isFlexible {
						SkipTags(&b)
					}
				}
				v = a
				s.PartitionStates = v
			}
			if isFlexible {
				SkipTags(&b)
			}
		}
		v = a
		s.Topics = v
	}
	if isFlexible {
		SkipTags(&b)
	}
	return b.Complete()
}

type StopReplicaResponsePartition struct {
	Topic string

	Partition int32

	ErrorCode int16
}

// StopReplicasResponse is returned from a StopReplicasRequest.
type StopReplicaResponse struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	// Version 3 returns FENCED_LEADER_EPOCH if the leader is stale (KIP-570).
	ErrorCode int16

	Partitions []StopReplicaResponsePartition
}

func (*StopReplicaResponse) Key() int16                 { return 5 }
func (*StopReplicaResponse) MaxVersion() int16          { return 3 }
func (v *StopReplicaResponse) SetVersion(version int16) { v.Version = version }
func (v *StopReplicaResponse) GetVersion() int16        { return v.Version }
func (v *StopReplicaResponse) IsFlexible() bool         { return v.Version >= 2 }
func (v *StopReplicaResponse) RequestKind() Request     { return &StopReplicaRequest{Version: v.Version} }

func (v *StopReplicaResponse) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	isFlexible := version >= 2
	_ = isFlexible
	{
		v := v.ErrorCode
		dst = kbin.AppendInt16(dst, v)
	}
	{
		v := v.Partitions
		if isFlexible {
			dst = kbin.AppendCompactArrayLen(dst, len(v))
		} else {
			dst = kbin.AppendArrayLen(dst, len(v))
		}
		for i := range v {
			v := &v[i]
			{
				v := v.Topic
				if isFlexible {
					dst = kbin.AppendCompactString(dst, v)
				} else {
					dst = kbin.AppendString(dst, v)
				}
			}
			{
				v := v.Partition
				dst = kbin.AppendInt32(dst, v)
			}
			{
				v := v.ErrorCode
				dst = kbin.AppendInt16(dst, v)
			}
			if isFlexible {
				dst = kbin.AppendUvarint(dst, 0)
			}
		}
	}
	if isFlexible {
		dst = kbin.AppendUvarint(dst, 0)
	}
	return dst
}
func (v *StopReplicaResponse) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	isFlexible := version >= 2
	_ = isFlexible
	b := kbin.Reader{Src: src}
	s := v
	{
		v := b.Int16()
		s.ErrorCode = v
	}
	{
		v := s.Partitions
		a := v
		var l int32
		if isFlexible {
			l = b.CompactArrayLen()
		} else {
			l = b.ArrayLen()
		}
		if !b.Ok() {
			return b.Complete()
		}
		if l > 0 {
			a = make([]StopReplicaResponsePartition, l)
		}
		for i := int32(0); i < l; i++ {
			v := &a[i]
			s := v
			{
				var v string
				if isFlexible {
					v = b.CompactString()
				} else {
					v = b.String()
				}
				s.Topic = v
			}
			{
				v := b.Int32()
				s.Partition = v
			}
			{
				v := b.Int16()
				s.ErrorCode = v
			}
			if isFlexible {
				SkipTags(&b)
			}
		}
		v = a
		s.Partitions = v
	}
	if isFlexible {
		SkipTags(&b)
	}
	return b.Complete()
}

type UpdateMetadataRequestTopicPartition struct {
	Topic string

	Partition int32

	ControllerEpoch int32

	Leader int32

	LeaderEpoch int32

	ISR []int32

	ZKVersion int32

	Replicas []int32

	OfflineReplicas []int32
}
type UpdateMetadataRequestTopicState struct {
	Topic string

	PartitionStates []UpdateMetadataRequestTopicPartition
}
type UpdateMetadataRequestLiveBrokerEndpoint struct {
	Port int32

	Host string

	ListenerName string // v3+

	SecurityProtocol int16
}
type UpdateMetadataRequestLiveBroker struct {
	ID int32

	Host string

	Port int32

	Endpoints []UpdateMetadataRequestLiveBrokerEndpoint // v1+

	Rack *string // v2+
}

// UpdateMetadataRequest is an advanced request that brokers use to
// issue metadata updates to each other.
//
// As this is an advanced request and there is little reason to issue it as a
// client, this request is undocumented.
//
// Version 1 changed the layout of the live brokers.
//
// Kafka 2.2.0 introduced version 5, proposed in KIP-380, which changed the
// layout of the struct to be more memory efficient.
type UpdateMetadataRequest struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	ControllerID int32

	ControllerEpoch int32

	BrokerEpoch int64 // v5+

	PartitionStates []UpdateMetadataRequestTopicPartition

	TopicStates []UpdateMetadataRequestTopicState // v5+

	LiveBrokers []UpdateMetadataRequestLiveBroker
}

func (*UpdateMetadataRequest) Key() int16                 { return 6 }
func (*UpdateMetadataRequest) MaxVersion() int16          { return 6 }
func (v *UpdateMetadataRequest) SetVersion(version int16) { v.Version = version }
func (v *UpdateMetadataRequest) GetVersion() int16        { return v.Version }
func (v *UpdateMetadataRequest) IsFlexible() bool         { return v.Version >= 6 }
func (v *UpdateMetadataRequest) ResponseKind() Response {
	return &UpdateMetadataResponse{Version: v.Version}
}

func (v *UpdateMetadataRequest) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	isFlexible := version >= 6
	_ = isFlexible
	{
		v := v.ControllerID
		dst = kbin.AppendInt32(dst, v)
	}
	{
		v := v.ControllerEpoch
		dst = kbin.AppendInt32(dst, v)
	}
	if version >= 5 {
		v := v.BrokerEpoch
		dst = kbin.AppendInt64(dst, v)
	}
	if version >= 0 && version <= 4 {
		v := v.PartitionStates
		if isFlexible {
			dst = kbin.AppendCompactArrayLen(dst, len(v))
		} else {
			dst = kbin.AppendArrayLen(dst, len(v))
		}
		for i := range v {
			v := &v[i]
			if version >= 0 && version <= 4 {
				v := v.Topic
				dst = kbin.AppendString(dst, v)
			}
			{
				v := v.Partition
				dst = kbin.AppendInt32(dst, v)
			}
			{
				v := v.ControllerEpoch
				dst = kbin.AppendInt32(dst, v)
			}
			{
				v := v.Leader
				dst = kbin.AppendInt32(dst, v)
			}
			{
				v := v.LeaderEpoch
				dst = kbin.AppendInt32(dst, v)
			}
			{
				v := v.ISR
				dst = kbin.AppendArrayLen(dst, len(v))
				for i := range v {
					v := v[i]
					dst = kbin.AppendInt32(dst, v)
				}
			}
			{
				v := v.ZKVersion
				dst = kbin.AppendInt32(dst, v)
			}
			{
				v := v.Replicas
				dst = kbin.AppendArrayLen(dst, len(v))
				for i := range v {
					v := v[i]
					dst = kbin.AppendInt32(dst, v)
				}
			}
			{
				v := v.OfflineReplicas
				dst = kbin.AppendArrayLen(dst, len(v))
				for i := range v {
					v := v[i]
					dst = kbin.AppendInt32(dst, v)
				}
			}
			if isFlexible {
				dst = kbin.AppendUvarint(dst, 0)
			}
		}
	}
	if version >= 5 {
		v := v.TopicStates
		if isFlexible {
			dst = kbin.AppendCompactArrayLen(dst, len(v))
		} else {
			dst = kbin.AppendArrayLen(dst, len(v))
		}
		for i := range v {
			v := &v[i]
			{
				v := v.Topic
				if isFlexible {
					dst = kbin.AppendCompactString(dst, v)
				} else {
					dst = kbin.AppendString(dst, v)
				}
			}
			{
				v := v.PartitionStates
				if isFlexible {
					dst = kbin.AppendCompactArrayLen(dst, len(v))
				} else {
					dst = kbin.AppendArrayLen(dst, len(v))
				}
				for i := range v {
					v := &v[i]
					if version >= 0 && version <= 4 {
						v := v.Topic
						dst = kbin.AppendString(dst, v)
					}
					{
						v := v.Partition
						dst = kbin.AppendInt32(dst, v)
					}
					{
						v := v.ControllerEpoch
						dst = kbin.AppendInt32(dst, v)
					}
					{
						v := v.Leader
						dst = kbin.AppendInt32(dst, v)
					}
					{
						v := v.LeaderEpoch
						dst = kbin.AppendInt32(dst, v)
					}
					{
						v := v.ISR
						dst = kbin.AppendArrayLen(dst, len(v))
						for i := range v {
							v := v[i]
							dst = kbin.AppendInt32(dst, v)
						}
					}
					{
						v := v.ZKVersion
						dst = kbin.AppendInt32(dst, v)
					}
					{
						v := v.Replicas
						dst = kbin.AppendArrayLen(dst, len(v))
						for i := range v {
							v := v[i]
							dst = kbin.AppendInt32(dst, v)
						}
					}
					{
						v := v.OfflineReplicas
						dst = kbin.AppendArrayLen(dst, len(v))
						for i := range v {
							v := v[i]
							dst = kbin.AppendInt32(dst, v)
						}
					}
					if isFlexible {
						dst = kbin.AppendUvarint(dst, 0)
					}
				}
			}
			if isFlexible {
				dst = kbin.AppendUvarint(dst, 0)
			}
		}
	}
	{
		v := v.LiveBrokers
		if isFlexible {
			dst = kbin.AppendCompactArrayLen(dst, len(v))
		} else {
			dst = kbin.AppendArrayLen(dst, len(v))
		}
		for i := range v {
			v := &v[i]
			{
				v := v.ID
				dst = kbin.AppendInt32(dst, v)
			}
			if version >= 0 && version <= 0 {
				v := v.Host
				if isFlexible {
					dst = kbin.AppendCompactString(dst, v)
				} else {
					dst = kbin.AppendString(dst, v)
				}
			}
			if version >= 0 && version <= 0 {
				v := v.Port
				dst = kbin.AppendInt32(dst, v)
			}
			if version >= 1 {
				v := v.Endpoints
				if isFlexible {
					dst = kbin.AppendCompactArrayLen(dst, len(v))
				} else {
					dst = kbin.AppendArrayLen(dst, len(v))
				}
				for i := range v {
					v := &v[i]
					{
						v := v.Port
						dst = kbin.AppendInt32(dst, v)
					}
					{
						v := v.Host
						if isFlexible {
							dst = kbin.AppendCompactString(dst, v)
						} else {
							dst = kbin.AppendString(dst, v)
						}
					}
					if version >= 3 {
						v := v.ListenerName
						if isFlexible {
							dst = kbin.AppendCompactString(dst, v)
						} else {
							dst = kbin.AppendString(dst, v)
						}
					}
					{
						v := v.SecurityProtocol
						dst = kbin.AppendInt16(dst, v)
					}
					if isFlexible {
						dst = kbin.AppendUvarint(dst, 0)
					}
				}
			}
			if version >= 2 {
				v := v.Rack
				if isFlexible {
					dst = kbin.AppendCompactNullableString(dst, v)
				} else {
					dst = kbin.AppendNullableString(dst, v)
				}
			}
			if isFlexible {
				dst = kbin.AppendUvarint(dst, 0)
			}
		}
	}
	if isFlexible {
		dst = kbin.AppendUvarint(dst, 0)
	}
	return dst
}
func (v *UpdateMetadataRequest) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	isFlexible := version >= 6
	_ = isFlexible
	b := kbin.Reader{Src: src}
	s := v
	{
		v := b.Int32()
		s.ControllerID = v
	}
	{
		v := b.Int32()
		s.ControllerEpoch = v
	}
	if version >= 5 {
		v := b.Int64()
		s.BrokerEpoch = v
	}
	if version >= 0 && version <= 4 {
		v := s.PartitionStates
		a := v
		var l int32
		if isFlexible {
			l = b.CompactArrayLen()
		} else {
			l = b.ArrayLen()
		}
		if !b.Ok() {
			return b.Complete()
		}
		if l > 0 {
			a = make([]UpdateMetadataRequestTopicPartition, l)
		}
		for i := int32(0); i < l; i++ {
			v := &a[i]
			s := v
			if version >= 0 && version <= 4 {
				v := b.String()
				s.Topic = v
			}
			{
				v := b.Int32()
				s.Partition = v
			}
			{
				v := b.Int32()
				s.ControllerEpoch = v
			}
			{
				v := b.Int32()
				s.Leader = v
			}
			{
				v := b.Int32()
				s.LeaderEpoch = v
			}
			{
				v := s.ISR
				a := v
				var l int32
				l = b.ArrayLen()
				if !b.Ok() {
					return b.Complete()
				}
				if l > 0 {
					a = make([]int32, l)
				}
				for i := int32(0); i < l; i++ {
					v := b.Int32()
					a[i] = v
				}
				v = a
				s.ISR = v
			}
			{
				v := b.Int32()
				s.ZKVersion = v
			}
			{
				v := s.Replicas
				a := v
				var l int32
				l = b.ArrayLen()
				if !b.Ok() {
					return b.Complete()
				}
				if l > 0 {
					a = make([]int32, l)
				}
				for i := int32(0); i < l; i++ {
					v := b.Int32()
					a[i] = v
				}
				v = a
				s.Replicas = v
			}
			{
				v := s.OfflineReplicas
				a := v
				var l int32
				l = b.ArrayLen()
				if !b.Ok() {
					return b.Complete()
				}
				if l > 0 {
					a = make([]int32, l)
				}
				for i := int32(0); i < l; i++ {
					v := b.Int32()
					a[i] = v
				}
				v = a
				s.OfflineReplicas = v
			}
			if isFlexible {
				SkipTags(&b)
			}
		}
		v = a
		s.PartitionStates = v
	}
	if version >= 5 {
		v := s.TopicStates
		a := v
		var l int32
		if isFlexible {
			l = b.CompactArrayLen()
		} else {
			l = b.ArrayLen()
		}
		if !b.Ok() {
			return b.Complete()
		}
		if l > 0 {
			a = make([]UpdateMetadataRequestTopicState, l)
		}
		for i := int32(0); i < l; i++ {
			v := &a[i]
			s := v
			{
				var v string
				if isFlexible {
					v = b.CompactString()
				} else {
					v = b.String()
				}
				s.Topic = v
			}
			{
				v := s.PartitionStates
				a := v
				var l int32
				if isFlexible {
					l = b.CompactArrayLen()
				} else {
					l = b.ArrayLen()
				}
				if !b.Ok() {
					return b.Complete()
				}
				if l > 0 {
					a = make([]UpdateMetadataRequestTopicPartition, l)
				}
				for i := int32(0); i < l; i++ {
					v := &a[i]
					s := v
					if version >= 0 && version <= 4 {
						v := b.String()
						s.Topic = v
					}
					{
						v := b.Int32()
						s.Partition = v
					}
					{
						v := b.Int32()
						s.ControllerEpoch = v
					}
					{
						v := b.Int32()
						s.Leader = v
					}
					{
						v := b.Int32()
						s.LeaderEpoch = v
					}
					{
						v := s.ISR
						a := v
						var l int32
						l = b.ArrayLen()
						if !b.Ok() {
							return b.Complete()
						}
						if l > 0 {
							a = make([]int32, l)
						}
						for i := int32(0); i < l; i++ {
							v := b.Int32()
							a[i] = v
						}
						v = a
						s.ISR = v
					}
					{
						v := b.Int32()
						s.ZKVersion = v
					}
					{
						v := s.Replicas
						a := v
						var l int32
						l = b.ArrayLen()
						if !b.Ok() {
							return b.Complete()
						}
						if l > 0 {
							a = make([]int32, l)
						}
						for i := int32(0); i < l; i++ {
							v := b.Int32()
							a[i] = v
						}
						v = a
						s.Replicas = v
					}
					{
						v := s.OfflineReplicas
						a := v
						var l int32
						l = b.ArrayLen()
						if !b.Ok() {
							return b.Complete()
						}
						if l > 0 {
							a = make([]int32, l)
						}
						for i := int32(0); i < l; i++ {
							v := b.Int32()
							a[i] = v
						}
						v = a
						s.OfflineReplicas = v
					}
					if isFlexible {
						SkipTags(&b)
					}
				}
				v = a
				s.PartitionStates = v
			}
			if isFlexible {
				SkipTags(&b)
			}
		}
		v = a
		s.TopicStates = v
	}
	{
		v := s.LiveBrokers
		a := v
		var l int32
		if isFlexible {
			l = b.CompactArrayLen()
		} else {
			l = b.ArrayLen()
		}
		if !b.Ok() {
			return b.Complete()
		}
		if l > 0 {
			a = make([]UpdateMetadataRequestLiveBroker, l)
		}
		for i := int32(0); i < l; i++ {
			v := &a[i]
			s := v
			{
				v := b.Int32()
				s.ID = v
			}
			if version >= 0 && version <= 0 {
				var v string
				if isFlexible {
					v = b.CompactString()
				} else {
					v = b.String()
				}
				s.Host = v
			}
			if version >= 0 && version <= 0 {
				v := b.Int32()
				s.Port = v
			}
			if version >= 1 {
				v := s.Endpoints
				a := v
				var l int32
				if isFlexible {
					l = b.CompactArrayLen()
				} else {
					l = b.ArrayLen()
				}
				if !b.Ok() {
					return b.Complete()
				}
				if l > 0 {
					a = make([]UpdateMetadataRequestLiveBrokerEndpoint, l)
				}
				for i := int32(0); i < l; i++ {
					v := &a[i]
					s := v
					{
						v := b.Int32()
						s.Port = v
					}
					{
						var v string
						if isFlexible {
							v = b.CompactString()
						} else {
							v = b.String()
						}
						s.Host = v
					}
					if version >= 3 {
						var v string
						if isFlexible {
							v = b.CompactString()
						} else {
							v = b.String()
						}
						s.ListenerName = v
					}
					{
						v := b.Int16()
						s.SecurityProtocol = v
					}
					if isFlexible {
						SkipTags(&b)
					}
				}
				v = a
				s.Endpoints = v
			}
			if version >= 2 {
				var v *string
				if isFlexible {
					v = b.CompactNullableString()
				} else {
					v = b.NullableString()
				}
				s.Rack = v
			}
			if isFlexible {
				SkipTags(&b)
			}
		}
		v = a
		s.LiveBrokers = v
	}
	if isFlexible {
		SkipTags(&b)
	}
	return b.Complete()
}

// UpdateMetadataResponses is returned from an UpdateMetadataRequest.
type UpdateMetadataResponse struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	ErrorCode int16
}

func (*UpdateMetadataResponse) Key() int16                 { return 6 }
func (*UpdateMetadataResponse) MaxVersion() int16          { return 6 }
func (v *UpdateMetadataResponse) SetVersion(version int16) { v.Version = version }
func (v *UpdateMetadataResponse) GetVersion() int16        { return v.Version }
func (v *UpdateMetadataResponse) IsFlexible() bool         { return v.Version >= 6 }
func (v *UpdateMetadataResponse) RequestKind() Request {
	return &UpdateMetadataRequest{Version: v.Version}
}

func (v *UpdateMetadataResponse) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	isFlexible := version >= 6
	_ = isFlexible
	{
		v := v.ErrorCode
		dst = kbin.AppendInt16(dst, v)
	}
	if isFlexible {
		dst = kbin.AppendUvarint(dst, 0)
	}
	return dst
}
func (v *UpdateMetadataResponse) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	isFlexible := version >= 6
	_ = isFlexible
	b := kbin.Reader{Src: src}
	s := v
	{
		v := b.Int16()
		s.ErrorCode = v
	}
	if isFlexible {
		SkipTags(&b)
	}
	return b.Complete()
}

// ControlledShutdownRequest is an advanced request that can be used to
// sthudown a broker in a controlled manner.
//
// As this is an advanced request and there is little reason to issue it as a
// client, this request is undocumented. However, the minimal amount of fields
// here makes the usage rather obvious.
//
// Kafka 2.2.0 introduced version 2, proposed in KIP-380.
//
// Note that version 0 of this request uses a special encoding format
// where the request does not include the client ID.
type ControlledShutdownRequest struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	BrokerID int32

	BrokerEpoch int64 // v2+
}

func (*ControlledShutdownRequest) Key() int16                 { return 7 }
func (*ControlledShutdownRequest) MaxVersion() int16          { return 3 }
func (v *ControlledShutdownRequest) SetVersion(version int16) { v.Version = version }
func (v *ControlledShutdownRequest) GetVersion() int16        { return v.Version }
func (v *ControlledShutdownRequest) IsFlexible() bool         { return v.Version >= 3 }
func (v *ControlledShutdownRequest) ResponseKind() Response {
	return &ControlledShutdownResponse{Version: v.Version}
}

func (v *ControlledShutdownRequest) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	isFlexible := version >= 3
	_ = isFlexible
	{
		v := v.BrokerID
		dst = kbin.AppendInt32(dst, v)
	}
	if version >= 2 {
		v := v.BrokerEpoch
		dst = kbin.AppendInt64(dst, v)
	}
	if isFlexible {
		dst = kbin.AppendUvarint(dst, 0)
	}
	return dst
}
func (v *ControlledShutdownRequest) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	isFlexible := version >= 3
	_ = isFlexible
	b := kbin.Reader{Src: src}
	s := v
	{
		v := b.Int32()
		s.BrokerID = v
	}
	if version >= 2 {
		v := b.Int64()
		s.BrokerEpoch = v
	}
	if isFlexible {
		SkipTags(&b)
	}
	return b.Complete()
}

type ControlledShutdownResponsePartitionsRemaining struct {
	Topic string

	Partition int32
}

// ControlledShutdownResponse is returned from a ControlledShutdownRequest.
type ControlledShutdownResponse struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	ErrorCode int16

	PartitionsRemaining []ControlledShutdownResponsePartitionsRemaining
}

func (*ControlledShutdownResponse) Key() int16                 { return 7 }
func (*ControlledShutdownResponse) MaxVersion() int16          { return 3 }
func (v *ControlledShutdownResponse) SetVersion(version int16) { v.Version = version }
func (v *ControlledShutdownResponse) GetVersion() int16        { return v.Version }
func (v *ControlledShutdownResponse) IsFlexible() bool         { return v.Version >= 3 }
func (v *ControlledShutdownResponse) RequestKind() Request {
	return &ControlledShutdownRequest{Version: v.Version}
}

func (v *ControlledShutdownResponse) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	isFlexible := version >= 3
	_ = isFlexible
	{
		v := v.ErrorCode
		dst = kbin.AppendInt16(dst, v)
	}
	{
		v := v.PartitionsRemaining
		if isFlexible {
			dst = kbin.AppendCompactArrayLen(dst, len(v))
		} else {
			dst = kbin.AppendArrayLen(dst, len(v))
		}
		for i := range v {
			v := &v[i]
			{
				v := v.Topic
				if isFlexible {
					dst = kbin.AppendCompactString(dst, v)
				} else {
					dst = kbin.AppendString(dst, v)
				}
			}
			{
				v := v.Partition
				dst = kbin.AppendInt32(dst, v)
			}
			if isFlexible {
				dst = kbin.AppendUvarint(dst, 0)
			}
		}
	}
	if isFlexible {
		dst = kbin.AppendUvarint(dst, 0)
	}
	return dst
}
func (v *ControlledShutdownResponse) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	isFlexible := version >= 3
	_ = isFlexible
	b := kbin.Reader{Src: src}
	s := v
	{
		v := b.Int16()
		s.ErrorCode = v
	}
	{
		v := s.PartitionsRemaining
		a := v
		var l int32
		if isFlexible {
			l = b.CompactArrayLen()
		} else {
			l = b.ArrayLen()
		}
		if !b.Ok() {
			return b.Complete()
		}
		if l > 0 {
			a = make([]ControlledShutdownResponsePartitionsRemaining, l)
		}
		for i := int32(0); i < l; i++ {
			v := &a[i]
			s := v
			{
				var v string
				if isFlexible {
					v = b.CompactString()
				} else {
					v = b.String()
				}
				s.Topic = v
			}
			{
				v := b.Int32()
				s.Partition = v
			}
			if isFlexible {
				SkipTags(&b)
			}
		}
		v = a
		s.PartitionsRemaining = v
	}
	if isFlexible {
		SkipTags(&b)
	}
	return b.Complete()
}

// OffsetCommitKey is the key for the Kafka internal __consumer_offsets topic
// if the key starts with an int16 with a value of 0 or 1.
//
// This type was introduced in KAFKA-1012 commit a670537aa3 with release 0.8.2
// and has been in use ever since.
type OffsetCommitKey struct {
	// Version is which encoding version this value is using.
	Version int16

	// Group is the group being committed.
	Group string

	// Topic is the topic being committed.
	Topic string

	// Partition is the partition being committed.
	Partition int32
}

func (v *OffsetCommitKey) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	{
		v := v.Version
		dst = kbin.AppendInt16(dst, v)
	}
	{
		v := v.Group
		dst = kbin.AppendString(dst, v)
	}
	{
		v := v.Topic
		dst = kbin.AppendString(dst, v)
	}
	{
		v := v.Partition
		dst = kbin.AppendInt32(dst, v)
	}
	return dst
}
func (v *OffsetCommitKey) ReadFrom(src []byte) error {
	b := kbin.Reader{Src: src}
	version := b.Int16()
	v.Version = version
	s := v
	{
		v := b.String()
		s.Group = v
	}
	{
		v := b.String()
		s.Topic = v
	}
	{
		v := b.Int32()
		s.Partition = v
	}
	return b.Complete()
}

// OffsetCommitValue is the value for the Kafka internal __consumer_offsets
// topic if the key is of OffsetCommitKey type.
//
// Version 0 was introduced with the key version 0.
//
// KAFKA-1634 commit c5df2a8e3a in 0.9.0 released version 1.
//
// KAFKA-4682 commit 418a91b5d4, proposed in KIP-211 and included in 2.1.0
// released version 2.
//
// KAFKA-7437 commit 9f7267dd2f, proposed in KIP-320 and included in 2.1.0
// released version 3.
type OffsetCommitValue struct {
	// Version is which encoding version this value is using.
	Version int16

	// Offset is the committed offset.
	Offset int64

	// LeaderEpoch is the epoch of the leader committing this message.
	LeaderEpoch int32 // v3+

	// Metadata is the metadata included in the commit.
	Metadata string

	// CommitTimestamp is when this commit occurred.
	CommitTimestamp int64

	// ExpireTimestamp, introduced in v1 and dropped in v2 with KIP-111,
	// is when this commit expires.
	ExpireTimestamp int64 // v1+
}

func (v *OffsetCommitValue) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	{
		v := v.Version
		dst = kbin.AppendInt16(dst, v)
	}
	{
		v := v.Offset
		dst = kbin.AppendInt64(dst, v)
	}
	if version >= 3 {
		v := v.LeaderEpoch
		dst = kbin.AppendInt32(dst, v)
	}
	{
		v := v.Metadata
		dst = kbin.AppendString(dst, v)
	}
	{
		v := v.CommitTimestamp
		dst = kbin.AppendInt64(dst, v)
	}
	if version >= 1 && version <= 1 {
		v := v.ExpireTimestamp
		dst = kbin.AppendInt64(dst, v)
	}
	return dst
}
func (v *OffsetCommitValue) ReadFrom(src []byte) error {
	b := kbin.Reader{Src: src}
	version := b.Int16()
	v.Version = version
	s := v
	{
		v := b.Int64()
		s.Offset = v
	}
	if version >= 3 {
		v := b.Int32()
		s.LeaderEpoch = v
	}
	{
		v := b.String()
		s.Metadata = v
	}
	{
		v := b.Int64()
		s.CommitTimestamp = v
	}
	if version >= 1 && version <= 1 {
		v := b.Int64()
		s.ExpireTimestamp = v
	}
	return b.Complete()
}

// GroupMetadataKey is the key for the Kafka internal __consumer_offsets topic
// if the key starts with an int16 with a value of 2.
//
// This type was introduced in KAFKA-2017 commit 7c33475274 with release 0.9.0
// and has been in use ever since.
type GroupMetadataKey struct {
	// Version is which encoding version this value is using.
	Version int16

	// Group is the group this metadata is for.
	Group string
}

func (v *GroupMetadataKey) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	{
		v := v.Version
		dst = kbin.AppendInt16(dst, v)
	}
	{
		v := v.Group
		dst = kbin.AppendString(dst, v)
	}
	return dst
}
func (v *GroupMetadataKey) ReadFrom(src []byte) error {
	b := kbin.Reader{Src: src}
	version := b.Int16()
	v.Version = version
	s := v
	{
		v := b.String()
		s.Group = v
	}
	return b.Complete()
}

type GroupMetadataValueMember struct {
	// MemberID is a group member.
	MemberID string

	// InstanceID is the instance ID of this member in the group (KIP-345).
	InstanceID *string // v3+

	// ClientID is the client ID of this group member.
	ClientID string

	// ClientHost is the hostname of this group member.
	ClientHost string

	// RebalanceTimeoutMillis is the rebalance timeout of this group member.
	RebalanceTimeoutMillis int32 // v1+

	// SessionTimeoutMillis is the session timeout of this group member.
	SessionTimeoutMillis int32

	// Subscription is the subscription of this group member.
	Subscription []byte

	// Assignment is what the leader assigned this group member.
	Assignment []byte
}

// GroupMetadataValue is the value for the Kafka internal __consumer_offsets
// topic if the key is of GroupMetadataKey type.
//
// Version 0 was introduced with the key version 0.
//
// KAFKA-3888 commit 40b1dd3f49, proposed in KIP-62 and included in 0.10.1
// released version 1.
//
// KAFKA-4682 commit 418a91b5d4, proposed in KIP-211 and included in 2.1.0
// released version 2.
//
// KAFKA-7862 commit 0f995ba6be, proposed in KIP-345 and included in 2.3.0
// released version 3.
type GroupMetadataValue struct {
	// Version is the version of this value.
	Version int16

	// ProtocolType is the type of protocol being used for the group
	// (i.e., "consumer").
	ProtocolType string

	// Generation is the generation of this group.
	Generation int32

	// Protocol is the agreed upon protocol all members are using to partition
	// (i.e., "sticky").
	Protocol *string

	// Leader is the group leader.
	Leader *string

	// CurrentStateTimestamp is the timestamp for this state of the group
	// (stable, etc.).
	CurrentStateTimestamp int64 // v2+

	// Members are the group members.
	Members []GroupMetadataValueMember
}

func (v *GroupMetadataValue) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	{
		v := v.Version
		dst = kbin.AppendInt16(dst, v)
	}
	{
		v := v.ProtocolType
		dst = kbin.AppendString(dst, v)
	}
	{
		v := v.Generation
		dst = kbin.AppendInt32(dst, v)
	}
	{
		v := v.Protocol
		dst = kbin.AppendNullableString(dst, v)
	}
	{
		v := v.Leader
		dst = kbin.AppendNullableString(dst, v)
	}
	if version >= 2 {
		v := v.CurrentStateTimestamp
		dst = kbin.AppendInt64(dst, v)
	}
	{
		v := v.Members
		dst = kbin.AppendArrayLen(dst, len(v))
		for i := range v {
			v := &v[i]
			{
				v := v.MemberID
				dst = kbin.AppendString(dst, v)
			}
			if version >= 3 {
				v := v.InstanceID
				dst = kbin.AppendNullableString(dst, v)
			}
			{
				v := v.ClientID
				dst = kbin.AppendString(dst, v)
			}
			{
				v := v.ClientHost
				dst = kbin.AppendString(dst, v)
			}
			if version >= 1 {
				v := v.RebalanceTimeoutMillis
				dst = kbin.AppendInt32(dst, v)
			}
			{
				v := v.SessionTimeoutMillis
				dst = kbin.AppendInt32(dst, v)
			}
			{
				v := v.Subscription
				dst = kbin.AppendBytes(dst, v)
			}
			{
				v := v.Assignment
				dst = kbin.AppendBytes(dst, v)
			}
		}
	}
	return dst
}
func (v *GroupMetadataValue) ReadFrom(src []byte) error {
	b := kbin.Reader{Src: src}
	version := b.Int16()
	v.Version = version
	s := v
	{
		v := b.String()
		s.ProtocolType = v
	}
	{
		v := b.Int32()
		s.Generation = v
	}
	{
		v := b.NullableString()
		s.Protocol = v
	}
	{
		v := b.NullableString()
		s.Leader = v
	}
	if version >= 2 {
		v := b.Int64()
		s.CurrentStateTimestamp = v
	}
	{
		v := s.Members
		a := v
		var l int32
		l = b.ArrayLen()
		if !b.Ok() {
			return b.Complete()
		}
		if l > 0 {
			a = make([]GroupMetadataValueMember, l)
		}
		for i := int32(0); i < l; i++ {
			v := &a[i]
			s := v
			{
				v := b.String()
				s.MemberID = v
			}
			if version >= 3 {
				v := b.NullableString()
				s.InstanceID = v
			}
			{
				v := b.String()
				s.ClientID = v
			}
			{
				v := b.String()
				s.ClientHost = v
			}
			if version >= 1 {
				v := b.Int32()
				s.RebalanceTimeoutMillis = v
			}
			{
				v := b.Int32()
				s.SessionTimeoutMillis = v
			}
			{
				v := b.Bytes()
				s.Subscription = v
			}
			{
				v := b.Bytes()
				s.Assignment = v
			}
		}
		v = a
		s.Members = v
	}
	return b.Complete()
}

// TxnMetadataKey is the key for the Kafka internal __transaction_state topic
// if the key starts with an int16 with a value of 0.
type TxnMetadataKey struct {
	// Version is the version of this type.
	Version int16

	// TransactionalID is the transactional ID this record is for.
	TransactionalID string
}

func (v *TxnMetadataKey) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	{
		v := v.Version
		dst = kbin.AppendInt16(dst, v)
	}
	{
		v := v.TransactionalID
		dst = kbin.AppendString(dst, v)
	}
	return dst
}
func (v *TxnMetadataKey) ReadFrom(src []byte) error {
	b := kbin.Reader{Src: src}
	version := b.Int16()
	v.Version = version
	s := v
	{
		v := b.String()
		s.TransactionalID = v
	}
	return b.Complete()
}

type TxnMetadataValueTopic struct {
	// Topic is a topic involved in this transaction.
	Topic string

	// Partitions are partitions in this topic involved in the transaction.
	Partitions []int32
}

// TxnMetadataValue is the value for the Kafka internal __transaction_state
// topic if the key is of TxnMetadataKey type.
type TxnMetadataValue struct {
	// Version is the version of this value.
	Version int16

	// ProducerID is the ID in use by the transactional ID.
	ProducerID int64

	// LastProducerID is the last ID in use for a producer; see KIP-360.
	LastProducerID int64 // v1+

	// ProducerEpoch is the epoch associated with the producer ID.
	ProducerEpoch int16

	// LastProducerEpoch is the last epoch in use for a producer; see KIP-360.
	LastProducerEpoch int16 // v1+

	// TimeoutMillis is the timeout of this transaction in milliseconds.
	TimeoutMillis int32

	// State is the state this transaction is in,
	// 0 is Empty, 1 is Ongoing, 2 is PrepareCommit, 3 is PrepareAbort, 4 is
	// CompleteCommit, 5 is CompleteAbort, 6 is Dead, and 7 is PrepareEpochFence.
	State int8

	// Topics are topics that are involved in this transaction.
	Topics []TxnMetadataValueTopic

	// LastUpdateTimestamp is the timestamp in millis of when this transaction
	// was last updated.
	LastUpdateTimestamp int64

	// StartTimestamp is the timestamp in millis of when this transaction started.
	StartTimestamp int64
}

func (v *TxnMetadataValue) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	{
		v := v.Version
		dst = kbin.AppendInt16(dst, v)
	}
	{
		v := v.ProducerID
		dst = kbin.AppendInt64(dst, v)
	}
	if version >= 1 {
		v := v.LastProducerID
		dst = kbin.AppendInt64(dst, v)
	}
	{
		v := v.ProducerEpoch
		dst = kbin.AppendInt16(dst, v)
	}
	if version >= 1 {
		v := v.LastProducerEpoch
		dst = kbin.AppendInt16(dst, v)
	}
	{
		v := v.TimeoutMillis
		dst = kbin.AppendInt32(dst, v)
	}
	{
		v := v.State
		dst = kbin.AppendInt8(dst, v)
	}
	{
		v := v.Topics
		dst = kbin.AppendArrayLen(dst, len(v))
		for i := range v {
			v := &v[i]
			{
				v := v.Topic
				dst = kbin.AppendString(dst, v)
			}
			{
				v := v.Partitions
				dst = kbin.AppendArrayLen(dst, len(v))
				for i := range v {
					v := v[i]
					dst = kbin.AppendInt32(dst, v)
				}
			}
		}
	}
	{
		v := v.LastUpdateTimestamp
		dst = kbin.AppendInt64(dst, v)
	}
	{
		v := v.StartTimestamp
		dst = kbin.AppendInt64(dst, v)
	}
	return dst
}
func (v *TxnMetadataValue) ReadFrom(src []byte) error {
	b := kbin.Reader{Src: src}
	version := b.Int16()
	v.Version = version
	s := v
	{
		v := b.Int64()
		s.ProducerID = v
	}
	if version >= 1 {
		v := b.Int64()
		s.LastProducerID = v
	}
	{
		v := b.Int16()
		s.ProducerEpoch = v
	}
	if version >= 1 {
		v := b.Int16()
		s.LastProducerEpoch = v
	}
	{
		v := b.Int32()
		s.TimeoutMillis = v
	}
	{
		v := b.Int8()
		s.State = v
	}
	{
		v := s.Topics
		a := v
		var l int32
		l = b.ArrayLen()
		if !b.Ok() {
			return b.Complete()
		}
		if l > 0 {
			a = make([]TxnMetadataValueTopic, l)
		}
		for i := int32(0); i < l; i++ {
			v := &a[i]
			s := v
			{
				v := b.String()
				s.Topic = v
			}
			{
				v := s.Partitions
				a := v
				var l int32
				l = b.ArrayLen()
				if !b.Ok() {
					return b.Complete()
				}
				if l > 0 {
					a = make([]int32, l)
				}
				for i := int32(0); i < l; i++ {
					v := b.Int32()
					a[i] = v
				}
				v = a
				s.Partitions = v
			}
		}
		v = a
		s.Topics = v
	}
	{
		v := b.Int64()
		s.LastUpdateTimestamp = v
	}
	{
		v := b.Int64()
		s.StartTimestamp = v
	}
	return b.Complete()
}

type OffsetCommitRequestTopicPartition struct {
	// Partition if a partition to commit offsets for.
	Partition int32

	// Offset is an offset to commit.
	Offset int64

	// Timestamp is the first iteration of tracking how long offset commits
	// should persist in Kafka. This field only existed for v1.
	// The expiration would be timestamp + offset.retention.minutes, or, if
	// timestamp was zero, current time + offset.retention.minutes.
	Timestamp int64 // v1+

	// LeaderEpoch, proposed in KIP-320 and introduced in Kafka 2.1.0,
	// is the leader epoch of the record this request is committing.
	//
	// The initial leader epoch can be determined from a MetadataResponse.
	// To skip log truncation checking, use -1.
	LeaderEpoch int32 // v6+

	// Metadata is optional data to include with committing the offset. This
	// can contain information such as which node is doing the committing, etc.
	Metadata *string
}
type OffsetCommitRequestTopic struct {
	// Topic is a topic to commit offsets for.
	Topic string

	// Partitions contains partitions in a topic for which to commit offsets.
	Partitions []OffsetCommitRequestTopicPartition
}

// OffsetCommitRequest commits offsets for consumed topics / partitions in
// a group.
type OffsetCommitRequest struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	// Group is the group this request is committing offsets to.
	Group string

	// Generation being -1 and group being empty means the group is being used
	// to store offsets only. No generation validation, no rebalancing.
	Generation int32 // v1+

	// MemberID is the ID of the client issuing this request in the group.
	MemberID string // v1+

	// InstanceID is the instance ID of this member in the group (KIP-345).
	InstanceID *string // v7+

	// RetentionTimeMillis is how long this commit will persist in Kafka.
	//
	// This was introduced in v2, replacing an individual topic/partition's
	// Timestamp from v1, and was removed in v5 with Kafka 2.1.0.
	//
	// This was removed because rarely committing consumers could have their
	// offsets expired before committing, even though the consumer was still
	// active. After restarting or rebalancing, the consumer would now not know
	// the last committed offset and would have to start at the beginning or end,
	// leading to duplicates or log loss.
	//
	// Post 2.1.0, if this field is empty, offsets are only deleted once the
	// group is empty. Read KIP-211 for more details.
	RetentionTimeMillis int64 // v2+

	// Topics is contains topics and partitions for which to commit offsets.
	Topics []OffsetCommitRequestTopic
}

func (*OffsetCommitRequest) Key() int16                   { return 8 }
func (*OffsetCommitRequest) MaxVersion() int16            { return 8 }
func (v *OffsetCommitRequest) SetVersion(version int16)   { v.Version = version }
func (v *OffsetCommitRequest) GetVersion() int16          { return v.Version }
func (v *OffsetCommitRequest) IsFlexible() bool           { return v.Version >= 8 }
func (v *OffsetCommitRequest) IsGroupCoordinatorRequest() {}
func (v *OffsetCommitRequest) ResponseKind() Response {
	return &OffsetCommitResponse{Version: v.Version}
}

func (v *OffsetCommitRequest) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	isFlexible := version >= 8
	_ = isFlexible
	{
		v := v.Group
		if isFlexible {
			dst = kbin.AppendCompactString(dst, v)
		} else {
			dst = kbin.AppendString(dst, v)
		}
	}
	if version >= 1 {
		v := v.Generation
		dst = kbin.AppendInt32(dst, v)
	}
	if version >= 1 {
		v := v.MemberID
		if isFlexible {
			dst = kbin.AppendCompactString(dst, v)
		} else {
			dst = kbin.AppendString(dst, v)
		}
	}
	if version >= 7 {
		v := v.InstanceID
		if isFlexible {
			dst = kbin.AppendCompactNullableString(dst, v)
		} else {
			dst = kbin.AppendNullableString(dst, v)
		}
	}
	if version >= 2 && version <= 4 {
		v := v.RetentionTimeMillis
		dst = kbin.AppendInt64(dst, v)
	}
	{
		v := v.Topics
		if isFlexible {
			dst = kbin.AppendCompactArrayLen(dst, len(v))
		} else {
			dst = kbin.AppendArrayLen(dst, len(v))
		}
		for i := range v {
			v := &v[i]
			{
				v := v.Topic
				if isFlexible {
					dst = kbin.AppendCompactString(dst, v)
				} else {
					dst = kbin.AppendString(dst, v)
				}
			}
			{
				v := v.Partitions
				if isFlexible {
					dst = kbin.AppendCompactArrayLen(dst, len(v))
				} else {
					dst = kbin.AppendArrayLen(dst, len(v))
				}
				for i := range v {
					v := &v[i]
					{
						v := v.Partition
						dst = kbin.AppendInt32(dst, v)
					}
					{
						v := v.Offset
						dst = kbin.AppendInt64(dst, v)
					}
					if version >= 1 && version <= 1 {
						v := v.Timestamp
						dst = kbin.AppendInt64(dst, v)
					}
					if version >= 6 {
						v := v.LeaderEpoch
						dst = kbin.AppendInt32(dst, v)
					}
					{
						v := v.Metadata
						if isFlexible {
							dst = kbin.AppendCompactNullableString(dst, v)
						} else {
							dst = kbin.AppendNullableString(dst, v)
						}
					}
					if isFlexible {
						dst = kbin.AppendUvarint(dst, 0)
					}
				}
			}
			if isFlexible {
				dst = kbin.AppendUvarint(dst, 0)
			}
		}
	}
	if isFlexible {
		dst = kbin.AppendUvarint(dst, 0)
	}
	return dst
}
func (v *OffsetCommitRequest) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	isFlexible := version >= 8
	_ = isFlexible
	b := kbin.Reader{Src: src}
	s := v
	{
		var v string
		if isFlexible {
			v = b.CompactString()
		} else {
			v = b.String()
		}
		s.Group = v
	}
	if version >= 1 {
		v := b.Int32()
		s.Generation = v
	}
	if version >= 1 {
		var v string
		if isFlexible {
			v = b.CompactString()
		} else {
			v = b.String()
		}
		s.MemberID = v
	}
	if version >= 7 {
		var v *string
		if isFlexible {
			v = b.CompactNullableString()
		} else {
			v = b.NullableString()
		}
		s.InstanceID = v
	}
	if version >= 2 && version <= 4 {
		v := b.Int64()
		s.RetentionTimeMillis = v
	}
	{
		v := s.Topics
		a := v
		var l int32
		if isFlexible {
			l = b.CompactArrayLen()
		} else {
			l = b.ArrayLen()
		}
		if !b.Ok() {
			return b.Complete()
		}
		if l > 0 {
			a = make([]OffsetCommitRequestTopic, l)
		}
		for i := int32(0); i < l; i++ {
			v := &a[i]
			s := v
			{
				var v string
				if isFlexible {
					v = b.CompactString()
				} else {
					v = b.String()
				}
				s.Topic = v
			}
			{
				v := s.Partitions
				a := v
				var l int32
				if isFlexible {
					l = b.CompactArrayLen()
				} else {
					l = b.ArrayLen()
				}
				if !b.Ok() {
					return b.Complete()
				}
				if l > 0 {
					a = make([]OffsetCommitRequestTopicPartition, l)
				}
				for i := int32(0); i < l; i++ {
					v := &a[i]
					s := v
					{
						v := b.Int32()
						s.Partition = v
					}
					{
						v := b.Int64()
						s.Offset = v
					}
					if version >= 1 && version <= 1 {
						v := b.Int64()
						s.Timestamp = v
					}
					if version >= 6 {
						v := b.Int32()
						s.LeaderEpoch = v
					}
					{
						var v *string
						if isFlexible {
							v = b.CompactNullableString()
						} else {
							v = b.NullableString()
						}
						s.Metadata = v
					}
					if isFlexible {
						SkipTags(&b)
					}
				}
				v = a
				s.Partitions = v
			}
			if isFlexible {
				SkipTags(&b)
			}
		}
		v = a
		s.Topics = v
	}
	if isFlexible {
		SkipTags(&b)
	}
	return b.Complete()
}

type OffsetCommitResponseTopicPartition struct {
	// Partition is the partition in a topic this array slot corresponds to.
	Partition int32

	// ErrorCode is the error for this partition response.
	//
	// GROUP_AUTHORIZATION_FAILED is returned if the client is not authorized
	// for the group.
	//
	// TOPIC_AUTHORIZATION_FAILED is returned if the client is not authorized
	// for the topic / partition.
	//
	// UNKNOWN_TOPIC_OR_PARTITION is returned if the topic / partition does
	// not exist.
	//
	// OFFSET_METADATA_TOO_LARGE is returned if the request metadata is
	// larger than the brokers offset.metadata.max.bytes.
	//
	// INVALID_GROUP_ID is returned in the requested group ID is invalid.
	//
	// COORDINATOR_NOT_AVAILABLE is returned if the coordinator is not available
	// (due to the requested broker shutting down or it has not completed startup).
	//
	// COORDINATOR_LOAD_IN_PROGRESS is returned if the group is loading.
	//
	// NOT_COORDINATOR is returned if the requested broker is not the coordinator
	// for the requested group.
	//
	// ILLEGAL_GENERATION is returned if the request's generation ID is invalid.
	//
	// UNKNOWN_MEMBER_ID is returned if the group is dead or the group does not
	// know of the request's member ID.
	//
	// REBALANCE_IN_PROGRESS is returned if the group is finishing a rebalance.
	//
	// INVALID_COMMIT_OFFSET_SIZE is returned if the offset commit results in
	// a record batch that is too large (likely due to large metadata).
	ErrorCode int16
}
type OffsetCommitResponseTopic struct {
	// Topic is the topic this offset commit response corresponds to.
	Topic string

	// Partitions contains responses for each requested partition in
	// a topic.
	Partitions []OffsetCommitResponseTopicPartition
}

// OffsetCommitResponse is returned from an OffsetCommitRequest.
type OffsetCommitResponse struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	// ThrottleMillis is how long of a throttle Kafka will apply to the client
	// after this request.
	// For Kafka < 2.0.0, the throttle is applied before issuing a response.
	// For Kafka >= 2.0.0, the throttle is applied after issuing a response.
	ThrottleMillis int32 // v3+

	// Topics contains responses for each topic / partition in the commit request.
	Topics []OffsetCommitResponseTopic
}

func (*OffsetCommitResponse) Key() int16                 { return 8 }
func (*OffsetCommitResponse) MaxVersion() int16          { return 8 }
func (v *OffsetCommitResponse) SetVersion(version int16) { v.Version = version }
func (v *OffsetCommitResponse) GetVersion() int16        { return v.Version }
func (v *OffsetCommitResponse) IsFlexible() bool         { return v.Version >= 8 }
func (v *OffsetCommitResponse) RequestKind() Request     { return &OffsetCommitRequest{Version: v.Version} }

func (v *OffsetCommitResponse) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	isFlexible := version >= 8
	_ = isFlexible
	if version >= 3 {
		v := v.ThrottleMillis
		dst = kbin.AppendInt32(dst, v)
	}
	{
		v := v.Topics
		if isFlexible {
			dst = kbin.AppendCompactArrayLen(dst, len(v))
		} else {
			dst = kbin.AppendArrayLen(dst, len(v))
		}
		for i := range v {
			v := &v[i]
			{
				v := v.Topic
				if isFlexible {
					dst = kbin.AppendCompactString(dst, v)
				} else {
					dst = kbin.AppendString(dst, v)
				}
			}
			{
				v := v.Partitions
				if isFlexible {
					dst = kbin.AppendCompactArrayLen(dst, len(v))
				} else {
					dst = kbin.AppendArrayLen(dst, len(v))
				}
				for i := range v {
					v := &v[i]
					{
						v := v.Partition
						dst = kbin.AppendInt32(dst, v)
					}
					{
						v := v.ErrorCode
						dst = kbin.AppendInt16(dst, v)
					}
					if isFlexible {
						dst = kbin.AppendUvarint(dst, 0)
					}
				}
			}
			if isFlexible {
				dst = kbin.AppendUvarint(dst, 0)
			}
		}
	}
	if isFlexible {
		dst = kbin.AppendUvarint(dst, 0)
	}
	return dst
}
func (v *OffsetCommitResponse) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	isFlexible := version >= 8
	_ = isFlexible
	b := kbin.Reader{Src: src}
	s := v
	if version >= 3 {
		v := b.Int32()
		s.ThrottleMillis = v
	}
	{
		v := s.Topics
		a := v
		var l int32
		if isFlexible {
			l = b.CompactArrayLen()
		} else {
			l = b.ArrayLen()
		}
		if !b.Ok() {
			return b.Complete()
		}
		if l > 0 {
			a = make([]OffsetCommitResponseTopic, l)
		}
		for i := int32(0); i < l; i++ {
			v := &a[i]
			s := v
			{
				var v string
				if isFlexible {
					v = b.CompactString()
				} else {
					v = b.String()
				}
				s.Topic = v
			}
			{
				v := s.Partitions
				a := v
				var l int32
				if isFlexible {
					l = b.CompactArrayLen()
				} else {
					l = b.ArrayLen()
				}
				if !b.Ok() {
					return b.Complete()
				}
				if l > 0 {
					a = make([]OffsetCommitResponseTopicPartition, l)
				}
				for i := int32(0); i < l; i++ {
					v := &a[i]
					s := v
					{
						v := b.Int32()
						s.Partition = v
					}
					{
						v := b.Int16()
						s.ErrorCode = v
					}
					if isFlexible {
						SkipTags(&b)
					}
				}
				v = a
				s.Partitions = v
			}
			if isFlexible {
				SkipTags(&b)
			}
		}
		v = a
		s.Topics = v
	}
	if isFlexible {
		SkipTags(&b)
	}
	return b.Complete()
}

type OffsetFetchRequestTopic struct {
	// Topic is a topic to fetch offsets for.
	Topic string

	// Partitions in a list of partitions in a group to fetch offsets for.
	Partitions []int32
}

// OffsetFetchRequest requests the most recent committed offsets for topic
// partitions in a group.
type OffsetFetchRequest struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	// Group is the group to fetch offsets for.
	Group string

	// Topics contains topics to fetch offets for. Version 2+ allows this to be
	// null to return all topics the client is authorized to describe in the group.
	Topics []OffsetFetchRequestTopic

	// RequireStable signifies whether the broker should wait on returning
	// unstable offsets, instead setting a retriable error on the relevant
	// unstable partitions (UNSTABLE_OFFSET_COMMIT). See KIP-447 for more
	// details.
	RequireStable bool // v7+
}

func (*OffsetFetchRequest) Key() int16                   { return 9 }
func (*OffsetFetchRequest) MaxVersion() int16            { return 7 }
func (v *OffsetFetchRequest) SetVersion(version int16)   { v.Version = version }
func (v *OffsetFetchRequest) GetVersion() int16          { return v.Version }
func (v *OffsetFetchRequest) IsFlexible() bool           { return v.Version >= 6 }
func (v *OffsetFetchRequest) IsGroupCoordinatorRequest() {}
func (v *OffsetFetchRequest) ResponseKind() Response     { return &OffsetFetchResponse{Version: v.Version} }

func (v *OffsetFetchRequest) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	isFlexible := version >= 6
	_ = isFlexible
	{
		v := v.Group
		if isFlexible {
			dst = kbin.AppendCompactString(dst, v)
		} else {
			dst = kbin.AppendString(dst, v)
		}
	}
	{
		v := v.Topics
		if version > 2 {
			if isFlexible {
				dst = kbin.AppendCompactNullableArrayLen(dst, len(v), v == nil)
			} else {
				dst = kbin.AppendNullableArrayLen(dst, len(v), v == nil)
			}
		} else {
			if isFlexible {
				dst = kbin.AppendCompactArrayLen(dst, len(v))
			} else {
				dst = kbin.AppendArrayLen(dst, len(v))
			}
		}
		for i := range v {
			v := &v[i]
			{
				v := v.Topic
				if isFlexible {
					dst = kbin.AppendCompactString(dst, v)
				} else {
					dst = kbin.AppendString(dst, v)
				}
			}
			{
				v := v.Partitions
				if isFlexible {
					dst = kbin.AppendCompactArrayLen(dst, len(v))
				} else {
					dst = kbin.AppendArrayLen(dst, len(v))
				}
				for i := range v {
					v := v[i]
					dst = kbin.AppendInt32(dst, v)
				}
			}
			if isFlexible {
				dst = kbin.AppendUvarint(dst, 0)
			}
		}
	}
	if version >= 7 {
		v := v.RequireStable
		dst = kbin.AppendBool(dst, v)
	}
	if isFlexible {
		dst = kbin.AppendUvarint(dst, 0)
	}
	return dst
}
func (v *OffsetFetchRequest) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	isFlexible := version >= 6
	_ = isFlexible
	b := kbin.Reader{Src: src}
	s := v
	{
		var v string
		if isFlexible {
			v = b.CompactString()
		} else {
			v = b.String()
		}
		s.Group = v
	}
	{
		v := s.Topics
		a := v
		var l int32
		if isFlexible {
			l = b.CompactArrayLen()
		} else {
			l = b.ArrayLen()
		}
		if version < 2 || l == 0 {
			a = []OffsetFetchRequestTopic{}
		}
		if !b.Ok() {
			return b.Complete()
		}
		if l > 0 {
			a = make([]OffsetFetchRequestTopic, l)
		}
		for i := int32(0); i < l; i++ {
			v := &a[i]
			s := v
			{
				var v string
				if isFlexible {
					v = b.CompactString()
				} else {
					v = b.String()
				}
				s.Topic = v
			}
			{
				v := s.Partitions
				a := v
				var l int32
				if isFlexible {
					l = b.CompactArrayLen()
				} else {
					l = b.ArrayLen()
				}
				if !b.Ok() {
					return b.Complete()
				}
				if l > 0 {
					a = make([]int32, l)
				}
				for i := int32(0); i < l; i++ {
					v := b.Int32()
					a[i] = v
				}
				v = a
				s.Partitions = v
			}
			if isFlexible {
				SkipTags(&b)
			}
		}
		v = a
		s.Topics = v
	}
	if version >= 7 {
		v := b.Bool()
		s.RequireStable = v
	}
	if isFlexible {
		SkipTags(&b)
	}
	return b.Complete()
}

type OffsetFetchResponseTopicPartition struct {
	// Partition is the partition in a topic this array slot corresponds to.
	Partition int32

	// Offset is the most recently committed offset for this topic partition
	// in a group.
	Offset int64

	// LeaderEpoch is the leader epoch of the last consumed record.
	//
	// This was proposed in KIP-320 and introduced in Kafka 2.1.0 and allows
	// clients to detect log truncation. See the KIP for more details.
	LeaderEpoch int32 // v5+

	// Metadata is client provided metadata corresponding to the offset commit.
	// This can be useful for adding who made the commit, etc.
	Metadata *string

	// ErrorCode is the error for this partition response.
	//
	// GROUP_AUTHORIZATION_FAILED is returned if the client is not authorized
	// to the group.
	//
	// INVALID_GROUP_ID is returned in the requested group ID is invalid.
	//
	// COORDINATOR_NOT_AVAILABLE is returned if the coordinator is not available
	// (due to the requested broker shutting down or it has not completed startup).
	//
	// COORDINATOR_LOAD_IN_PROGRESS is returned if the group is loading.
	//
	// NOT_COORDINATOR is returned if the requested broker is not the coordinator
	// for the requested group.
	//
	// UNKNOWN_TOPIC_OR_PARTITION is returned if the requested topic or partition
	// is unknown.
	//
	// UNSTABLE_OFFSET_COMMIT is returned for v7+ if the request set RequireStable.
	// See KIP-447 for more details.
	ErrorCode int16
}
type OffsetFetchResponseTopic struct {
	// Topic is the topic this offset fetch response corresponds to.
	Topic string

	// Partitions contains responses for each requested partition in
	// a topic.
	Partitions []OffsetFetchResponseTopicPartition
}

// OffsetFetchResponse is returned from an OffsetFetchRequest.
type OffsetFetchResponse struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	// ThrottleMillis is how long of a throttle Kafka will apply to the client
	// after this request.
	// For Kafka < 2.0.0, the throttle is applied before issuing a response.
	// For Kafka >= 2.0.0, the throttle is applied after issuing a response.
	ThrottleMillis int32 // v3+

	// Topics contains responses for each requested topic/partition.
	Topics []OffsetFetchResponseTopic

	// ErrorCode is a top level error code that applies to all topic/partitions.
	// This will be any group error.
	ErrorCode int16 // v2+
}

func (*OffsetFetchResponse) Key() int16                 { return 9 }
func (*OffsetFetchResponse) MaxVersion() int16          { return 7 }
func (v *OffsetFetchResponse) SetVersion(version int16) { v.Version = version }
func (v *OffsetFetchResponse) GetVersion() int16        { return v.Version }
func (v *OffsetFetchResponse) IsFlexible() bool         { return v.Version >= 6 }
func (v *OffsetFetchResponse) RequestKind() Request     { return &OffsetFetchRequest{Version: v.Version} }

func (v *OffsetFetchResponse) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	isFlexible := version >= 6
	_ = isFlexible
	if version >= 3 {
		v := v.ThrottleMillis
		dst = kbin.AppendInt32(dst, v)
	}
	{
		v := v.Topics
		if isFlexible {
			dst = kbin.AppendCompactArrayLen(dst, len(v))
		} else {
			dst = kbin.AppendArrayLen(dst, len(v))
		}
		for i := range v {
			v := &v[i]
			{
				v := v.Topic
				if isFlexible {
					dst = kbin.AppendCompactString(dst, v)
				} else {
					dst = kbin.AppendString(dst, v)
				}
			}
			{
				v := v.Partitions
				if isFlexible {
					dst = kbin.AppendCompactArrayLen(dst, len(v))
				} else {
					dst = kbin.AppendArrayLen(dst, len(v))
				}
				for i := range v {
					v := &v[i]
					{
						v := v.Partition
						dst = kbin.AppendInt32(dst, v)
					}
					{
						v := v.Offset
						dst = kbin.AppendInt64(dst, v)
					}
					if version >= 5 {
						v := v.LeaderEpoch
						dst = kbin.AppendInt32(dst, v)
					}
					{
						v := v.Metadata
						if isFlexible {
							dst = kbin.AppendCompactNullableString(dst, v)
						} else {
							dst = kbin.AppendNullableString(dst, v)
						}
					}
					{
						v := v.ErrorCode
						dst = kbin.AppendInt16(dst, v)
					}
					if isFlexible {
						dst = kbin.AppendUvarint(dst, 0)
					}
				}
			}
			if isFlexible {
				dst = kbin.AppendUvarint(dst, 0)
			}
		}
	}
	if version >= 2 {
		v := v.ErrorCode
		dst = kbin.AppendInt16(dst, v)
	}
	if isFlexible {
		dst = kbin.AppendUvarint(dst, 0)
	}
	return dst
}
func (v *OffsetFetchResponse) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	isFlexible := version >= 6
	_ = isFlexible
	b := kbin.Reader{Src: src}
	s := v
	if version >= 3 {
		v := b.Int32()
		s.ThrottleMillis = v
	}
	{
		v := s.Topics
		a := v
		var l int32
		if isFlexible {
			l = b.CompactArrayLen()
		} else {
			l = b.ArrayLen()
		}
		if !b.Ok() {
			return b.Complete()
		}
		if l > 0 {
			a = make([]OffsetFetchResponseTopic, l)
		}
		for i := int32(0); i < l; i++ {
			v := &a[i]
			s := v
			{
				var v string
				if isFlexible {
					v = b.CompactString()
				} else {
					v = b.String()
				}
				s.Topic = v
			}
			{
				v := s.Partitions
				a := v
				var l int32
				if isFlexible {
					l = b.CompactArrayLen()
				} else {
					l = b.ArrayLen()
				}
				if !b.Ok() {
					return b.Complete()
				}
				if l > 0 {
					a = make([]OffsetFetchResponseTopicPartition, l)
				}
				for i := int32(0); i < l; i++ {
					v := &a[i]
					s := v
					{
						v := b.Int32()
						s.Partition = v
					}
					{
						v := b.Int64()
						s.Offset = v
					}
					if version >= 5 {
						v := b.Int32()
						s.LeaderEpoch = v
					}
					{
						var v *string
						if isFlexible {
							v = b.CompactNullableString()
						} else {
							v = b.NullableString()
						}
						s.Metadata = v
					}
					{
						v := b.Int16()
						s.ErrorCode = v
					}
					if isFlexible {
						SkipTags(&b)
					}
				}
				v = a
				s.Partitions = v
			}
			if isFlexible {
				SkipTags(&b)
			}
		}
		v = a
		s.Topics = v
	}
	if version >= 2 {
		v := b.Int16()
		s.ErrorCode = v
	}
	if isFlexible {
		SkipTags(&b)
	}
	return b.Complete()
}

// FindCoordinatorRequest requests the coordinator for a group or transaction.
//
// This coordinator is different from the broker leader coordinator. This
// coordinator is the partition leader for the partition that is storing
// the group or transaction ID.
type FindCoordinatorRequest struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	// CoordinatorKey is the ID to use for finding the coordinator. For groups,
	// this is the group name, for transactional producer, this is the
	// transactional ID.
	CoordinatorKey string

	// CoordinatorType is the type that key is. Groups are type 0,
	// transactional IDs are type 1.
	CoordinatorType int8 // v1+
}

func (*FindCoordinatorRequest) Key() int16                 { return 10 }
func (*FindCoordinatorRequest) MaxVersion() int16          { return 3 }
func (v *FindCoordinatorRequest) SetVersion(version int16) { v.Version = version }
func (v *FindCoordinatorRequest) GetVersion() int16        { return v.Version }
func (v *FindCoordinatorRequest) IsFlexible() bool         { return v.Version >= 3 }
func (v *FindCoordinatorRequest) ResponseKind() Response {
	return &FindCoordinatorResponse{Version: v.Version}
}

func (v *FindCoordinatorRequest) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	isFlexible := version >= 3
	_ = isFlexible
	{
		v := v.CoordinatorKey
		if isFlexible {
			dst = kbin.AppendCompactString(dst, v)
		} else {
			dst = kbin.AppendString(dst, v)
		}
	}
	if version >= 1 {
		v := v.CoordinatorType
		dst = kbin.AppendInt8(dst, v)
	}
	if isFlexible {
		dst = kbin.AppendUvarint(dst, 0)
	}
	return dst
}
func (v *FindCoordinatorRequest) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	isFlexible := version >= 3
	_ = isFlexible
	b := kbin.Reader{Src: src}
	s := v
	{
		var v string
		if isFlexible {
			v = b.CompactString()
		} else {
			v = b.String()
		}
		s.CoordinatorKey = v
	}
	if version >= 1 {
		v := b.Int8()
		s.CoordinatorType = v
	}
	if isFlexible {
		SkipTags(&b)
	}
	return b.Complete()
}

// FindCoordinatorResponse is returned from a FindCoordinatorRequest.
type FindCoordinatorResponse struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	// ThrottleMillis is how long of a throttle Kafka will apply to the client
	// after this request.
	// For Kafka < 2.0.0, the throttle is applied before issuing a response.
	// For Kafka >= 2.0.0, the throttle is applied after issuing a response.
	ThrottleMillis int32 // v1+

	// ErrorCode is the error returned for the request.
	//
	// GROUP_AUTHORIZATION_FAILED is returned if for a group ID request and the
	// client is not authorized to describe groups.
	//
	// TRANSACTIONAL_ID_AUTHORIZATION_FAILED is returned for a transactional ID
	// request and the client is not authorized to describe transactional IDs.
	//
	// INVALID_REQUEST is returned if not asking for a known type (group,
	// or transaction).
	//
	// COORDINATOR_NOT_AVAILABLE is returned if the coordinator is not available
	// for the requested ID, or if the requested ID does not exist.
	ErrorCode int16

	// ErrorMessage is an informative message if the request errored.
	ErrorMessage *string // v1+

	// NodeID is the broker ID of the coordinator.
	NodeID int32

	// Host is the host of the coordinator.
	Host string

	// Port is the port of the coordinator.
	Port int32
}

func (*FindCoordinatorResponse) Key() int16                 { return 10 }
func (*FindCoordinatorResponse) MaxVersion() int16          { return 3 }
func (v *FindCoordinatorResponse) SetVersion(version int16) { v.Version = version }
func (v *FindCoordinatorResponse) GetVersion() int16        { return v.Version }
func (v *FindCoordinatorResponse) IsFlexible() bool         { return v.Version >= 3 }
func (v *FindCoordinatorResponse) RequestKind() Request {
	return &FindCoordinatorRequest{Version: v.Version}
}

func (v *FindCoordinatorResponse) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	isFlexible := version >= 3
	_ = isFlexible
	if version >= 1 {
		v := v.ThrottleMillis
		dst = kbin.AppendInt32(dst, v)
	}
	{
		v := v.ErrorCode
		dst = kbin.AppendInt16(dst, v)
	}
	if version >= 1 {
		v := v.ErrorMessage
		if isFlexible {
			dst = kbin.AppendCompactNullableString(dst, v)
		} else {
			dst = kbin.AppendNullableString(dst, v)
		}
	}
	{
		v := v.NodeID
		dst = kbin.AppendInt32(dst, v)
	}
	{
		v := v.Host
		if isFlexible {
			dst = kbin.AppendCompactString(dst, v)
		} else {
			dst = kbin.AppendString(dst, v)
		}
	}
	{
		v := v.Port
		dst = kbin.AppendInt32(dst, v)
	}
	if isFlexible {
		dst = kbin.AppendUvarint(dst, 0)
	}
	return dst
}
func (v *FindCoordinatorResponse) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	isFlexible := version >= 3
	_ = isFlexible
	b := kbin.Reader{Src: src}
	s := v
	if version >= 1 {
		v := b.Int32()
		s.ThrottleMillis = v
	}
	{
		v := b.Int16()
		s.ErrorCode = v
	}
	if version >= 1 {
		var v *string
		if isFlexible {
			v = b.CompactNullableString()
		} else {
			v = b.NullableString()
		}
		s.ErrorMessage = v
	}
	{
		v := b.Int32()
		s.NodeID = v
	}
	{
		var v string
		if isFlexible {
			v = b.CompactString()
		} else {
			v = b.String()
		}
		s.Host = v
	}
	{
		v := b.Int32()
		s.Port = v
	}
	if isFlexible {
		SkipTags(&b)
	}
	return b.Complete()
}

type StickyMemberMetadataCurrentAssignment struct {
	// Topic is a topic the group member is currently assigned.
	Topic string

	// Partitions are the partitions within a topic that a group member is
	// currently assigned.
	Partitions []int32
}

// StickyMemberMetadata is is what is encoded in UserData for
// GroupMemberMetadata in group join requests with the sticky partitioning
// strategy.
//
// V1 added generation, which fixed a bug with flaky group members joining
// repeatedly. See KIP-341 for more details.
//
// Note that clients should always try decoding as v1 and, if that fails,
// fall back to v0. This is necessary due to there being no version number
// anywhere in this type.
type StickyMemberMetadata struct {
	// CurrentAssignment is the assignment that a group member has when
	// issuing a join.
	CurrentAssignment []StickyMemberMetadataCurrentAssignment

	// Generation is the generation of this join. This is incremented every join.
	Generation int32 // v1+
}
type GroupMemberMetadataOwnedPartition struct {
	Topic string

	Partitions []int32
}

// GroupMemberMetadata is the metadata that is usually sent with a join group
// request.
type GroupMemberMetadata struct {
	// Version is either version 0 or version 1.
	Version int16

	// Topics is the list of topics in the group that this member is interested
	// in consuming.
	Topics []string

	// UserData is arbitrary client data for a given client in the group.
	// For sticky assignment, this is StickyMemberMetadata.
	UserData []byte

	// OwnedPartitions, introduced for KIP-429, are the partitions that this
	// member currently owns.
	OwnedPartitions []GroupMemberMetadataOwnedPartition // v1+
}

func (v *GroupMemberMetadata) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	{
		v := v.Version
		dst = kbin.AppendInt16(dst, v)
	}
	{
		v := v.Topics
		dst = kbin.AppendArrayLen(dst, len(v))
		for i := range v {
			v := v[i]
			dst = kbin.AppendString(dst, v)
		}
	}
	{
		v := v.UserData
		dst = kbin.AppendBytes(dst, v)
	}
	if version >= 1 {
		v := v.OwnedPartitions
		dst = kbin.AppendArrayLen(dst, len(v))
		for i := range v {
			v := &v[i]
			{
				v := v.Topic
				dst = kbin.AppendString(dst, v)
			}
			{
				v := v.Partitions
				dst = kbin.AppendArrayLen(dst, len(v))
				for i := range v {
					v := v[i]
					dst = kbin.AppendInt32(dst, v)
				}
			}
		}
	}
	return dst
}
func (v *GroupMemberMetadata) ReadFrom(src []byte) error {
	b := kbin.Reader{Src: src}
	version := b.Int16()
	v.Version = version
	s := v
	{
		v := s.Topics
		a := v
		var l int32
		l = b.ArrayLen()
		if !b.Ok() {
			return b.Complete()
		}
		if l > 0 {
			a = make([]string, l)
		}
		for i := int32(0); i < l; i++ {
			v := b.String()
			a[i] = v
		}
		v = a
		s.Topics = v
	}
	{
		v := b.Bytes()
		s.UserData = v
	}
	if version >= 1 {
		v := s.OwnedPartitions
		a := v
		var l int32
		l = b.ArrayLen()
		if !b.Ok() {
			return b.Complete()
		}
		if l > 0 {
			a = make([]GroupMemberMetadataOwnedPartition, l)
		}
		for i := int32(0); i < l; i++ {
			v := &a[i]
			s := v
			{
				v := b.String()
				s.Topic = v
			}
			{
				v := s.Partitions
				a := v
				var l int32
				l = b.ArrayLen()
				if !b.Ok() {
					return b.Complete()
				}
				if l > 0 {
					a = make([]int32, l)
				}
				for i := int32(0); i < l; i++ {
					v := b.Int32()
					a[i] = v
				}
				v = a
				s.Partitions = v
			}
		}
		v = a
		s.OwnedPartitions = v
	}
	return b.Complete()
}

type GroupMemberAssignmentTopic struct {
	// Topic is a topic in the assignment.
	Topic string

	// Partitions contains partitions in the assignment.
	Partitions []int32
}

// GroupMemberAssignment is the assignment data that is usually sent with a
// sync group request.
type GroupMemberAssignment struct {
	// Verson is currently version 0.
	Version int16

	// Topics contains topics in the assignment.
	Topics []GroupMemberAssignmentTopic

	// UserData is arbitrary client data for a given client in the group.
	UserData []byte
}

func (v *GroupMemberAssignment) AppendTo(dst []byte) []byte {
	{
		v := v.Version
		dst = kbin.AppendInt16(dst, v)
	}
	{
		v := v.Topics
		dst = kbin.AppendArrayLen(dst, len(v))
		for i := range v {
			v := &v[i]
			{
				v := v.Topic
				dst = kbin.AppendString(dst, v)
			}
			{
				v := v.Partitions
				dst = kbin.AppendArrayLen(dst, len(v))
				for i := range v {
					v := v[i]
					dst = kbin.AppendInt32(dst, v)
				}
			}
		}
	}
	{
		v := v.UserData
		dst = kbin.AppendBytes(dst, v)
	}
	return dst
}
func (v *GroupMemberAssignment) ReadFrom(src []byte) error {
	b := kbin.Reader{Src: src}
	s := v
	{
		v := b.Int16()
		s.Version = v
	}
	{
		v := s.Topics
		a := v
		var l int32
		l = b.ArrayLen()
		if !b.Ok() {
			return b.Complete()
		}
		if l > 0 {
			a = make([]GroupMemberAssignmentTopic, l)
		}
		for i := int32(0); i < l; i++ {
			v := &a[i]
			s := v
			{
				v := b.String()
				s.Topic = v
			}
			{
				v := s.Partitions
				a := v
				var l int32
				l = b.ArrayLen()
				if !b.Ok() {
					return b.Complete()
				}
				if l > 0 {
					a = make([]int32, l)
				}
				for i := int32(0); i < l; i++ {
					v := b.Int32()
					a[i] = v
				}
				v = a
				s.Partitions = v
			}
		}
		v = a
		s.Topics = v
	}
	{
		v := b.Bytes()
		s.UserData = v
	}
	return b.Complete()
}

type JoinGroupRequestProtocol struct {
	// Name is a name of a protocol. This is arbitrary, but is used
	// in the official client to agree on a partition balancing strategy.
	//
	// The official client uses range, roundrobin, or sticky (which was
	// introduced in KIP-54).
	Name string

	// Metadata is arbitrary information to pass along with this
	// protocol name for this member.
	//
	// Note that while this is not documented in any protocol page,
	// this is usually a serialized GroupMemberMetadata as described in
	// https://cwiki.apache.org/confluence/display/KAFKA/Kafka+Client-side+Assignment+Proposal.
	//
	// The protocol metadata is where group members will communicate which
	// topics they collectively as a group want to consume.
	Metadata []byte
}

// JoinGroupRequest issues a request to join a Kafka group. This will create a
// group if one does not exist. If joining an existing group, this may trigger
// a group rebalance.
//
// This will trigger a group rebalance if the request is from the group leader,
// or if the request is from a group member with different metadata, or if the
// request is with a new group member.
//
// Version 4 introduced replying to joins of existing groups with
// MEMBER_ID_REQUIRED, which requires re-issuing the join group with the
// returned member ID. See KIP-394 for more details.
//
// Version 5 introduced InstanceID, allowing for more "static" membership.
// See KIP-345 for more details.
type JoinGroupRequest struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	// Group is the group to join.
	Group string

	// SessionTimeoutMillis is how long a member in the group can go between
	// heartbeats. If a member does not send a heartbeat within this timeout,
	// the broker will remove the member from the group and initiate a rebalance.
	SessionTimeoutMillis int32

	// RebalanceTimeoutMillis is how long the broker waits for members to join a group
	// once a rebalance begins. Kafka waits for the longest rebalance of all
	// members in the group. Member sessions are still alive; heartbeats will be
	// replied to with REBALANCE_IN_PROGRESS. Those members must transition to
	// joining within this rebalance timeout. Members that do not rejoin within
	// this timeout will be removed from the group. Members must commit offsets
	// within this timeout.
	//
	// The first join for a new group has a 3 second grace period for other
	// members to join; this grace period is extended until the RebalanceTimeoutMillis
	// is up or until 3 seconds lapse with no new members.
	RebalanceTimeoutMillis int32 // v1+

	// MemberID is the member ID to join the group with. When joining a group for
	// the first time, use the empty string. The response will contain the member
	// ID that should be used going forward.
	MemberID string

	// InstanceID is a user configured ID that is used for making a group
	// member "static", allowing many rebalances to be avoided.
	InstanceID *string // v5+

	// ProtocolType is the "type" of protocol being used for the join group.
	// The initial group creation sets the type; all additional members must
	// have the same type or they will be rejected.
	//
	// This is completely arbitrary, but the Java client and everything else
	// uses "consumer" as the protocol type.
	ProtocolType string

	// Protocols contains arbitrary information that group members use
	// for rebalancing. All group members must agree on at least one protocol
	// name.
	Protocols []JoinGroupRequestProtocol
}

func (*JoinGroupRequest) Key() int16                   { return 11 }
func (*JoinGroupRequest) MaxVersion() int16            { return 7 }
func (v *JoinGroupRequest) SetVersion(version int16)   { v.Version = version }
func (v *JoinGroupRequest) GetVersion() int16          { return v.Version }
func (v *JoinGroupRequest) IsFlexible() bool           { return v.Version >= 6 }
func (v *JoinGroupRequest) IsGroupCoordinatorRequest() {}
func (v *JoinGroupRequest) ResponseKind() Response     { return &JoinGroupResponse{Version: v.Version} }

func (v *JoinGroupRequest) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	isFlexible := version >= 6
	_ = isFlexible
	{
		v := v.Group
		if isFlexible {
			dst = kbin.AppendCompactString(dst, v)
		} else {
			dst = kbin.AppendString(dst, v)
		}
	}
	{
		v := v.SessionTimeoutMillis
		dst = kbin.AppendInt32(dst, v)
	}
	if version >= 1 {
		v := v.RebalanceTimeoutMillis
		dst = kbin.AppendInt32(dst, v)
	}
	{
		v := v.MemberID
		if isFlexible {
			dst = kbin.AppendCompactString(dst, v)
		} else {
			dst = kbin.AppendString(dst, v)
		}
	}
	if version >= 5 {
		v := v.InstanceID
		if isFlexible {
			dst = kbin.AppendCompactNullableString(dst, v)
		} else {
			dst = kbin.AppendNullableString(dst, v)
		}
	}
	{
		v := v.ProtocolType
		if isFlexible {
			dst = kbin.AppendCompactString(dst, v)
		} else {
			dst = kbin.AppendString(dst, v)
		}
	}
	{
		v := v.Protocols
		if isFlexible {
			dst = kbin.AppendCompactArrayLen(dst, len(v))
		} else {
			dst = kbin.AppendArrayLen(dst, len(v))
		}
		for i := range v {
			v := &v[i]
			{
				v := v.Name
				if isFlexible {
					dst = kbin.AppendCompactString(dst, v)
				} else {
					dst = kbin.AppendString(dst, v)
				}
			}
			{
				v := v.Metadata
				if isFlexible {
					dst = kbin.AppendCompactBytes(dst, v)
				} else {
					dst = kbin.AppendBytes(dst, v)
				}
			}
			if isFlexible {
				dst = kbin.AppendUvarint(dst, 0)
			}
		}
	}
	if isFlexible {
		dst = kbin.AppendUvarint(dst, 0)
	}
	return dst
}
func (v *JoinGroupRequest) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	isFlexible := version >= 6
	_ = isFlexible
	b := kbin.Reader{Src: src}
	s := v
	{
		var v string
		if isFlexible {
			v = b.CompactString()
		} else {
			v = b.String()
		}
		s.Group = v
	}
	{
		v := b.Int32()
		s.SessionTimeoutMillis = v
	}
	if version >= 1 {
		v := b.Int32()
		s.RebalanceTimeoutMillis = v
	}
	{
		var v string
		if isFlexible {
			v = b.CompactString()
		} else {
			v = b.String()
		}
		s.MemberID = v
	}
	if version >= 5 {
		var v *string
		if isFlexible {
			v = b.CompactNullableString()
		} else {
			v = b.NullableString()
		}
		s.InstanceID = v
	}
	{
		var v string
		if isFlexible {
			v = b.CompactString()
		} else {
			v = b.String()
		}
		s.ProtocolType = v
	}
	{
		v := s.Protocols
		a := v
		var l int32
		if isFlexible {
			l = b.CompactArrayLen()
		} else {
			l = b.ArrayLen()
		}
		if !b.Ok() {
			return b.Complete()
		}
		if l > 0 {
			a = make([]JoinGroupRequestProtocol, l)
		}
		for i := int32(0); i < l; i++ {
			v := &a[i]
			s := v
			{
				var v string
				if isFlexible {
					v = b.CompactString()
				} else {
					v = b.String()
				}
				s.Name = v
			}
			{
				var v []byte
				if isFlexible {
					v = b.CompactBytes()
				} else {
					v = b.Bytes()
				}
				s.Metadata = v
			}
			if isFlexible {
				SkipTags(&b)
			}
		}
		v = a
		s.Protocols = v
	}
	if isFlexible {
		SkipTags(&b)
	}
	return b.Complete()
}

type JoinGroupResponseMember struct {
	// MemberID is a member in this group.
	MemberID string

	// InstanceID is an instance ID of a member in this group (KIP-345).
	InstanceID *string // v5+

	// ProtocolMetadata is the metadata for this member for this protocol.
	// This is usually of type GroupMemberMetadata.
	ProtocolMetadata []byte
}

// JoinGroupResponse is returned from a JoinGroupRequest.
type JoinGroupResponse struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	// ThrottleMillis is how long of a throttle Kafka will apply to the client
	// after this request.
	// For Kafka < 2.0.0, the throttle is applied before issuing a response.
	// For Kafka >= 2.0.0, the throttle is applied after issuing a response.
	ThrottleMillis int32 // v2+

	// ErrorCode is the error for the join group request.
	//
	// GROUP_AUTHORIZATION_FAILED is returned if the client is not authorized
	// to the group (no read perms).
	//
	// INVALID_GROUP_ID is returned in the requested group ID is invalid.
	//
	// COORDINATOR_NOT_AVAILABLE is returned if the coordinator is not available
	// (due to the requested broker shutting down or it has not completed startup).
	//
	// COORDINATOR_LOAD_IN_PROGRESS is returned if the group is loading.
	//
	// NOT_COORDINATOR is returned if the requested broker is not the coordinator
	// for the requested group.
	//
	// INVALID_SESSION_TIMEOUT is returned if the requested SessionTimeout is
	// not within the broker's group.{min,max}.session.timeout.ms.
	//
	// INCONSISTENT_GROUP_PROTOCOL is returned if the requested protocols are
	// incompatible with the existing group member's protocols, or if the join
	// was for a new group but contained no protocols.
	//
	// UNKNOWN_MEMBER_ID is returned is the requested group is dead (likely
	// just migrated to another coordinator or the group is temporarily unstable),
	// or if the request was for a new group but contained a non-empty member ID,
	// or if the group does not have the requested member ID (and the client must
	// do the new-join-group dance).
	//
	// MEMBER_ID_REQUIRED is returned on the initial join of an existing group.
	// This error was proposed in KIP-394 and introduced in Kafka 2.2.0 to
	// prevent flaky clients from continually triggering rebalances and prevent
	// these clients from consuming RAM with metadata. If a client sees
	// this error, it should re-issue the join with the MemberID in the response.
	// Non-flaky clients will join with this new member ID, but flaky clients
	// will not join quickly enough before the pending member ID is rotated out
	// due to hitting the session.timeout.ms.
	//
	// GROUP_MAX_SIZE_REACHED is returned as of Kafka 2.2.0 if the group has
	// reached a broker's group.max.size.
	ErrorCode int16

	// Generation is the current "generation" of this group.
	Generation int32

	// ProtocolType is the "type" of protocol being used for this group.
	ProtocolType *string // v7+

	// Protocol is the agreed upon protocol name (i.e. "sticky", "range").
	//
	// v7 of this response changed this field to be nullable.
	Protocol *string

	// LeaderID is the leader member.
	LeaderID string

	// MemberID is the member of the receiving client.
	MemberID string

	// Members contains all other members of this group. Only the group leader
	// receives the members. The leader is responsible for balancing subscribed
	// topic partitions and replying appropriately in a SyncGroup request.
	Members []JoinGroupResponseMember
}

func (*JoinGroupResponse) Key() int16                 { return 11 }
func (*JoinGroupResponse) MaxVersion() int16          { return 7 }
func (v *JoinGroupResponse) SetVersion(version int16) { v.Version = version }
func (v *JoinGroupResponse) GetVersion() int16        { return v.Version }
func (v *JoinGroupResponse) IsFlexible() bool         { return v.Version >= 6 }
func (v *JoinGroupResponse) RequestKind() Request     { return &JoinGroupRequest{Version: v.Version} }

func (v *JoinGroupResponse) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	isFlexible := version >= 6
	_ = isFlexible
	if version >= 2 {
		v := v.ThrottleMillis
		dst = kbin.AppendInt32(dst, v)
	}
	{
		v := v.ErrorCode
		dst = kbin.AppendInt16(dst, v)
	}
	{
		v := v.Generation
		dst = kbin.AppendInt32(dst, v)
	}
	if version >= 7 {
		v := v.ProtocolType
		if isFlexible {
			dst = kbin.AppendCompactNullableString(dst, v)
		} else {
			dst = kbin.AppendNullableString(dst, v)
		}
	}
	{
		v := v.Protocol
		if version < 7 {
			var vv string
			if v != nil {
				vv = *v
			}
			{
				v := vv
				if isFlexible {
					dst = kbin.AppendCompactString(dst, v)
				} else {
					dst = kbin.AppendString(dst, v)
				}
			}
		} else {
			if isFlexible {
				dst = kbin.AppendCompactNullableString(dst, v)
			} else {
				dst = kbin.AppendNullableString(dst, v)
			}
		}
	}
	{
		v := v.LeaderID
		if isFlexible {
			dst = kbin.AppendCompactString(dst, v)
		} else {
			dst = kbin.AppendString(dst, v)
		}
	}
	{
		v := v.MemberID
		if isFlexible {
			dst = kbin.AppendCompactString(dst, v)
		} else {
			dst = kbin.AppendString(dst, v)
		}
	}
	{
		v := v.Members
		if isFlexible {
			dst = kbin.AppendCompactArrayLen(dst, len(v))
		} else {
			dst = kbin.AppendArrayLen(dst, len(v))
		}
		for i := range v {
			v := &v[i]
			{
				v := v.MemberID
				if isFlexible {
					dst = kbin.AppendCompactString(dst, v)
				} else {
					dst = kbin.AppendString(dst, v)
				}
			}
			if version >= 5 {
				v := v.InstanceID
				if isFlexible {
					dst = kbin.AppendCompactNullableString(dst, v)
				} else {
					dst = kbin.AppendNullableString(dst, v)
				}
			}
			{
				v := v.ProtocolMetadata
				if isFlexible {
					dst = kbin.AppendCompactBytes(dst, v)
				} else {
					dst = kbin.AppendBytes(dst, v)
				}
			}
			if isFlexible {
				dst = kbin.AppendUvarint(dst, 0)
			}
		}
	}
	if isFlexible {
		dst = kbin.AppendUvarint(dst, 0)
	}
	return dst
}
func (v *JoinGroupResponse) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	isFlexible := version >= 6
	_ = isFlexible
	b := kbin.Reader{Src: src}
	s := v
	if version >= 2 {
		v := b.Int32()
		s.ThrottleMillis = v
	}
	{
		v := b.Int16()
		s.ErrorCode = v
	}
	{
		v := b.Int32()
		s.Generation = v
	}
	if version >= 7 {
		var v *string
		if isFlexible {
			v = b.CompactNullableString()
		} else {
			v = b.NullableString()
		}
		s.ProtocolType = v
	}
	{
		var v *string
		if version < 7 {
			var vv string
			if isFlexible {
				vv = b.CompactString()
			} else {
				vv = b.String()
			}
			v = &vv
		} else {
			if isFlexible {
				v = b.CompactNullableString()
			} else {
				v = b.NullableString()
			}
		}
		s.Protocol = v
	}
	{
		var v string
		if isFlexible {
			v = b.CompactString()
		} else {
			v = b.String()
		}
		s.LeaderID = v
	}
	{
		var v string
		if isFlexible {
			v = b.CompactString()
		} else {
			v = b.String()
		}
		s.MemberID = v
	}
	{
		v := s.Members
		a := v
		var l int32
		if isFlexible {
			l = b.CompactArrayLen()
		} else {
			l = b.ArrayLen()
		}
		if !b.Ok() {
			return b.Complete()
		}
		if l > 0 {
			a = make([]JoinGroupResponseMember, l)
		}
		for i := int32(0); i < l; i++ {
			v := &a[i]
			s := v
			{
				var v string
				if isFlexible {
					v = b.CompactString()
				} else {
					v = b.String()
				}
				s.MemberID = v
			}
			if version >= 5 {
				var v *string
				if isFlexible {
					v = b.CompactNullableString()
				} else {
					v = b.NullableString()
				}
				s.InstanceID = v
			}
			{
				var v []byte
				if isFlexible {
					v = b.CompactBytes()
				} else {
					v = b.Bytes()
				}
				s.ProtocolMetadata = v
			}
			if isFlexible {
				SkipTags(&b)
			}
		}
		v = a
		s.Members = v
	}
	if isFlexible {
		SkipTags(&b)
	}
	return b.Complete()
}

// HeartbeatRequest issues a heartbeat for a member in a group, ensuring that
// Kafka does not expire the member from the group.
type HeartbeatRequest struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	// Group is the group ID this heartbeat is for.
	Group string

	// Generation is the group generation this heartbeat is for.
	Generation int32

	// MemberID is the member ID this member is for.
	MemberID string

	// InstanceID is the instance ID of this member in the group (KIP-345).
	InstanceID *string // v3+
}

func (*HeartbeatRequest) Key() int16                   { return 12 }
func (*HeartbeatRequest) MaxVersion() int16            { return 4 }
func (v *HeartbeatRequest) SetVersion(version int16)   { v.Version = version }
func (v *HeartbeatRequest) GetVersion() int16          { return v.Version }
func (v *HeartbeatRequest) IsFlexible() bool           { return v.Version >= 4 }
func (v *HeartbeatRequest) IsGroupCoordinatorRequest() {}
func (v *HeartbeatRequest) ResponseKind() Response     { return &HeartbeatResponse{Version: v.Version} }

func (v *HeartbeatRequest) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	isFlexible := version >= 4
	_ = isFlexible
	{
		v := v.Group
		if isFlexible {
			dst = kbin.AppendCompactString(dst, v)
		} else {
			dst = kbin.AppendString(dst, v)
		}
	}
	{
		v := v.Generation
		dst = kbin.AppendInt32(dst, v)
	}
	{
		v := v.MemberID
		if isFlexible {
			dst = kbin.AppendCompactString(dst, v)
		} else {
			dst = kbin.AppendString(dst, v)
		}
	}
	if version >= 3 {
		v := v.InstanceID
		if isFlexible {
			dst = kbin.AppendCompactNullableString(dst, v)
		} else {
			dst = kbin.AppendNullableString(dst, v)
		}
	}
	if isFlexible {
		dst = kbin.AppendUvarint(dst, 0)
	}
	return dst
}
func (v *HeartbeatRequest) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	isFlexible := version >= 4
	_ = isFlexible
	b := kbin.Reader{Src: src}
	s := v
	{
		var v string
		if isFlexible {
			v = b.CompactString()
		} else {
			v = b.String()
		}
		s.Group = v
	}
	{
		v := b.Int32()
		s.Generation = v
	}
	{
		var v string
		if isFlexible {
			v = b.CompactString()
		} else {
			v = b.String()
		}
		s.MemberID = v
	}
	if version >= 3 {
		var v *string
		if isFlexible {
			v = b.CompactNullableString()
		} else {
			v = b.NullableString()
		}
		s.InstanceID = v
	}
	if isFlexible {
		SkipTags(&b)
	}
	return b.Complete()
}

// HeartbeatResponse is returned from a HeartbeatRequest.
type HeartbeatResponse struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	// ThrottleMillis is how long of a throttle Kafka will apply to the client
	// after this request.
	// For Kafka < 2.0.0, the throttle is applied before issuing a response.
	// For Kafka >= 2.0.0, the throttle is applied after issuing a response.
	ThrottleMillis int32 // v1+

	// ErrorCode is the error for the heartbeat request.
	//
	// GROUP_AUTHORIZATION_FAILED is returned if the client is not authorized
	// to the group (no read perms).
	//
	// INVALID_GROUP_ID is returned in the requested group ID is invalid.
	//
	// COORDINATOR_NOT_AVAILABLE is returned if the coordinator is not available
	// (due to the requested broker shutting down or it has not completed startup).
	//
	// NOT_COORDINATOR is returned if the requested broker is not the coordinator
	// for the requested group.
	//
	// UNKNOWN_MEMBER_ID is returned if the member ID is not a part of the group,
	// or if the group is empty or dead.
	//
	// ILLEGAL_GENERATION is returned if the request's generation ID is invalid.
	//
	// REBALANCE_IN_PROGRESS is returned if the group is currently rebalancing.
	ErrorCode int16
}

func (*HeartbeatResponse) Key() int16                 { return 12 }
func (*HeartbeatResponse) MaxVersion() int16          { return 4 }
func (v *HeartbeatResponse) SetVersion(version int16) { v.Version = version }
func (v *HeartbeatResponse) GetVersion() int16        { return v.Version }
func (v *HeartbeatResponse) IsFlexible() bool         { return v.Version >= 4 }
func (v *HeartbeatResponse) RequestKind() Request     { return &HeartbeatRequest{Version: v.Version} }

func (v *HeartbeatResponse) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	isFlexible := version >= 4
	_ = isFlexible
	if version >= 1 {
		v := v.ThrottleMillis
		dst = kbin.AppendInt32(dst, v)
	}
	{
		v := v.ErrorCode
		dst = kbin.AppendInt16(dst, v)
	}
	if isFlexible {
		dst = kbin.AppendUvarint(dst, 0)
	}
	return dst
}
func (v *HeartbeatResponse) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	isFlexible := version >= 4
	_ = isFlexible
	b := kbin.Reader{Src: src}
	s := v
	if version >= 1 {
		v := b.Int32()
		s.ThrottleMillis = v
	}
	{
		v := b.Int16()
		s.ErrorCode = v
	}
	if isFlexible {
		SkipTags(&b)
	}
	return b.Complete()
}

type LeaveGroupRequestMember struct {
	MemberID string

	InstanceID *string
}

// LeaveGroupRequest issues a request for a group member to leave the group,
// triggering a group rebalance.
//
// Version 3 changed removed MemberID and added a batch instance+member ID
// way of leaving a group.
type LeaveGroupRequest struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	// Group is the group to leave.
	Group string

	// MemberID is the member that is leaving.
	MemberID string

	// Members are member and group instance IDs to cause to leave a group.
	Members []LeaveGroupRequestMember // v3+
}

func (*LeaveGroupRequest) Key() int16                   { return 13 }
func (*LeaveGroupRequest) MaxVersion() int16            { return 4 }
func (v *LeaveGroupRequest) SetVersion(version int16)   { v.Version = version }
func (v *LeaveGroupRequest) GetVersion() int16          { return v.Version }
func (v *LeaveGroupRequest) IsFlexible() bool           { return v.Version >= 4 }
func (v *LeaveGroupRequest) IsGroupCoordinatorRequest() {}
func (v *LeaveGroupRequest) ResponseKind() Response     { return &LeaveGroupResponse{Version: v.Version} }

func (v *LeaveGroupRequest) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	isFlexible := version >= 4
	_ = isFlexible
	{
		v := v.Group
		if isFlexible {
			dst = kbin.AppendCompactString(dst, v)
		} else {
			dst = kbin.AppendString(dst, v)
		}
	}
	if version >= 0 && version <= 2 {
		v := v.MemberID
		if isFlexible {
			dst = kbin.AppendCompactString(dst, v)
		} else {
			dst = kbin.AppendString(dst, v)
		}
	}
	if version >= 3 {
		v := v.Members
		if isFlexible {
			dst = kbin.AppendCompactArrayLen(dst, len(v))
		} else {
			dst = kbin.AppendArrayLen(dst, len(v))
		}
		for i := range v {
			v := &v[i]
			{
				v := v.MemberID
				if isFlexible {
					dst = kbin.AppendCompactString(dst, v)
				} else {
					dst = kbin.AppendString(dst, v)
				}
			}
			{
				v := v.InstanceID
				if isFlexible {
					dst = kbin.AppendCompactNullableString(dst, v)
				} else {
					dst = kbin.AppendNullableString(dst, v)
				}
			}
			if isFlexible {
				dst = kbin.AppendUvarint(dst, 0)
			}
		}
	}
	if isFlexible {
		dst = kbin.AppendUvarint(dst, 0)
	}
	return dst
}
func (v *LeaveGroupRequest) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	isFlexible := version >= 4
	_ = isFlexible
	b := kbin.Reader{Src: src}
	s := v
	{
		var v string
		if isFlexible {
			v = b.CompactString()
		} else {
			v = b.String()
		}
		s.Group = v
	}
	if version >= 0 && version <= 2 {
		var v string
		if isFlexible {
			v = b.CompactString()
		} else {
			v = b.String()
		}
		s.MemberID = v
	}
	if version >= 3 {
		v := s.Members
		a := v
		var l int32
		if isFlexible {
			l = b.CompactArrayLen()
		} else {
			l = b.ArrayLen()
		}
		if !b.Ok() {
			return b.Complete()
		}
		if l > 0 {
			a = make([]LeaveGroupRequestMember, l)
		}
		for i := int32(0); i < l; i++ {
			v := &a[i]
			s := v
			{
				var v string
				if isFlexible {
					v = b.CompactString()
				} else {
					v = b.String()
				}
				s.MemberID = v
			}
			{
				var v *string
				if isFlexible {
					v = b.CompactNullableString()
				} else {
					v = b.NullableString()
				}
				s.InstanceID = v
			}
			if isFlexible {
				SkipTags(&b)
			}
		}
		v = a
		s.Members = v
	}
	if isFlexible {
		SkipTags(&b)
	}
	return b.Complete()
}

type LeaveGroupResponseMember struct {
	MemberID string

	InstanceID *string

	// An individual member's leave error code.
	ErrorCode int16
}

// LeaveGroupResponse is returned from a LeaveGroupRequest.
type LeaveGroupResponse struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	// ThrottleMillis is how long of a throttle Kafka will apply to the client
	// after this request.
	// For Kafka < 2.0.0, the throttle is applied before issuing a response.
	// For Kafka >= 2.0.0, the throttle is applied after issuing a response.
	ThrottleMillis int32 // v1+

	// ErrorCode is the error for the leave group request.
	//
	// GROUP_AUTHORIZATION_FAILED is returned if the client is not authorized
	// to the group (no read perms).
	//
	// INVALID_GROUP_ID is returned in the requested group ID is invalid.
	//
	// COORDINATOR_NOT_AVAILABLE is returned if the coordinator is not available
	// (due to the requested broker shutting down or it has not completed startup).
	//
	// COORDINATOR_LOAD_IN_PROGRESS is returned if the group is loading.
	//
	// NOT_COORDINATOR is returned if the requested broker is not the coordinator
	// for the requested group.
	//
	// UNKNOWN_MEMBER_ID is returned if the member ID is not a part of the group,
	// or if the group is empty or dead.
	ErrorCode int16

	// Members are the list of members and group instance IDs that left the group.
	Members []LeaveGroupResponseMember // v3+
}

func (*LeaveGroupResponse) Key() int16                 { return 13 }
func (*LeaveGroupResponse) MaxVersion() int16          { return 4 }
func (v *LeaveGroupResponse) SetVersion(version int16) { v.Version = version }
func (v *LeaveGroupResponse) GetVersion() int16        { return v.Version }
func (v *LeaveGroupResponse) IsFlexible() bool         { return v.Version >= 4 }
func (v *LeaveGroupResponse) RequestKind() Request     { return &LeaveGroupRequest{Version: v.Version} }

func (v *LeaveGroupResponse) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	isFlexible := version >= 4
	_ = isFlexible
	if version >= 1 {
		v := v.ThrottleMillis
		dst = kbin.AppendInt32(dst, v)
	}
	{
		v := v.ErrorCode
		dst = kbin.AppendInt16(dst, v)
	}
	if version >= 3 {
		v := v.Members
		if isFlexible {
			dst = kbin.AppendCompactArrayLen(dst, len(v))
		} else {
			dst = kbin.AppendArrayLen(dst, len(v))
		}
		for i := range v {
			v := &v[i]
			{
				v := v.MemberID
				if isFlexible {
					dst = kbin.AppendCompactString(dst, v)
				} else {
					dst = kbin.AppendString(dst, v)
				}
			}
			{
				v := v.InstanceID
				if isFlexible {
					dst = kbin.AppendCompactNullableString(dst, v)
				} else {
					dst = kbin.AppendNullableString(dst, v)
				}
			}
			{
				v := v.ErrorCode
				dst = kbin.AppendInt16(dst, v)
			}
			if isFlexible {
				dst = kbin.AppendUvarint(dst, 0)
			}
		}
	}
	if isFlexible {
		dst = kbin.AppendUvarint(dst, 0)
	}
	return dst
}
func (v *LeaveGroupResponse) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	isFlexible := version >= 4
	_ = isFlexible
	b := kbin.Reader{Src: src}
	s := v
	if version >= 1 {
		v := b.Int32()
		s.ThrottleMillis = v
	}
	{
		v := b.Int16()
		s.ErrorCode = v
	}
	if version >= 3 {
		v := s.Members
		a := v
		var l int32
		if isFlexible {
			l = b.CompactArrayLen()
		} else {
			l = b.ArrayLen()
		}
		if !b.Ok() {
			return b.Complete()
		}
		if l > 0 {
			a = make([]LeaveGroupResponseMember, l)
		}
		for i := int32(0); i < l; i++ {
			v := &a[i]
			s := v
			{
				var v string
				if isFlexible {
					v = b.CompactString()
				} else {
					v = b.String()
				}
				s.MemberID = v
			}
			{
				var v *string
				if isFlexible {
					v = b.CompactNullableString()
				} else {
					v = b.NullableString()
				}
				s.InstanceID = v
			}
			{
				v := b.Int16()
				s.ErrorCode = v
			}
			if isFlexible {
				SkipTags(&b)
			}
		}
		v = a
		s.Members = v
	}
	if isFlexible {
		SkipTags(&b)
	}
	return b.Complete()
}

type SyncGroupRequestGroupAssignment struct {
	// MemberID is the member this assignment is for.
	MemberID string

	// MemberAssignment is the assignment for this member. This is typically
	// of type GroupMemberAssignment.
	MemberAssignment []byte
}

// SyncGroupRequest is issued by all group members after they receive a a
// response for JoinGroup. The group leader is responsible for sending member
// assignments with the request; all other members do not.
//
// Once the leader sends the group assignment, all members will be replied to.
type SyncGroupRequest struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	// Group is the group ID this sync group is for.
	Group string

	// Generation is the group generation this sync is for.
	Generation int32

	// MemberID is the member ID this member is.
	MemberID string

	// InstanceID is the instance ID of this member in the group (KIP-345).
	InstanceID *string // v3+

	// ProtocolType is the "type" of protocol being used for this group.
	ProtocolType *string // v5+

	// Protocol is the agreed upon protocol name (i.e. "sticky", "range").
	Protocol *string // v5+

	// GroupAssignment, sent only from the group leader, is the topic partition
	// assignment it has decided on for all members.
	GroupAssignment []SyncGroupRequestGroupAssignment
}

func (*SyncGroupRequest) Key() int16                   { return 14 }
func (*SyncGroupRequest) MaxVersion() int16            { return 5 }
func (v *SyncGroupRequest) SetVersion(version int16)   { v.Version = version }
func (v *SyncGroupRequest) GetVersion() int16          { return v.Version }
func (v *SyncGroupRequest) IsFlexible() bool           { return v.Version >= 4 }
func (v *SyncGroupRequest) IsGroupCoordinatorRequest() {}
func (v *SyncGroupRequest) ResponseKind() Response     { return &SyncGroupResponse{Version: v.Version} }

func (v *SyncGroupRequest) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	isFlexible := version >= 4
	_ = isFlexible
	{
		v := v.Group
		if isFlexible {
			dst = kbin.AppendCompactString(dst, v)
		} else {
			dst = kbin.AppendString(dst, v)
		}
	}
	{
		v := v.Generation
		dst = kbin.AppendInt32(dst, v)
	}
	{
		v := v.MemberID
		if isFlexible {
			dst = kbin.AppendCompactString(dst, v)
		} else {
			dst = kbin.AppendString(dst, v)
		}
	}
	if version >= 3 {
		v := v.InstanceID
		if isFlexible {
			dst = kbin.AppendCompactNullableString(dst, v)
		} else {
			dst = kbin.AppendNullableString(dst, v)
		}
	}
	if version >= 5 {
		v := v.ProtocolType
		if isFlexible {
			dst = kbin.AppendCompactNullableString(dst, v)
		} else {
			dst = kbin.AppendNullableString(dst, v)
		}
	}
	if version >= 5 {
		v := v.Protocol
		if isFlexible {
			dst = kbin.AppendCompactNullableString(dst, v)
		} else {
			dst = kbin.AppendNullableString(dst, v)
		}
	}
	{
		v := v.GroupAssignment
		if isFlexible {
			dst = kbin.AppendCompactArrayLen(dst, len(v))
		} else {
			dst = kbin.AppendArrayLen(dst, len(v))
		}
		for i := range v {
			v := &v[i]
			{
				v := v.MemberID
				if isFlexible {
					dst = kbin.AppendCompactString(dst, v)
				} else {
					dst = kbin.AppendString(dst, v)
				}
			}
			{
				v := v.MemberAssignment
				if isFlexible {
					dst = kbin.AppendCompactBytes(dst, v)
				} else {
					dst = kbin.AppendBytes(dst, v)
				}
			}
			if isFlexible {
				dst = kbin.AppendUvarint(dst, 0)
			}
		}
	}
	if isFlexible {
		dst = kbin.AppendUvarint(dst, 0)
	}
	return dst
}
func (v *SyncGroupRequest) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	isFlexible := version >= 4
	_ = isFlexible
	b := kbin.Reader{Src: src}
	s := v
	{
		var v string
		if isFlexible {
			v = b.CompactString()
		} else {
			v = b.String()
		}
		s.Group = v
	}
	{
		v := b.Int32()
		s.Generation = v
	}
	{
		var v string
		if isFlexible {
			v = b.CompactString()
		} else {
			v = b.String()
		}
		s.MemberID = v
	}
	if version >= 3 {
		var v *string
		if isFlexible {
			v = b.CompactNullableString()
		} else {
			v = b.NullableString()
		}
		s.InstanceID = v
	}
	if version >= 5 {
		var v *string
		if isFlexible {
			v = b.CompactNullableString()
		} else {
			v = b.NullableString()
		}
		s.ProtocolType = v
	}
	if version >= 5 {
		var v *string
		if isFlexible {
			v = b.CompactNullableString()
		} else {
			v = b.NullableString()
		}
		s.Protocol = v
	}
	{
		v := s.GroupAssignment
		a := v
		var l int32
		if isFlexible {
			l = b.CompactArrayLen()
		} else {
			l = b.ArrayLen()
		}
		if !b.Ok() {
			return b.Complete()
		}
		if l > 0 {
			a = make([]SyncGroupRequestGroupAssignment, l)
		}
		for i := int32(0); i < l; i++ {
			v := &a[i]
			s := v
			{
				var v string
				if isFlexible {
					v = b.CompactString()
				} else {
					v = b.String()
				}
				s.MemberID = v
			}
			{
				var v []byte
				if isFlexible {
					v = b.CompactBytes()
				} else {
					v = b.Bytes()
				}
				s.MemberAssignment = v
			}
			if isFlexible {
				SkipTags(&b)
			}
		}
		v = a
		s.GroupAssignment = v
	}
	if isFlexible {
		SkipTags(&b)
	}
	return b.Complete()
}

// SyncGroupResponse is returned from a SyncGroupRequest.
type SyncGroupResponse struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	// ThrottleMillis is how long of a throttle Kafka will apply to the client
	// after this request.
	// For Kafka < 2.0.0, the throttle is applied before issuing a response.
	// For Kafka >= 2.0.0, the throttle is applied after issuing a response.
	ThrottleMillis int32 // v1+

	// ErrorCode is the error for the sync group request.
	//
	// GROUP_AUTHORIZATION_FAILED is returned if the client is not authorized
	// to the group (no read perms).
	//
	// INVALID_GROUP_ID is returned in the requested group ID is invalid.
	//
	// COORDINATOR_NOT_AVAILABLE is returned if the coordinator is not available.
	//
	// NOT_COORDINATOR is returned if the requested broker is not the coordinator
	// for the requested group.
	//
	// UNKNOWN_MEMBER_ID is returned if the member ID is not a part of the group,
	// or if the group is empty or dead.
	//
	// ILLEGAL_GENERATION is returned if the request's generation ID is invalid.
	//
	// REBALANCE_IN_PROGRESS is returned if the group switched back to rebalancing.
	//
	// UNKNOWN_SERVER_ERROR is returned if the store of the group assignment
	// resulted in a too large message.
	ErrorCode int16

	// ProtocolType is the "type" of protocol being used for this group.
	ProtocolType *string // v5+

	// Protocol is the agreed upon protocol name (i.e. "sticky", "range").
	Protocol *string // v5+

	// MemberAssignment is the assignment for this member that the leader
	// determined.
	MemberAssignment []byte
}

func (*SyncGroupResponse) Key() int16                 { return 14 }
func (*SyncGroupResponse) MaxVersion() int16          { return 5 }
func (v *SyncGroupResponse) SetVersion(version int16) { v.Version = version }
func (v *SyncGroupResponse) GetVersion() int16        { return v.Version }
func (v *SyncGroupResponse) IsFlexible() bool         { return v.Version >= 4 }
func (v *SyncGroupResponse) RequestKind() Request     { return &SyncGroupRequest{Version: v.Version} }

func (v *SyncGroupResponse) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	isFlexible := version >= 4
	_ = isFlexible
	if version >= 1 {
		v := v.ThrottleMillis
		dst = kbin.AppendInt32(dst, v)
	}
	{
		v := v.ErrorCode
		dst = kbin.AppendInt16(dst, v)
	}
	if version >= 5 {
		v := v.ProtocolType
		if isFlexible {
			dst = kbin.AppendCompactNullableString(dst, v)
		} else {
			dst = kbin.AppendNullableString(dst, v)
		}
	}
	if version >= 5 {
		v := v.Protocol
		if isFlexible {
			dst = kbin.AppendCompactNullableString(dst, v)
		} else {
			dst = kbin.AppendNullableString(dst, v)
		}
	}
	{
		v := v.MemberAssignment
		if isFlexible {
			dst = kbin.AppendCompactBytes(dst, v)
		} else {
			dst = kbin.AppendBytes(dst, v)
		}
	}
	if isFlexible {
		dst = kbin.AppendUvarint(dst, 0)
	}
	return dst
}
func (v *SyncGroupResponse) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	isFlexible := version >= 4
	_ = isFlexible
	b := kbin.Reader{Src: src}
	s := v
	if version >= 1 {
		v := b.Int32()
		s.ThrottleMillis = v
	}
	{
		v := b.Int16()
		s.ErrorCode = v
	}
	if version >= 5 {
		var v *string
		if isFlexible {
			v = b.CompactNullableString()
		} else {
			v = b.NullableString()
		}
		s.ProtocolType = v
	}
	if version >= 5 {
		var v *string
		if isFlexible {
			v = b.CompactNullableString()
		} else {
			v = b.NullableString()
		}
		s.Protocol = v
	}
	{
		var v []byte
		if isFlexible {
			v = b.CompactBytes()
		} else {
			v = b.Bytes()
		}
		s.MemberAssignment = v
	}
	if isFlexible {
		SkipTags(&b)
	}
	return b.Complete()
}

// DescribeGroupsRequest requests metadata for group IDs.
type DescribeGroupsRequest struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	// Groups is an array of group IDs to request metadata for.
	// If this is empty, the response will include all groups.
	Groups []string

	// IncludeAuthorizedOperations, introduced in Kafka 2.3.0, specifies
	// whether to include a bitfield of AclOperations this client can perform
	// on the groups. See KIP-430 for more details.
	IncludeAuthorizedOperations bool
}

func (*DescribeGroupsRequest) Key() int16                   { return 15 }
func (*DescribeGroupsRequest) MaxVersion() int16            { return 5 }
func (v *DescribeGroupsRequest) SetVersion(version int16)   { v.Version = version }
func (v *DescribeGroupsRequest) GetVersion() int16          { return v.Version }
func (v *DescribeGroupsRequest) IsFlexible() bool           { return v.Version >= 5 }
func (v *DescribeGroupsRequest) IsGroupCoordinatorRequest() {}
func (v *DescribeGroupsRequest) ResponseKind() Response {
	return &DescribeGroupsResponse{Version: v.Version}
}

func (v *DescribeGroupsRequest) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	isFlexible := version >= 5
	_ = isFlexible
	{
		v := v.Groups
		if isFlexible {
			dst = kbin.AppendCompactArrayLen(dst, len(v))
		} else {
			dst = kbin.AppendArrayLen(dst, len(v))
		}
		for i := range v {
			v := v[i]
			if isFlexible {
				dst = kbin.AppendCompactString(dst, v)
			} else {
				dst = kbin.AppendString(dst, v)
			}
		}
	}
	{
		v := v.IncludeAuthorizedOperations
		dst = kbin.AppendBool(dst, v)
	}
	if isFlexible {
		dst = kbin.AppendUvarint(dst, 0)
	}
	return dst
}
func (v *DescribeGroupsRequest) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	isFlexible := version >= 5
	_ = isFlexible
	b := kbin.Reader{Src: src}
	s := v
	{
		v := s.Groups
		a := v
		var l int32
		if isFlexible {
			l = b.CompactArrayLen()
		} else {
			l = b.ArrayLen()
		}
		if !b.Ok() {
			return b.Complete()
		}
		if l > 0 {
			a = make([]string, l)
		}
		for i := int32(0); i < l; i++ {
			var v string
			if isFlexible {
				v = b.CompactString()
			} else {
				v = b.String()
			}
			a[i] = v
		}
		v = a
		s.Groups = v
	}
	{
		v := b.Bool()
		s.IncludeAuthorizedOperations = v
	}
	if isFlexible {
		SkipTags(&b)
	}
	return b.Complete()
}

type DescribeGroupsResponseGroupMember struct {
	// MemberID is the member ID of a member in this group.
	MemberID string

	// InstanceID is the instance ID of this member in the group (KIP-345).
	InstanceID *string // v4+

	// ClientID is the client ID used by this member.
	ClientID string

	// ClientHost is the host this client is running on.
	ClientHost string

	// ProtocolMetadata is the metadata this member included when joining
	// the group. If using normal (Java-like) consumers, this will be of
	// type GroupMemberMetadata.
	ProtocolMetadata []byte

	// MemberAssignment is the assignment for this member in the group.
	// If using normal (Java-like) consumers, this will be of type
	// GroupMemberAssignment.
	MemberAssignment []byte
}
type DescribeGroupsResponseGroup struct {
	// ErrorCode is the error code for an individual group in a request.
	//
	// GROUP_AUTHORIZATION_FAILED is returned if the client is not authorized
	// to describe a group.
	//
	// INVALID_GROUP_ID is returned if the requested group ID is invalid.
	//
	// COORDINATOR_NOT_AVAILABLE is returned if the coordinator for this
	// group is not yet active.
	//
	// COORDINATOR_LOAD_IN_PROGRESS is returned if the group is loading.
	//
	// NOT_COORDINATOR is returned if the requested broker is not the
	// coordinator for this group.
	ErrorCode int16

	// Group is the id of this group.
	Group string

	// State is the state this group is in.
	State string

	// ProtocolType is the "type" of protocol being used for this group.
	ProtocolType string

	// Protocol is the agreed upon protocol for all members in this group.
	Protocol string

	// Members contains members in this group.
	Members []DescribeGroupsResponseGroupMember

	// AuthorizedOperations is a bitfield containing which operations the
	// the client is allowed to perform on this group.
	// This is only returned if requested.
	AuthorizedOperations int32 // v3+
}

// DescribeGroupsResponse is returned from a DescribeGroupsRequest.
type DescribeGroupsResponse struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	// ThrottleMillis is how long of a throttle Kafka will apply to the client
	// after this request.
	// For Kafka < 2.0.0, the throttle is applied before issuing a response.
	// For Kafka >= 2.0.0, the throttle is applied after issuing a response.
	ThrottleMillis int32

	// Groups is an array of group metadata.
	Groups []DescribeGroupsResponseGroup
}

func (*DescribeGroupsResponse) Key() int16                 { return 15 }
func (*DescribeGroupsResponse) MaxVersion() int16          { return 5 }
func (v *DescribeGroupsResponse) SetVersion(version int16) { v.Version = version }
func (v *DescribeGroupsResponse) GetVersion() int16        { return v.Version }
func (v *DescribeGroupsResponse) IsFlexible() bool         { return v.Version >= 5 }
func (v *DescribeGroupsResponse) RequestKind() Request {
	return &DescribeGroupsRequest{Version: v.Version}
}

func (v *DescribeGroupsResponse) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	isFlexible := version >= 5
	_ = isFlexible
	{
		v := v.ThrottleMillis
		dst = kbin.AppendInt32(dst, v)
	}
	{
		v := v.Groups
		if isFlexible {
			dst = kbin.AppendCompactArrayLen(dst, len(v))
		} else {
			dst = kbin.AppendArrayLen(dst, len(v))
		}
		for i := range v {
			v := &v[i]
			{
				v := v.ErrorCode
				dst = kbin.AppendInt16(dst, v)
			}
			{
				v := v.Group
				if isFlexible {
					dst = kbin.AppendCompactString(dst, v)
				} else {
					dst = kbin.AppendString(dst, v)
				}
			}
			{
				v := v.State
				if isFlexible {
					dst = kbin.AppendCompactString(dst, v)
				} else {
					dst = kbin.AppendString(dst, v)
				}
			}
			{
				v := v.ProtocolType
				if isFlexible {
					dst = kbin.AppendCompactString(dst, v)
				} else {
					dst = kbin.AppendString(dst, v)
				}
			}
			{
				v := v.Protocol
				if isFlexible {
					dst = kbin.AppendCompactString(dst, v)
				} else {
					dst = kbin.AppendString(dst, v)
				}
			}
			{
				v := v.Members
				if isFlexible {
					dst = kbin.AppendCompactArrayLen(dst, len(v))
				} else {
					dst = kbin.AppendArrayLen(dst, len(v))
				}
				for i := range v {
					v := &v[i]
					{
						v := v.MemberID
						if isFlexible {
							dst = kbin.AppendCompactString(dst, v)
						} else {
							dst = kbin.AppendString(dst, v)
						}
					}
					if version >= 4 {
						v := v.InstanceID
						if isFlexible {
							dst = kbin.AppendCompactNullableString(dst, v)
						} else {
							dst = kbin.AppendNullableString(dst, v)
						}
					}
					{
						v := v.ClientID
						if isFlexible {
							dst = kbin.AppendCompactString(dst, v)
						} else {
							dst = kbin.AppendString(dst, v)
						}
					}
					{
						v := v.ClientHost
						if isFlexible {
							dst = kbin.AppendCompactString(dst, v)
						} else {
							dst = kbin.AppendString(dst, v)
						}
					}
					{
						v := v.ProtocolMetadata
						if isFlexible {
							dst = kbin.AppendCompactBytes(dst, v)
						} else {
							dst = kbin.AppendBytes(dst, v)
						}
					}
					{
						v := v.MemberAssignment
						if isFlexible {
							dst = kbin.AppendCompactBytes(dst, v)
						} else {
							dst = kbin.AppendBytes(dst, v)
						}
					}
					if isFlexible {
						dst = kbin.AppendUvarint(dst, 0)
					}
				}
			}
			if version >= 3 {
				v := v.AuthorizedOperations
				dst = kbin.AppendInt32(dst, v)
			}
			if isFlexible {
				dst = kbin.AppendUvarint(dst, 0)
			}
		}
	}
	if isFlexible {
		dst = kbin.AppendUvarint(dst, 0)
	}
	return dst
}
func (v *DescribeGroupsResponse) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	isFlexible := version >= 5
	_ = isFlexible
	b := kbin.Reader{Src: src}
	s := v
	{
		v := b.Int32()
		s.ThrottleMillis = v
	}
	{
		v := s.Groups
		a := v
		var l int32
		if isFlexible {
			l = b.CompactArrayLen()
		} else {
			l = b.ArrayLen()
		}
		if !b.Ok() {
			return b.Complete()
		}
		if l > 0 {
			a = make([]DescribeGroupsResponseGroup, l)
		}
		for i := int32(0); i < l; i++ {
			v := &a[i]
			s := v
			{
				v := b.Int16()
				s.ErrorCode = v
			}
			{
				var v string
				if isFlexible {
					v = b.CompactString()
				} else {
					v = b.String()
				}
				s.Group = v
			}
			{
				var v string
				if isFlexible {
					v = b.CompactString()
				} else {
					v = b.String()
				}
				s.State = v
			}
			{
				var v string
				if isFlexible {
					v = b.CompactString()
				} else {
					v = b.String()
				}
				s.ProtocolType = v
			}
			{
				var v string
				if isFlexible {
					v = b.CompactString()
				} else {
					v = b.String()
				}
				s.Protocol = v
			}
			{
				v := s.Members
				a := v
				var l int32
				if isFlexible {
					l = b.CompactArrayLen()
				} else {
					l = b.ArrayLen()
				}
				if !b.Ok() {
					return b.Complete()
				}
				if l > 0 {
					a = make([]DescribeGroupsResponseGroupMember, l)
				}
				for i := int32(0); i < l; i++ {
					v := &a[i]
					s := v
					{
						var v string
						if isFlexible {
							v = b.CompactString()
						} else {
							v = b.String()
						}
						s.MemberID = v
					}
					if version >= 4 {
						var v *string
						if isFlexible {
							v = b.CompactNullableString()
						} else {
							v = b.NullableString()
						}
						s.InstanceID = v
					}
					{
						var v string
						if isFlexible {
							v = b.CompactString()
						} else {
							v = b.String()
						}
						s.ClientID = v
					}
					{
						var v string
						if isFlexible {
							v = b.CompactString()
						} else {
							v = b.String()
						}
						s.ClientHost = v
					}
					{
						var v []byte
						if isFlexible {
							v = b.CompactBytes()
						} else {
							v = b.Bytes()
						}
						s.ProtocolMetadata = v
					}
					{
						var v []byte
						if isFlexible {
							v = b.CompactBytes()
						} else {
							v = b.Bytes()
						}
						s.MemberAssignment = v
					}
					if isFlexible {
						SkipTags(&b)
					}
				}
				v = a
				s.Members = v
			}
			if version >= 3 {
				v := b.Int32()
				s.AuthorizedOperations = v
			}
			if isFlexible {
				SkipTags(&b)
			}
		}
		v = a
		s.Groups = v
	}
	if isFlexible {
		SkipTags(&b)
	}
	return b.Complete()
}

// ListGroupsRequest issues a request to list all groups.
//
// To list all groups in a cluster, this must be issued to every broker.
type ListGroupsRequest struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	// StatesFilter, proposed in KIP-518 and introduced in Kafka 2.6.0,
	// allows filtering groups by state, where a state is any of
	// "Preparing", "PreparingRebalance", "CompletingRebalance", "Stable",
	// "Dead", or "Empty". If empty, all groups are returned.
	StatesFilter []string // v4+
}

func (*ListGroupsRequest) Key() int16                 { return 16 }
func (*ListGroupsRequest) MaxVersion() int16          { return 4 }
func (v *ListGroupsRequest) SetVersion(version int16) { v.Version = version }
func (v *ListGroupsRequest) GetVersion() int16        { return v.Version }
func (v *ListGroupsRequest) IsFlexible() bool         { return v.Version >= 3 }
func (v *ListGroupsRequest) ResponseKind() Response   { return &ListGroupsResponse{Version: v.Version} }

func (v *ListGroupsRequest) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	isFlexible := version >= 3
	_ = isFlexible
	if version >= 4 {
		v := v.StatesFilter
		if isFlexible {
			dst = kbin.AppendCompactArrayLen(dst, len(v))
		} else {
			dst = kbin.AppendArrayLen(dst, len(v))
		}
		for i := range v {
			v := v[i]
			if isFlexible {
				dst = kbin.AppendCompactString(dst, v)
			} else {
				dst = kbin.AppendString(dst, v)
			}
		}
	}
	if isFlexible {
		dst = kbin.AppendUvarint(dst, 0)
	}
	return dst
}
func (v *ListGroupsRequest) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	isFlexible := version >= 3
	_ = isFlexible
	b := kbin.Reader{Src: src}
	s := v
	if version >= 4 {
		v := s.StatesFilter
		a := v
		var l int32
		if isFlexible {
			l = b.CompactArrayLen()
		} else {
			l = b.ArrayLen()
		}
		if !b.Ok() {
			return b.Complete()
		}
		if l > 0 {
			a = make([]string, l)
		}
		for i := int32(0); i < l; i++ {
			var v string
			if isFlexible {
				v = b.CompactString()
			} else {
				v = b.String()
			}
			a[i] = v
		}
		v = a
		s.StatesFilter = v
	}
	if isFlexible {
		SkipTags(&b)
	}
	return b.Complete()
}

type ListGroupsResponseGroup struct {
	// Group is a Kafka group.
	Group string

	// ProtocolType is the protocol type in use by the group.
	ProtocolType string

	// The group state.
	GroupState string // v4+
}

// ListGroupsResponse is returned from a ListGroupsRequest.
type ListGroupsResponse struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	// ThrottleMillis is how long of a throttle Kafka will apply to the client
	// after this request.
	// For Kafka < 2.0.0, the throttle is applied before issuing a response.
	// For Kafka >= 2.0.0, the throttle is applied after issuing a response.
	ThrottleMillis int32 // v1+

	// ErrorCode is the error returned for the list groups request.
	//
	// COORDINATOR_NOT_AVAILABLE is returned if the coordinator is not yet active.
	//
	// COORDINATOR_LOAD_IN_PROGRESS is returned if the group manager is loading.
	ErrorCode int16

	// Groups is the list of groups Kafka knows of.
	Groups []ListGroupsResponseGroup
}

func (*ListGroupsResponse) Key() int16                 { return 16 }
func (*ListGroupsResponse) MaxVersion() int16          { return 4 }
func (v *ListGroupsResponse) SetVersion(version int16) { v.Version = version }
func (v *ListGroupsResponse) GetVersion() int16        { return v.Version }
func (v *ListGroupsResponse) IsFlexible() bool         { return v.Version >= 3 }
func (v *ListGroupsResponse) RequestKind() Request     { return &ListGroupsRequest{Version: v.Version} }

func (v *ListGroupsResponse) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	isFlexible := version >= 3
	_ = isFlexible
	if version >= 1 {
		v := v.ThrottleMillis
		dst = kbin.AppendInt32(dst, v)
	}
	{
		v := v.ErrorCode
		dst = kbin.AppendInt16(dst, v)
	}
	{
		v := v.Groups
		if isFlexible {
			dst = kbin.AppendCompactArrayLen(dst, len(v))
		} else {
			dst = kbin.AppendArrayLen(dst, len(v))
		}
		for i := range v {
			v := &v[i]
			{
				v := v.Group
				if isFlexible {
					dst = kbin.AppendCompactString(dst, v)
				} else {
					dst = kbin.AppendString(dst, v)
				}
			}
			{
				v := v.ProtocolType
				if isFlexible {
					dst = kbin.AppendCompactString(dst, v)
				} else {
					dst = kbin.AppendString(dst, v)
				}
			}
			if version >= 4 {
				v := v.GroupState
				if isFlexible {
					dst = kbin.AppendCompactString(dst, v)
				} else {
					dst = kbin.AppendString(dst, v)
				}
			}
			if isFlexible {
				dst = kbin.AppendUvarint(dst, 0)
			}
		}
	}
	if isFlexible {
		dst = kbin.AppendUvarint(dst, 0)
	}
	return dst
}
func (v *ListGroupsResponse) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	isFlexible := version >= 3
	_ = isFlexible
	b := kbin.Reader{Src: src}
	s := v
	if version >= 1 {
		v := b.Int32()
		s.ThrottleMillis = v
	}
	{
		v := b.Int16()
		s.ErrorCode = v
	}
	{
		v := s.Groups
		a := v
		var l int32
		if isFlexible {
			l = b.CompactArrayLen()
		} else {
			l = b.ArrayLen()
		}
		if !b.Ok() {
			return b.Complete()
		}
		if l > 0 {
			a = make([]ListGroupsResponseGroup, l)
		}
		for i := int32(0); i < l; i++ {
			v := &a[i]
			s := v
			{
				var v string
				if isFlexible {
					v = b.CompactString()
				} else {
					v = b.String()
				}
				s.Group = v
			}
			{
				var v string
				if isFlexible {
					v = b.CompactString()
				} else {
					v = b.String()
				}
				s.ProtocolType = v
			}
			if version >= 4 {
				var v string
				if isFlexible {
					v = b.CompactString()
				} else {
					v = b.String()
				}
				s.GroupState = v
			}
			if isFlexible {
				SkipTags(&b)
			}
		}
		v = a
		s.Groups = v
	}
	if isFlexible {
		SkipTags(&b)
	}
	return b.Complete()
}

// SASLHandshakeRequest begins the sasl authentication flow. Note that Kerberos
// GSSAPI authentication has its own unique flow.
type SASLHandshakeRequest struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	// Mechanism is the mechanism to use for the sasl handshake (e.g., "PLAIN").
	//
	// For version 0, if this mechanism is supported, it is expected that the
	// client immediately authenticates using this mechanism. Note that the
	// only mechanism exclusive to v0 is PLAIN.
	//
	// For version 1, if the mechanism is supported, the next request to issue
	// is SASLHandshakeRequest.
	Mechanism string
}

func (*SASLHandshakeRequest) Key() int16                 { return 17 }
func (*SASLHandshakeRequest) MaxVersion() int16          { return 1 }
func (v *SASLHandshakeRequest) SetVersion(version int16) { v.Version = version }
func (v *SASLHandshakeRequest) GetVersion() int16        { return v.Version }
func (v *SASLHandshakeRequest) IsFlexible() bool         { return false }
func (v *SASLHandshakeRequest) ResponseKind() Response {
	return &SASLHandshakeResponse{Version: v.Version}
}

func (v *SASLHandshakeRequest) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	{
		v := v.Mechanism
		dst = kbin.AppendString(dst, v)
	}
	return dst
}
func (v *SASLHandshakeRequest) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	b := kbin.Reader{Src: src}
	s := v
	{
		v := b.String()
		s.Mechanism = v
	}
	return b.Complete()
}

// SASLHandshakeResponse is returned for a SASLHandshakeRequest.
type SASLHandshakeResponse struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	// ErrorCode is non-zero for ILLEGAL_SASL_STATE, meaning a sasl handshake
	// is not expected at this point in the connection, or UNSUPPORTED_SASL_MECHANISM,
	// meaning the requested mechanism is not supported.
	ErrorCode int16

	// SupportedMechanisms is the list of mechanisms supported if this request
	// errored.
	SupportedMechanisms []string
}

func (*SASLHandshakeResponse) Key() int16                 { return 17 }
func (*SASLHandshakeResponse) MaxVersion() int16          { return 1 }
func (v *SASLHandshakeResponse) SetVersion(version int16) { v.Version = version }
func (v *SASLHandshakeResponse) GetVersion() int16        { return v.Version }
func (v *SASLHandshakeResponse) IsFlexible() bool         { return false }
func (v *SASLHandshakeResponse) RequestKind() Request {
	return &SASLHandshakeRequest{Version: v.Version}
}

func (v *SASLHandshakeResponse) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	{
		v := v.ErrorCode
		dst = kbin.AppendInt16(dst, v)
	}
	{
		v := v.SupportedMechanisms
		dst = kbin.AppendArrayLen(dst, len(v))
		for i := range v {
			v := v[i]
			dst = kbin.AppendString(dst, v)
		}
	}
	return dst
}
func (v *SASLHandshakeResponse) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	b := kbin.Reader{Src: src}
	s := v
	{
		v := b.Int16()
		s.ErrorCode = v
	}
	{
		v := s.SupportedMechanisms
		a := v
		var l int32
		l = b.ArrayLen()
		if !b.Ok() {
			return b.Complete()
		}
		if l > 0 {
			a = make([]string, l)
		}
		for i := int32(0); i < l; i++ {
			v := b.String()
			a[i] = v
		}
		v = a
		s.SupportedMechanisms = v
	}
	return b.Complete()
}

// ApiVersionsRequest requests what API versions a Kafka broker supports.
//
// Note that the client does not know the version a broker supports before
// sending this request.
//
// Before Kafka 2.4.0, if the client used a version larger than the broker
// understands, the broker would reply with an UNSUPPORTED_VERSION error using
// the version 0 message format (i.e., 6 bytes long!). The client should retry
// with a lower version.
//
// After Kafka 2.4.0, if the client uses a version larger than the broker
// understands, the broker replies with UNSUPPORTED_VERSIONS using the version
// 0 message format but additionally includes the api versions the broker does
// support.
type ApiVersionsRequest struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	// ClientSoftwareName, added for KIP-511 with Kafka 2.4.0, is the name of the
	// client issuing this request. The broker can use this to enrich its own
	// debugging information of which version of what clients are connected.
	//
	// If using v3, this field is required and must match the following pattern:
	//
	//     [a-zA-Z0-9](?:[a-zA-Z0-9\\-.]*[a-zA-Z0-9])?
	//
	ClientSoftwareName string // v3+

	// ClientSoftwareVersion is the version of the software name in the prior
	// field. It must match the same regex (thus, this is also required).
	ClientSoftwareVersion string // v3+
}

func (*ApiVersionsRequest) Key() int16                 { return 18 }
func (*ApiVersionsRequest) MaxVersion() int16          { return 3 }
func (v *ApiVersionsRequest) SetVersion(version int16) { v.Version = version }
func (v *ApiVersionsRequest) GetVersion() int16        { return v.Version }
func (v *ApiVersionsRequest) IsFlexible() bool         { return v.Version >= 3 }
func (v *ApiVersionsRequest) ResponseKind() Response   { return &ApiVersionsResponse{Version: v.Version} }

func (v *ApiVersionsRequest) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	isFlexible := version >= 3
	_ = isFlexible
	if version >= 3 {
		v := v.ClientSoftwareName
		if isFlexible {
			dst = kbin.AppendCompactString(dst, v)
		} else {
			dst = kbin.AppendString(dst, v)
		}
	}
	if version >= 3 {
		v := v.ClientSoftwareVersion
		if isFlexible {
			dst = kbin.AppendCompactString(dst, v)
		} else {
			dst = kbin.AppendString(dst, v)
		}
	}
	if isFlexible {
		dst = kbin.AppendUvarint(dst, 0)
	}
	return dst
}
func (v *ApiVersionsRequest) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	isFlexible := version >= 3
	_ = isFlexible
	b := kbin.Reader{Src: src}
	s := v
	if version >= 3 {
		var v string
		if isFlexible {
			v = b.CompactString()
		} else {
			v = b.String()
		}
		s.ClientSoftwareName = v
	}
	if version >= 3 {
		var v string
		if isFlexible {
			v = b.CompactString()
		} else {
			v = b.String()
		}
		s.ClientSoftwareVersion = v
	}
	if isFlexible {
		SkipTags(&b)
	}
	return b.Complete()
}

type ApiVersionsResponseApiKey struct {
	// ApiKey is the key of a message request.
	ApiKey int16

	// MinVersion is the min version a broker supports for an API key.
	MinVersion int16

	// MaxVersion is the max version a broker supports for an API key.
	MaxVersion int16
}

// ApiVersionsResponse is returned from an ApiVersionsRequest.
type ApiVersionsResponse struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	// ErrorCode is UNSUPPORTED_VERSION if the request was issued with a higher
	// version than the broker supports. Before Kafka 2.4.0, if this error is
	// returned, the rest of this struct will be empty.
	//
	// Starting in Kafka 2.4.0 (with version 3), even with an UNSUPPORTED_VERSION
	// error, the broker still replies with the ApiKeys it supports.
	ErrorCode int16

	// ApiKeys is an array corresponding to API keys the broker supports
	// and the range of supported versions for each key.
	ApiKeys []ApiVersionsResponseApiKey

	// ThrottleMillis is how long of a throttle Kafka will apply to the client
	// after this request.
	// For Kafka < 2.0.0, the throttle is applied before issuing a response.
	// For Kafka >= 2.0.0, the throttle is applied after issuing a response.
	ThrottleMillis int32 // v1+
}

func (*ApiVersionsResponse) Key() int16                 { return 18 }
func (*ApiVersionsResponse) MaxVersion() int16          { return 3 }
func (v *ApiVersionsResponse) SetVersion(version int16) { v.Version = version }
func (v *ApiVersionsResponse) GetVersion() int16        { return v.Version }
func (v *ApiVersionsResponse) IsFlexible() bool         { return v.Version >= 3 }
func (v *ApiVersionsResponse) RequestKind() Request     { return &ApiVersionsRequest{Version: v.Version} }

func (v *ApiVersionsResponse) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	isFlexible := version >= 3
	_ = isFlexible
	{
		v := v.ErrorCode
		dst = kbin.AppendInt16(dst, v)
	}
	{
		v := v.ApiKeys
		if isFlexible {
			dst = kbin.AppendCompactArrayLen(dst, len(v))
		} else {
			dst = kbin.AppendArrayLen(dst, len(v))
		}
		for i := range v {
			v := &v[i]
			{
				v := v.ApiKey
				dst = kbin.AppendInt16(dst, v)
			}
			{
				v := v.MinVersion
				dst = kbin.AppendInt16(dst, v)
			}
			{
				v := v.MaxVersion
				dst = kbin.AppendInt16(dst, v)
			}
			if isFlexible {
				dst = kbin.AppendUvarint(dst, 0)
			}
		}
	}
	if version >= 1 {
		v := v.ThrottleMillis
		dst = kbin.AppendInt32(dst, v)
	}
	if isFlexible {
		dst = kbin.AppendUvarint(dst, 0)
	}
	return dst
}
func (v *ApiVersionsResponse) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	isFlexible := version >= 3
	_ = isFlexible
	b := kbin.Reader{Src: src}
	s := v
	{
		v := b.Int16()
		s.ErrorCode = v
	}
	{
		v := s.ApiKeys
		a := v
		var l int32
		if isFlexible {
			l = b.CompactArrayLen()
		} else {
			l = b.ArrayLen()
		}
		if !b.Ok() {
			return b.Complete()
		}
		if l > 0 {
			a = make([]ApiVersionsResponseApiKey, l)
		}
		for i := int32(0); i < l; i++ {
			v := &a[i]
			s := v
			{
				v := b.Int16()
				s.ApiKey = v
			}
			{
				v := b.Int16()
				s.MinVersion = v
			}
			{
				v := b.Int16()
				s.MaxVersion = v
			}
			if isFlexible {
				SkipTags(&b)
			}
		}
		v = a
		s.ApiKeys = v
	}
	if version >= 1 {
		v := b.Int32()
		s.ThrottleMillis = v
	}
	if isFlexible {
		SkipTags(&b)
	}
	return b.Complete()
}

type CreateTopicsRequestTopicReplicaAssignment struct {
	// Partition is a partition to create.
	Partition int32

	// Replicas are broker IDs the partition must exist on.
	Replicas []int32
}
type CreateTopicsRequestTopicConfig struct {
	// Name is a topic level config key (e.g. segment.bytes).
	Name string

	// Value is a topic level config value (e.g. 1073741824)
	Value *string
}
type CreateTopicsRequestTopic struct {
	// Topic is a topic to create.
	Topic string

	// NumPartitions is how many partitions to give a topic. This must
	// be -1 if specifying partitions manually (see ReplicaAssignment)
	// or, starting v4+, to use the broker default partitions.
	NumPartitions int32

	// ReplicationFactor is how many replicas every partition must have.
	// This must be -1 if specifying partitions manually (see ReplicaAssignment)
	// or, starting v4+, to use the broker default replication factor.
	ReplicationFactor int16

	// ReplicaAssignment is an array to manually dicate replicas and their
	// partitions for a topic. If using this, both ReplicationFactor and
	// NumPartitions must be -1.
	ReplicaAssignment []CreateTopicsRequestTopicReplicaAssignment

	// Configs is an array of key value config pairs for a topic.
	// These correspond to Kafka Topic-Level Configs: http://kafka.apache.org/documentation/#topicconfigs.
	Configs []CreateTopicsRequestTopicConfig
}

// CreateTopicsRequest creates Kafka topics.
//
// Version 4, introduced in Kafka 2.4.0, implies client support for
// creation defaults. See KIP-464.
//
// Version 5, also in 2.4.0, returns topic configs in the response (KIP-525).
type CreateTopicsRequest struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	// Topics is an array of topics to attempt to create.
	Topics []CreateTopicsRequestTopic

	// TimeoutMillis is how long to allow for this request.
	TimeoutMillis int32

	// ValidateOnly is makes this request a dry-run; everything is validated but
	// no topics are actually created.
	ValidateOnly bool // v1+
}

func (*CreateTopicsRequest) Key() int16                 { return 19 }
func (*CreateTopicsRequest) MaxVersion() int16          { return 6 }
func (v *CreateTopicsRequest) SetVersion(version int16) { v.Version = version }
func (v *CreateTopicsRequest) GetVersion() int16        { return v.Version }
func (v *CreateTopicsRequest) IsFlexible() bool         { return v.Version >= 5 }
func (v *CreateTopicsRequest) IsAdminRequest()          {}
func (v *CreateTopicsRequest) ResponseKind() Response {
	return &CreateTopicsResponse{Version: v.Version}
}

func (v *CreateTopicsRequest) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	isFlexible := version >= 5
	_ = isFlexible
	{
		v := v.Topics
		if isFlexible {
			dst = kbin.AppendCompactArrayLen(dst, len(v))
		} else {
			dst = kbin.AppendArrayLen(dst, len(v))
		}
		for i := range v {
			v := &v[i]
			{
				v := v.Topic
				if isFlexible {
					dst = kbin.AppendCompactString(dst, v)
				} else {
					dst = kbin.AppendString(dst, v)
				}
			}
			{
				v := v.NumPartitions
				dst = kbin.AppendInt32(dst, v)
			}
			{
				v := v.ReplicationFactor
				dst = kbin.AppendInt16(dst, v)
			}
			{
				v := v.ReplicaAssignment
				if isFlexible {
					dst = kbin.AppendCompactArrayLen(dst, len(v))
				} else {
					dst = kbin.AppendArrayLen(dst, len(v))
				}
				for i := range v {
					v := &v[i]
					{
						v := v.Partition
						dst = kbin.AppendInt32(dst, v)
					}
					{
						v := v.Replicas
						if isFlexible {
							dst = kbin.AppendCompactArrayLen(dst, len(v))
						} else {
							dst = kbin.AppendArrayLen(dst, len(v))
						}
						for i := range v {
							v := v[i]
							dst = kbin.AppendInt32(dst, v)
						}
					}
					if isFlexible {
						dst = kbin.AppendUvarint(dst, 0)
					}
				}
			}
			{
				v := v.Configs
				if isFlexible {
					dst = kbin.AppendCompactArrayLen(dst, len(v))
				} else {
					dst = kbin.AppendArrayLen(dst, len(v))
				}
				for i := range v {
					v := &v[i]
					{
						v := v.Name
						if isFlexible {
							dst = kbin.AppendCompactString(dst, v)
						} else {
							dst = kbin.AppendString(dst, v)
						}
					}
					{
						v := v.Value
						if isFlexible {
							dst = kbin.AppendCompactNullableString(dst, v)
						} else {
							dst = kbin.AppendNullableString(dst, v)
						}
					}
					if isFlexible {
						dst = kbin.AppendUvarint(dst, 0)
					}
				}
			}
			if isFlexible {
				dst = kbin.AppendUvarint(dst, 0)
			}
		}
	}
	{
		v := v.TimeoutMillis
		dst = kbin.AppendInt32(dst, v)
	}
	if version >= 1 {
		v := v.ValidateOnly
		dst = kbin.AppendBool(dst, v)
	}
	if isFlexible {
		dst = kbin.AppendUvarint(dst, 0)
	}
	return dst
}
func (v *CreateTopicsRequest) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	isFlexible := version >= 5
	_ = isFlexible
	b := kbin.Reader{Src: src}
	s := v
	{
		v := s.Topics
		a := v
		var l int32
		if isFlexible {
			l = b.CompactArrayLen()
		} else {
			l = b.ArrayLen()
		}
		if !b.Ok() {
			return b.Complete()
		}
		if l > 0 {
			a = make([]CreateTopicsRequestTopic, l)
		}
		for i := int32(0); i < l; i++ {
			v := &a[i]
			s := v
			{
				var v string
				if isFlexible {
					v = b.CompactString()
				} else {
					v = b.String()
				}
				s.Topic = v
			}
			{
				v := b.Int32()
				s.NumPartitions = v
			}
			{
				v := b.Int16()
				s.ReplicationFactor = v
			}
			{
				v := s.ReplicaAssignment
				a := v
				var l int32
				if isFlexible {
					l = b.CompactArrayLen()
				} else {
					l = b.ArrayLen()
				}
				if !b.Ok() {
					return b.Complete()
				}
				if l > 0 {
					a = make([]CreateTopicsRequestTopicReplicaAssignment, l)
				}
				for i := int32(0); i < l; i++ {
					v := &a[i]
					s := v
					{
						v := b.Int32()
						s.Partition = v
					}
					{
						v := s.Replicas
						a := v
						var l int32
						if isFlexible {
							l = b.CompactArrayLen()
						} else {
							l = b.ArrayLen()
						}
						if !b.Ok() {
							return b.Complete()
						}
						if l > 0 {
							a = make([]int32, l)
						}
						for i := int32(0); i < l; i++ {
							v := b.Int32()
							a[i] = v
						}
						v = a
						s.Replicas = v
					}
					if isFlexible {
						SkipTags(&b)
					}
				}
				v = a
				s.ReplicaAssignment = v
			}
			{
				v := s.Configs
				a := v
				var l int32
				if isFlexible {
					l = b.CompactArrayLen()
				} else {
					l = b.ArrayLen()
				}
				if !b.Ok() {
					return b.Complete()
				}
				if l > 0 {
					a = make([]CreateTopicsRequestTopicConfig, l)
				}
				for i := int32(0); i < l; i++ {
					v := &a[i]
					s := v
					{
						var v string
						if isFlexible {
							v = b.CompactString()
						} else {
							v = b.String()
						}
						s.Name = v
					}
					{
						var v *string
						if isFlexible {
							v = b.CompactNullableString()
						} else {
							v = b.NullableString()
						}
						s.Value = v
					}
					if isFlexible {
						SkipTags(&b)
					}
				}
				v = a
				s.Configs = v
			}
			if isFlexible {
				SkipTags(&b)
			}
		}
		v = a
		s.Topics = v
	}
	{
		v := b.Int32()
		s.TimeoutMillis = v
	}
	if version >= 1 {
		v := b.Bool()
		s.ValidateOnly = v
	}
	if isFlexible {
		SkipTags(&b)
	}
	return b.Complete()
}

type CreateTopicsResponseTopicConfig struct {
	// Name is the configuration name (e.g. segment.bytes).
	Name string

	// Value is the value for this config key. If the key is sensitive,
	// the value will be null.
	Value *string

	// ReadOnly signifies whether this is not a dynamic config option.
	ReadOnly bool

	// Source is where this config entry is from. See the documentation
	// on DescribeConfigsRequest's Source for more details.
	Source int8

	// IsSensitive signifies whether this is a sensitive config key, which
	// is either a password or an unknown type.
	IsSensitive bool
}
type CreateTopicsResponseTopic struct {
	// Topic is the topic this response corresponds to.
	Topic string

	// ErrorCode is the error code for an individual topic creation.
	//
	// NOT_CONTROLLER is returned if the request was not issued to a Kafka
	// controller.
	//
	// TOPIC_AUTHORIZATION_FAILED is returned if the client is not authorized
	//
	// INVALID_REQUEST is returned if the same topic occurred multiple times
	// in the request.
	//
	// POLICY_VIOLATION is returned if the broker is using a
	// create.topic.policy.class.name that returns a policy violation.
	//
	// INVALID_TOPIC_EXCEPTION if the topic collides with another topic when
	// both topic's names' periods are replaced with underscores (e.g.
	// topic.foo and topic_foo collide).
	//
	// TOPIC_ALREADY_EXISTS is returned if the topic already exists.
	//
	// INVALID_PARTITIONS is returned if the requested number of partitions is
	// <= 0.
	//
	// INVALID_REPLICATION_FACTOR is returned if the requested replication
	// factor is <= 0.
	//
	// INVALID_REPLICA_ASSIGNMENT is returned if not all partitions have the same
	// number of replicas, or duplica replicas are assigned, or the partitions
	// are not consecutive starting from 0.
	//
	// INVALID_CONFIG is returned if the requested topic config is invalid.
	// to create a topic.
	ErrorCode int16

	// ErrorMessage is an informative message if the topic creation failed.
	ErrorMessage *string // v1+

	// ConfigErrorCode is non-zero if configs are unable to be returned.
	//
	// This is the first tagged field, introduced in version 5. As such, it is
	// only possible to be present in v5+.
	ConfigErrorCode int16 // tag 0

	// NumPartitions is how many partitions were created for this topic.
	NumPartitions int32 // v5+

	// ReplicationFactor is how many replicas every partition has for this topic.
	ReplicationFactor int16 // v5+

	// Configs contains this topic's configuration.
	Configs []CreateTopicsResponseTopicConfig // v5+
}

// CreateTopicsResponse is returned from a CreateTopicsRequest.
type CreateTopicsResponse struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	// ThrottleMillis is how long of a throttle Kafka will apply to the client
	// after this request.
	// For Kafka < 2.0.0, the throttle is applied before issuing a response.
	// For Kafka >= 2.0.0, the throttle is applied after issuing a response.
	ThrottleMillis int32 // v2+

	// Topics contains responses to the requested topic creations.
	Topics []CreateTopicsResponseTopic
}

func (*CreateTopicsResponse) Key() int16                 { return 19 }
func (*CreateTopicsResponse) MaxVersion() int16          { return 6 }
func (v *CreateTopicsResponse) SetVersion(version int16) { v.Version = version }
func (v *CreateTopicsResponse) GetVersion() int16        { return v.Version }
func (v *CreateTopicsResponse) IsFlexible() bool         { return v.Version >= 5 }
func (v *CreateTopicsResponse) RequestKind() Request     { return &CreateTopicsRequest{Version: v.Version} }

func (v *CreateTopicsResponse) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	isFlexible := version >= 5
	_ = isFlexible
	if version >= 2 {
		v := v.ThrottleMillis
		dst = kbin.AppendInt32(dst, v)
	}
	{
		v := v.Topics
		if isFlexible {
			dst = kbin.AppendCompactArrayLen(dst, len(v))
		} else {
			dst = kbin.AppendArrayLen(dst, len(v))
		}
		for i := range v {
			v := &v[i]
			{
				v := v.Topic
				if isFlexible {
					dst = kbin.AppendCompactString(dst, v)
				} else {
					dst = kbin.AppendString(dst, v)
				}
			}
			{
				v := v.ErrorCode
				dst = kbin.AppendInt16(dst, v)
			}
			if version >= 1 {
				v := v.ErrorMessage
				if isFlexible {
					dst = kbin.AppendCompactNullableString(dst, v)
				} else {
					dst = kbin.AppendNullableString(dst, v)
				}
			}
			if version >= 5 {
				v := v.NumPartitions
				dst = kbin.AppendInt32(dst, v)
			}
			if version >= 5 {
				v := v.ReplicationFactor
				dst = kbin.AppendInt16(dst, v)
			}
			if version >= 5 {
				v := v.Configs
				if isFlexible {
					dst = kbin.AppendCompactNullableArrayLen(dst, len(v), v == nil)
				} else {
					dst = kbin.AppendNullableArrayLen(dst, len(v), v == nil)
				}
				for i := range v {
					v := &v[i]
					{
						v := v.Name
						if isFlexible {
							dst = kbin.AppendCompactString(dst, v)
						} else {
							dst = kbin.AppendString(dst, v)
						}
					}
					{
						v := v.Value
						if isFlexible {
							dst = kbin.AppendCompactNullableString(dst, v)
						} else {
							dst = kbin.AppendNullableString(dst, v)
						}
					}
					{
						v := v.ReadOnly
						dst = kbin.AppendBool(dst, v)
					}
					{
						v := v.Source
						dst = kbin.AppendInt8(dst, v)
					}
					{
						v := v.IsSensitive
						dst = kbin.AppendBool(dst, v)
					}
					if isFlexible {
						dst = kbin.AppendUvarint(dst, 0)
					}
				}
			}
			if isFlexible {
				dst = kbin.AppendUvarint(dst, 1)
				{
					v := v.ConfigErrorCode
					dst = kbin.AppendUvarint(dst, 0)
					dst = kbin.AppendUvarint(dst, 2)
					dst = kbin.AppendInt16(dst, v)
				}
			}
		}
	}
	if isFlexible {
		dst = kbin.AppendUvarint(dst, 0)
	}
	return dst
}
func (v *CreateTopicsResponse) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	isFlexible := version >= 5
	_ = isFlexible
	b := kbin.Reader{Src: src}
	s := v
	if version >= 2 {
		v := b.Int32()
		s.ThrottleMillis = v
	}
	{
		v := s.Topics
		a := v
		var l int32
		if isFlexible {
			l = b.CompactArrayLen()
		} else {
			l = b.ArrayLen()
		}
		if !b.Ok() {
			return b.Complete()
		}
		if l > 0 {
			a = make([]CreateTopicsResponseTopic, l)
		}
		for i := int32(0); i < l; i++ {
			v := &a[i]
			s := v
			{
				var v string
				if isFlexible {
					v = b.CompactString()
				} else {
					v = b.String()
				}
				s.Topic = v
			}
			{
				v := b.Int16()
				s.ErrorCode = v
			}
			if version >= 1 {
				var v *string
				if isFlexible {
					v = b.CompactNullableString()
				} else {
					v = b.NullableString()
				}
				s.ErrorMessage = v
			}
			if version >= 5 {
				v := b.Int32()
				s.NumPartitions = v
			}
			if version >= 5 {
				v := b.Int16()
				s.ReplicationFactor = v
			}
			if version >= 5 {
				v := s.Configs
				a := v
				var l int32
				if isFlexible {
					l = b.CompactArrayLen()
				} else {
					l = b.ArrayLen()
				}
				if version < 0 || l == 0 {
					a = []CreateTopicsResponseTopicConfig{}
				}
				if !b.Ok() {
					return b.Complete()
				}
				if l > 0 {
					a = make([]CreateTopicsResponseTopicConfig, l)
				}
				for i := int32(0); i < l; i++ {
					v := &a[i]
					s := v
					{
						var v string
						if isFlexible {
							v = b.CompactString()
						} else {
							v = b.String()
						}
						s.Name = v
					}
					{
						var v *string
						if isFlexible {
							v = b.CompactNullableString()
						} else {
							v = b.NullableString()
						}
						s.Value = v
					}
					{
						v := b.Bool()
						s.ReadOnly = v
					}
					{
						v := b.Int8()
						s.Source = v
					}
					{
						v := b.Bool()
						s.IsSensitive = v
					}
					if isFlexible {
						SkipTags(&b)
					}
				}
				v = a
				s.Configs = v
			}
			if isFlexible {
				for i := b.Uvarint(); i > 0; i-- {
					tag, size := b.Uvarint(), int(b.Uvarint())
					switch tag {
					default:
						b.Span(size)
					case 0:
						b := kbin.Reader{Src: b.Span(size)}
						v := b.Int16()
						s.ConfigErrorCode = v
						if err := b.Complete(); err != nil {
							return err
						}
					}
				}
			}
		}
		v = a
		s.Topics = v
	}
	if isFlexible {
		SkipTags(&b)
	}
	return b.Complete()
}

// DeleteTopicsRequest deletes Kafka topics.
type DeleteTopicsRequest struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	// Topics is an array of topics to delete.
	Topics []string

	// TimeoutMillis is the millisecond timeout of this request.
	TimeoutMillis int32
}

func (*DeleteTopicsRequest) Key() int16                 { return 20 }
func (*DeleteTopicsRequest) MaxVersion() int16          { return 5 }
func (v *DeleteTopicsRequest) SetVersion(version int16) { v.Version = version }
func (v *DeleteTopicsRequest) GetVersion() int16        { return v.Version }
func (v *DeleteTopicsRequest) IsFlexible() bool         { return v.Version >= 4 }
func (v *DeleteTopicsRequest) IsAdminRequest()          {}
func (v *DeleteTopicsRequest) ResponseKind() Response {
	return &DeleteTopicsResponse{Version: v.Version}
}

func (v *DeleteTopicsRequest) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	isFlexible := version >= 4
	_ = isFlexible
	{
		v := v.Topics
		if isFlexible {
			dst = kbin.AppendCompactArrayLen(dst, len(v))
		} else {
			dst = kbin.AppendArrayLen(dst, len(v))
		}
		for i := range v {
			v := v[i]
			if isFlexible {
				dst = kbin.AppendCompactString(dst, v)
			} else {
				dst = kbin.AppendString(dst, v)
			}
		}
	}
	{
		v := v.TimeoutMillis
		dst = kbin.AppendInt32(dst, v)
	}
	if isFlexible {
		dst = kbin.AppendUvarint(dst, 0)
	}
	return dst
}
func (v *DeleteTopicsRequest) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	isFlexible := version >= 4
	_ = isFlexible
	b := kbin.Reader{Src: src}
	s := v
	{
		v := s.Topics
		a := v
		var l int32
		if isFlexible {
			l = b.CompactArrayLen()
		} else {
			l = b.ArrayLen()
		}
		if !b.Ok() {
			return b.Complete()
		}
		if l > 0 {
			a = make([]string, l)
		}
		for i := int32(0); i < l; i++ {
			var v string
			if isFlexible {
				v = b.CompactString()
			} else {
				v = b.String()
			}
			a[i] = v
		}
		v = a
		s.Topics = v
	}
	{
		v := b.Int32()
		s.TimeoutMillis = v
	}
	if isFlexible {
		SkipTags(&b)
	}
	return b.Complete()
}

type DeleteTopicsResponseTopic struct {
	// Topic is the topic requested for deletion.
	Topic string

	// ErrorCode is the error code returned for an individual topic in
	// deletion request.
	//
	// TOPIC_AUTHORIZATION_FAILED is returned if the client is not authorized
	// to delete a topic.
	//
	// UNKNOWN_TOPIC_OR_PARTITION is returned if the broker does not know of
	// the topic.
	//
	// NOT_CONTROLLER is returned if the request was not issued to a Kafka
	// controller.
	//
	// TOPIC_DELETION_DISABLED is returned for deletion requests version 3+
	// and brokers >= 2.1.0. INVALID_REQUEST is issued for request versions
	// 0-2 against brokers >= 2.1.0. Otherwise, the request hangs until it
	// times out.
	ErrorCode int16

	// ErrorMessage is a message for an error.
	ErrorMessage *string // v5+
}

// DeleteTopicsResponse is returned from a DeleteTopicsRequest.
// Version 3 added the TOPIC_DELETION_DISABLED error proposed in KIP-322
// and introduced in Kafka 2.1.0. Prior, the request timed out.
type DeleteTopicsResponse struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	// ThrottleMillis is how long of a throttle Kafka will apply to the client
	// after this request.
	// For Kafka < 2.0.0, the throttle is applied before issuing a response.
	// For Kafka >= 2.0.0, the throttle is applied after issuing a response.
	ThrottleMillis int32 // v1+

	// Topics contains responses for each topic requested for deletion.
	Topics []DeleteTopicsResponseTopic
}

func (*DeleteTopicsResponse) Key() int16                 { return 20 }
func (*DeleteTopicsResponse) MaxVersion() int16          { return 5 }
func (v *DeleteTopicsResponse) SetVersion(version int16) { v.Version = version }
func (v *DeleteTopicsResponse) GetVersion() int16        { return v.Version }
func (v *DeleteTopicsResponse) IsFlexible() bool         { return v.Version >= 4 }
func (v *DeleteTopicsResponse) RequestKind() Request     { return &DeleteTopicsRequest{Version: v.Version} }

func (v *DeleteTopicsResponse) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	isFlexible := version >= 4
	_ = isFlexible
	if version >= 1 {
		v := v.ThrottleMillis
		dst = kbin.AppendInt32(dst, v)
	}
	{
		v := v.Topics
		if isFlexible {
			dst = kbin.AppendCompactArrayLen(dst, len(v))
		} else {
			dst = kbin.AppendArrayLen(dst, len(v))
		}
		for i := range v {
			v := &v[i]
			{
				v := v.Topic
				if isFlexible {
					dst = kbin.AppendCompactString(dst, v)
				} else {
					dst = kbin.AppendString(dst, v)
				}
			}
			{
				v := v.ErrorCode
				dst = kbin.AppendInt16(dst, v)
			}
			if version >= 5 {
				v := v.ErrorMessage
				if isFlexible {
					dst = kbin.AppendCompactNullableString(dst, v)
				} else {
					dst = kbin.AppendNullableString(dst, v)
				}
			}
			if isFlexible {
				dst = kbin.AppendUvarint(dst, 0)
			}
		}
	}
	if isFlexible {
		dst = kbin.AppendUvarint(dst, 0)
	}
	return dst
}
func (v *DeleteTopicsResponse) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	isFlexible := version >= 4
	_ = isFlexible
	b := kbin.Reader{Src: src}
	s := v
	if version >= 1 {
		v := b.Int32()
		s.ThrottleMillis = v
	}
	{
		v := s.Topics
		a := v
		var l int32
		if isFlexible {
			l = b.CompactArrayLen()
		} else {
			l = b.ArrayLen()
		}
		if !b.Ok() {
			return b.Complete()
		}
		if l > 0 {
			a = make([]DeleteTopicsResponseTopic, l)
		}
		for i := int32(0); i < l; i++ {
			v := &a[i]
			s := v
			{
				var v string
				if isFlexible {
					v = b.CompactString()
				} else {
					v = b.String()
				}
				s.Topic = v
			}
			{
				v := b.Int16()
				s.ErrorCode = v
			}
			if version >= 5 {
				var v *string
				if isFlexible {
					v = b.CompactNullableString()
				} else {
					v = b.NullableString()
				}
				s.ErrorMessage = v
			}
			if isFlexible {
				SkipTags(&b)
			}
		}
		v = a
		s.Topics = v
	}
	if isFlexible {
		SkipTags(&b)
	}
	return b.Complete()
}

type DeleteRecordsRequestTopicPartition struct {
	// Partition is a partition to delete records from.
	Partition int32

	// Offset is the offset to set the partition's low watermark (start
	// offset) to. After a successful response, all records before this
	// offset are considered deleted and are no longer readable.
	//
	// To delete all records, use -1, which is mapped to the partition's
	// current high watermark.
	Offset int64
}
type DeleteRecordsRequestTopic struct {
	// Topic is a topic to delete records from.
	Topic string

	// Partitions contains partitions to delete records from.
	Partitions []DeleteRecordsRequestTopicPartition
}

// DeleteRecordsRequest is an admin request to delete records from Kafka.
// This was added for KIP-107.
//
// To delete records, Kafka sets the LastStableOffset for partitions to
// the requested offset. All segments whose max partition is before the
// requested offset are deleted, and any records within the segment before
// the requested offset can no longer be read.
//
// This request must be issued to the correct brokers that own the partitions
// you intend to delete records for.
type DeleteRecordsRequest struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	// Topics contains topics for which to delete records from.
	Topics []DeleteRecordsRequestTopic

	// TimeoutMillis is how long to wait for a response before Kafka will return.
	// Kafka waits for all replicas to respond to the delete reords request;
	// any partition that all replicas do not reply to within this limit will
	// have a timeout error.
	TimeoutMillis int32
}

func (*DeleteRecordsRequest) Key() int16                 { return 21 }
func (*DeleteRecordsRequest) MaxVersion() int16          { return 2 }
func (v *DeleteRecordsRequest) SetVersion(version int16) { v.Version = version }
func (v *DeleteRecordsRequest) GetVersion() int16        { return v.Version }
func (v *DeleteRecordsRequest) IsFlexible() bool         { return v.Version >= 2 }
func (v *DeleteRecordsRequest) ResponseKind() Response {
	return &DeleteRecordsResponse{Version: v.Version}
}

func (v *DeleteRecordsRequest) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	isFlexible := version >= 2
	_ = isFlexible
	{
		v := v.Topics
		if isFlexible {
			dst = kbin.AppendCompactArrayLen(dst, len(v))
		} else {
			dst = kbin.AppendArrayLen(dst, len(v))
		}
		for i := range v {
			v := &v[i]
			{
				v := v.Topic
				if isFlexible {
					dst = kbin.AppendCompactString(dst, v)
				} else {
					dst = kbin.AppendString(dst, v)
				}
			}
			{
				v := v.Partitions
				if isFlexible {
					dst = kbin.AppendCompactArrayLen(dst, len(v))
				} else {
					dst = kbin.AppendArrayLen(dst, len(v))
				}
				for i := range v {
					v := &v[i]
					{
						v := v.Partition
						dst = kbin.AppendInt32(dst, v)
					}
					{
						v := v.Offset
						dst = kbin.AppendInt64(dst, v)
					}
					if isFlexible {
						dst = kbin.AppendUvarint(dst, 0)
					}
				}
			}
			if isFlexible {
				dst = kbin.AppendUvarint(dst, 0)
			}
		}
	}
	{
		v := v.TimeoutMillis
		dst = kbin.AppendInt32(dst, v)
	}
	if isFlexible {
		dst = kbin.AppendUvarint(dst, 0)
	}
	return dst
}
func (v *DeleteRecordsRequest) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	isFlexible := version >= 2
	_ = isFlexible
	b := kbin.Reader{Src: src}
	s := v
	{
		v := s.Topics
		a := v
		var l int32
		if isFlexible {
			l = b.CompactArrayLen()
		} else {
			l = b.ArrayLen()
		}
		if !b.Ok() {
			return b.Complete()
		}
		if l > 0 {
			a = make([]DeleteRecordsRequestTopic, l)
		}
		for i := int32(0); i < l; i++ {
			v := &a[i]
			s := v
			{
				var v string
				if isFlexible {
					v = b.CompactString()
				} else {
					v = b.String()
				}
				s.Topic = v
			}
			{
				v := s.Partitions
				a := v
				var l int32
				if isFlexible {
					l = b.CompactArrayLen()
				} else {
					l = b.ArrayLen()
				}
				if !b.Ok() {
					return b.Complete()
				}
				if l > 0 {
					a = make([]DeleteRecordsRequestTopicPartition, l)
				}
				for i := int32(0); i < l; i++ {
					v := &a[i]
					s := v
					{
						v := b.Int32()
						s.Partition = v
					}
					{
						v := b.Int64()
						s.Offset = v
					}
					if isFlexible {
						SkipTags(&b)
					}
				}
				v = a
				s.Partitions = v
			}
			if isFlexible {
				SkipTags(&b)
			}
		}
		v = a
		s.Topics = v
	}
	{
		v := b.Int32()
		s.TimeoutMillis = v
	}
	if isFlexible {
		SkipTags(&b)
	}
	return b.Complete()
}

type DeleteRecordsResponseTopicPartition struct {
	// Partition is the partition this response corresponds to.
	Partition int32

	// LowWatermark is the new earliest offset for this partition.
	LowWatermark int64

	// ErrorCode is the error code returned for a given partition in
	// the delete request.
	//
	// TOPIC_AUTHORIZATION_FAILED is returned for all partitions if the
	// client is not authorized to delete records.
	//
	// UNKNOWN_TOPIC_OR_PARTITION is returned for all partitions that
	// the requested broker does not know of.
	//
	// NOT_LEADER_FOR_PARTITION is returned for partitions that the
	// requested broker is not a leader of.
	//
	// OFFSET_OUT_OF_RANGE is returned if the requested offset is
	// negative or higher than the current high watermark.
	//
	// POLICY_VIOLATION is returned if records cannot be deleted due to
	// broker configuration.
	//
	// KAFKA_STORAGE_EXCEPTION is returned if the partition is in an
	// offline log directory.
	ErrorCode int16
}
type DeleteRecordsResponseTopic struct {
	// Topic is the topic this response corresponds to.
	Topic string

	// Partitions contains responses for each partition in a requested topic
	// in the delete records request.
	Partitions []DeleteRecordsResponseTopicPartition
}

// DeleteRecordsResponse is returned from a DeleteRecordsRequest.
type DeleteRecordsResponse struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	// ThrottleMillis is how long of a throttle Kafka will apply to the client
	// after this request.
	// For Kafka < 2.0.0, the throttle is applied before issuing a response.
	// For Kafka >= 2.0.0, the throttle is applied after issuing a response.
	ThrottleMillis int32

	// Topics contains responses for each topic in the delete records request.
	Topics []DeleteRecordsResponseTopic
}

func (*DeleteRecordsResponse) Key() int16                 { return 21 }
func (*DeleteRecordsResponse) MaxVersion() int16          { return 2 }
func (v *DeleteRecordsResponse) SetVersion(version int16) { v.Version = version }
func (v *DeleteRecordsResponse) GetVersion() int16        { return v.Version }
func (v *DeleteRecordsResponse) IsFlexible() bool         { return v.Version >= 2 }
func (v *DeleteRecordsResponse) RequestKind() Request {
	return &DeleteRecordsRequest{Version: v.Version}
}

func (v *DeleteRecordsResponse) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	isFlexible := version >= 2
	_ = isFlexible
	{
		v := v.ThrottleMillis
		dst = kbin.AppendInt32(dst, v)
	}
	{
		v := v.Topics
		if isFlexible {
			dst = kbin.AppendCompactArrayLen(dst, len(v))
		} else {
			dst = kbin.AppendArrayLen(dst, len(v))
		}
		for i := range v {
			v := &v[i]
			{
				v := v.Topic
				if isFlexible {
					dst = kbin.AppendCompactString(dst, v)
				} else {
					dst = kbin.AppendString(dst, v)
				}
			}
			{
				v := v.Partitions
				if isFlexible {
					dst = kbin.AppendCompactArrayLen(dst, len(v))
				} else {
					dst = kbin.AppendArrayLen(dst, len(v))
				}
				for i := range v {
					v := &v[i]
					{
						v := v.Partition
						dst = kbin.AppendInt32(dst, v)
					}
					{
						v := v.LowWatermark
						dst = kbin.AppendInt64(dst, v)
					}
					{
						v := v.ErrorCode
						dst = kbin.AppendInt16(dst, v)
					}
					if isFlexible {
						dst = kbin.AppendUvarint(dst, 0)
					}
				}
			}
			if isFlexible {
				dst = kbin.AppendUvarint(dst, 0)
			}
		}
	}
	if isFlexible {
		dst = kbin.AppendUvarint(dst, 0)
	}
	return dst
}
func (v *DeleteRecordsResponse) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	isFlexible := version >= 2
	_ = isFlexible
	b := kbin.Reader{Src: src}
	s := v
	{
		v := b.Int32()
		s.ThrottleMillis = v
	}
	{
		v := s.Topics
		a := v
		var l int32
		if isFlexible {
			l = b.CompactArrayLen()
		} else {
			l = b.ArrayLen()
		}
		if !b.Ok() {
			return b.Complete()
		}
		if l > 0 {
			a = make([]DeleteRecordsResponseTopic, l)
		}
		for i := int32(0); i < l; i++ {
			v := &a[i]
			s := v
			{
				var v string
				if isFlexible {
					v = b.CompactString()
				} else {
					v = b.String()
				}
				s.Topic = v
			}
			{
				v := s.Partitions
				a := v
				var l int32
				if isFlexible {
					l = b.CompactArrayLen()
				} else {
					l = b.ArrayLen()
				}
				if !b.Ok() {
					return b.Complete()
				}
				if l > 0 {
					a = make([]DeleteRecordsResponseTopicPartition, l)
				}
				for i := int32(0); i < l; i++ {
					v := &a[i]
					s := v
					{
						v := b.Int32()
						s.Partition = v
					}
					{
						v := b.Int64()
						s.LowWatermark = v
					}
					{
						v := b.Int16()
						s.ErrorCode = v
					}
					if isFlexible {
						SkipTags(&b)
					}
				}
				v = a
				s.Partitions = v
			}
			if isFlexible {
				SkipTags(&b)
			}
		}
		v = a
		s.Topics = v
	}
	if isFlexible {
		SkipTags(&b)
	}
	return b.Complete()
}

// InitProducerIDRequest initializes a producer ID for idempotent transactions,
// and if using transactions, a producer epoch. This is the first request
// necessary to begin idempotent producing or transactions.
//
// Note that you do not need to go to a txn coordinator if you are initializing
// a producer id without a transactional id.
type InitProducerIDRequest struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	// TransactionalID is the ID to use for transactions if using transactions.
	TransactionalID *string

	// TransactionTimeoutMillis is how long a transaction is allowed before
	// EndTxn is required.
	//
	// Note that this timeout only begins on the first AddPartitionsToTxn
	// request.
	TransactionTimeoutMillis int32

	// ProducerID, added for KIP-360, is the current producer ID. This allows
	// the client to potentially recover on UNKNOWN_PRODUCER_ID errors.
	ProducerID int64 // v3+

	// The producer's current epoch. This will be checked against the producer
	// epoch on the broker, and the request will return an error if they do not
	// match. Also added for KIP-360.
	ProducerEpoch int16 // v3+
}

func (*InitProducerIDRequest) Key() int16                 { return 22 }
func (*InitProducerIDRequest) MaxVersion() int16          { return 4 }
func (v *InitProducerIDRequest) SetVersion(version int16) { v.Version = version }
func (v *InitProducerIDRequest) GetVersion() int16        { return v.Version }
func (v *InitProducerIDRequest) IsFlexible() bool         { return v.Version >= 2 }
func (v *InitProducerIDRequest) IsTxnCoordinatorRequest() {}
func (v *InitProducerIDRequest) ResponseKind() Response {
	return &InitProducerIDResponse{Version: v.Version}
}

func (v *InitProducerIDRequest) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	isFlexible := version >= 2
	_ = isFlexible
	{
		v := v.TransactionalID
		if isFlexible {
			dst = kbin.AppendCompactNullableString(dst, v)
		} else {
			dst = kbin.AppendNullableString(dst, v)
		}
	}
	{
		v := v.TransactionTimeoutMillis
		dst = kbin.AppendInt32(dst, v)
	}
	if version >= 3 {
		v := v.ProducerID
		dst = kbin.AppendInt64(dst, v)
	}
	if version >= 3 {
		v := v.ProducerEpoch
		dst = kbin.AppendInt16(dst, v)
	}
	if isFlexible {
		dst = kbin.AppendUvarint(dst, 0)
	}
	return dst
}
func (v *InitProducerIDRequest) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	isFlexible := version >= 2
	_ = isFlexible
	b := kbin.Reader{Src: src}
	s := v
	{
		var v *string
		if isFlexible {
			v = b.CompactNullableString()
		} else {
			v = b.NullableString()
		}
		s.TransactionalID = v
	}
	{
		v := b.Int32()
		s.TransactionTimeoutMillis = v
	}
	if version >= 3 {
		v := b.Int64()
		s.ProducerID = v
	}
	if version >= 3 {
		v := b.Int16()
		s.ProducerEpoch = v
	}
	if isFlexible {
		SkipTags(&b)
	}
	return b.Complete()
}

// InitProducerIDResponse is returned for an InitProducerIDRequest.
type InitProducerIDResponse struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	// ThrottleMillis is how long of a throttle Kafka will apply to the client
	// after this request.
	// For Kafka < 2.0.0, the throttle is applied before issuing a response.
	// For Kafka >= 2.0.0, the throttle is applied after issuing a response.
	ThrottleMillis int32

	// CLUSTER_AUTHORIZATION_FAILED is returned when not using transactions if
	// the client is not authorized for idempotent_write on cluster.
	//
	// TRANSACTIONAL_ID_AUTHORIZATION_FAILED is returned when using transactions
	// if the client is not authorized to write on transactional_id.
	//
	// INVALID_REQUEST is returned if using transactions and the transactional id
	// is an empty, non-null string
	//
	// COORDINATOR_LOAD_IN_PROGRESS is returned if the coordinator for this
	// transactional ID is still loading.
	//
	// NOT_COORDINATOR is returned if the broker is not the coordinator for
	// this transactional ID.
	//
	// INVALID_TRANSACTION_TIMEOUT is returned if using transactions and the timeout
	// is equal to over over transaction.max.timeout.ms or under 0.
	//
	// CONCURRENT_TRANSACTIONS is returned if there is an ongoing transaction
	// that is completing at the time this init is called.
	ErrorCode int16

	// ProducerID is the next producer ID that Kafka generated. This ID is used
	// to ensure repeated produce requests do not result in duplicate records.
	ProducerID int64

	// ProducerEpoch is the producer epoch to use for transactions.
	ProducerEpoch int16
}

func (*InitProducerIDResponse) Key() int16                 { return 22 }
func (*InitProducerIDResponse) MaxVersion() int16          { return 4 }
func (v *InitProducerIDResponse) SetVersion(version int16) { v.Version = version }
func (v *InitProducerIDResponse) GetVersion() int16        { return v.Version }
func (v *InitProducerIDResponse) IsFlexible() bool         { return v.Version >= 2 }
func (v *InitProducerIDResponse) RequestKind() Request {
	return &InitProducerIDRequest{Version: v.Version}
}

func (v *InitProducerIDResponse) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	isFlexible := version >= 2
	_ = isFlexible
	{
		v := v.ThrottleMillis
		dst = kbin.AppendInt32(dst, v)
	}
	{
		v := v.ErrorCode
		dst = kbin.AppendInt16(dst, v)
	}
	{
		v := v.ProducerID
		dst = kbin.AppendInt64(dst, v)
	}
	{
		v := v.ProducerEpoch
		dst = kbin.AppendInt16(dst, v)
	}
	if isFlexible {
		dst = kbin.AppendUvarint(dst, 0)
	}
	return dst
}
func (v *InitProducerIDResponse) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	isFlexible := version >= 2
	_ = isFlexible
	b := kbin.Reader{Src: src}
	s := v
	{
		v := b.Int32()
		s.ThrottleMillis = v
	}
	{
		v := b.Int16()
		s.ErrorCode = v
	}
	{
		v := b.Int64()
		s.ProducerID = v
	}
	{
		v := b.Int16()
		s.ProducerEpoch = v
	}
	if isFlexible {
		SkipTags(&b)
	}
	return b.Complete()
}

type OffsetForLeaderEpochRequestTopicPartition struct {
	// Partition is the number of a partition.
	Partition int32

	// CurrentLeaderEpoch, proposed in KIP-320 and introduced in Kafka 2.1.0,
	// allows brokers to check if the client is fenced (has an out of date
	// leader) or if the client is ahead of the broker.
	//
	// The initial leader epoch can be determined from a MetadataResponse.
	CurrentLeaderEpoch int32 // v2+

	// LeaderEpoch is the epoch to fetch the end offset for.
	LeaderEpoch int32
}
type OffsetForLeaderEpochRequestTopic struct {
	// Topic is the name of a topic.
	Topic string

	// Partitions are partitions within a topic to fetch leader epoch offsets for.
	Partitions []OffsetForLeaderEpochRequestTopicPartition
}

// OffsetForLeaderEpochRequest requests log end offsets for partitions.
//
// Version 2, proposed in KIP-320 and introduced in Kafka 2.1.0, can be used by
// consumers to perform more accurate offset resetting in the case of data loss.
//
// In support of version 2, this requires DESCRIBE on TOPIC.
type OffsetForLeaderEpochRequest struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	// ReplicaID, added in support of KIP-392, is the broker ID of the follower,
	// or -1 if this request is from a consumer.
	ReplicaID int32 // v3+

	// Topics are topics to fetch leader epoch offsets for.
	Topics []OffsetForLeaderEpochRequestTopic
}

func (*OffsetForLeaderEpochRequest) Key() int16                 { return 23 }
func (*OffsetForLeaderEpochRequest) MaxVersion() int16          { return 3 }
func (v *OffsetForLeaderEpochRequest) SetVersion(version int16) { v.Version = version }
func (v *OffsetForLeaderEpochRequest) GetVersion() int16        { return v.Version }
func (v *OffsetForLeaderEpochRequest) IsFlexible() bool         { return false }
func (v *OffsetForLeaderEpochRequest) ResponseKind() Response {
	return &OffsetForLeaderEpochResponse{Version: v.Version}
}

func (v *OffsetForLeaderEpochRequest) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	if version >= 3 {
		v := v.ReplicaID
		dst = kbin.AppendInt32(dst, v)
	}
	{
		v := v.Topics
		dst = kbin.AppendArrayLen(dst, len(v))
		for i := range v {
			v := &v[i]
			{
				v := v.Topic
				dst = kbin.AppendString(dst, v)
			}
			{
				v := v.Partitions
				dst = kbin.AppendArrayLen(dst, len(v))
				for i := range v {
					v := &v[i]
					{
						v := v.Partition
						dst = kbin.AppendInt32(dst, v)
					}
					if version >= 2 {
						v := v.CurrentLeaderEpoch
						dst = kbin.AppendInt32(dst, v)
					}
					{
						v := v.LeaderEpoch
						dst = kbin.AppendInt32(dst, v)
					}
				}
			}
		}
	}
	return dst
}
func (v *OffsetForLeaderEpochRequest) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	b := kbin.Reader{Src: src}
	s := v
	if version >= 3 {
		v := b.Int32()
		s.ReplicaID = v
	}
	{
		v := s.Topics
		a := v
		var l int32
		l = b.ArrayLen()
		if !b.Ok() {
			return b.Complete()
		}
		if l > 0 {
			a = make([]OffsetForLeaderEpochRequestTopic, l)
		}
		for i := int32(0); i < l; i++ {
			v := &a[i]
			s := v
			{
				v := b.String()
				s.Topic = v
			}
			{
				v := s.Partitions
				a := v
				var l int32
				l = b.ArrayLen()
				if !b.Ok() {
					return b.Complete()
				}
				if l > 0 {
					a = make([]OffsetForLeaderEpochRequestTopicPartition, l)
				}
				for i := int32(0); i < l; i++ {
					v := &a[i]
					s := v
					{
						v := b.Int32()
						s.Partition = v
					}
					if version >= 2 {
						v := b.Int32()
						s.CurrentLeaderEpoch = v
					}
					{
						v := b.Int32()
						s.LeaderEpoch = v
					}
				}
				v = a
				s.Partitions = v
			}
		}
		v = a
		s.Topics = v
	}
	return b.Complete()
}

type OffsetForLeaderEpochResponseTopicPartition struct {
	// ErrorCode is the error code returned on request failure.
	//
	// TOPIC_AUTHORIZATION_FAILED is returned if the client does not have
	// the necessary permissions to issue this request.
	//
	// KAFKA_STORAGE_ERROR is returned if the partition is offline.
	//
	// NOT_LEADER_FOR_PARTITION is returned if the broker knows of the partition
	// but does not own it.
	//
	// UNKNOWN_TOPIC_OR_PARTITION is returned if the broker does not know of the
	// partition.
	//
	// FENCED_LEADER_EPOCH is returned if the client is using a current leader epoch
	// older than the actual leader epoch.
	//
	// UNKNOWN_LEADER_EPOCH if returned if the client is using a current leader epoch
	// that the actual leader does not know of. This could occur when the client
	// has newer metadata than the broker when the broker just became the leader for
	//  a replica.
	ErrorCode int16

	// Partition is the partition this response is for.
	Partition int32

	// LeaderEpoch is similar to the requested leader epoch, but pairs with the
	// next field. If the requested leader epoch is unknown, this is -1. If the
	// requested epoch had no records produced during the requested epoch, this
	// is the first prior epoch that had records.
	LeaderEpoch int32

	// EndOffset is either (1) just past the last recorded offset in the
	// current partition if the broker leader has the same epoch as the
	// leader epoch in the request, or (2) the beginning offset of the next
	// epoch if the leader is past the requested epoch. The second scenario
	// can be seen as equivalent to the first: the beginning offset of the
	// next epoch is just past the final offset of the prior epoch.
	//
	// (2) allows consumers to detect data loss: if the consumer consumed
	// past the end offset that is returned, then the consumer should reset
	// to the returned offset and the consumer knows everything past the end
	// offset was lost.
	//
	// With the prior field, consumers know that at this offset, the broker
	// either has no more records (consumer is caught up), or the broker
	// transitioned to a new epoch.
	EndOffset int64
}
type OffsetForLeaderEpochResponseTopic struct {
	// Topic is the topic this response corresponds to.
	Topic string

	// Partitions are responses to partitions in a topic in the request.
	Partitions []OffsetForLeaderEpochResponseTopicPartition
}

// OffsetForLeaderEpochResponse is returned from an OffsetForLeaderEpochRequest.
type OffsetForLeaderEpochResponse struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	// ThrottleMillis is how long of a throttle Kafka will apply to the client
	// after this request.
	ThrottleMillis int32 // v2+

	// Topics are responses to topics in the request.
	Topics []OffsetForLeaderEpochResponseTopic
}

func (*OffsetForLeaderEpochResponse) Key() int16                 { return 23 }
func (*OffsetForLeaderEpochResponse) MaxVersion() int16          { return 3 }
func (v *OffsetForLeaderEpochResponse) SetVersion(version int16) { v.Version = version }
func (v *OffsetForLeaderEpochResponse) GetVersion() int16        { return v.Version }
func (v *OffsetForLeaderEpochResponse) IsFlexible() bool         { return false }
func (v *OffsetForLeaderEpochResponse) RequestKind() Request {
	return &OffsetForLeaderEpochRequest{Version: v.Version}
}

func (v *OffsetForLeaderEpochResponse) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	if version >= 2 {
		v := v.ThrottleMillis
		dst = kbin.AppendInt32(dst, v)
	}
	{
		v := v.Topics
		dst = kbin.AppendArrayLen(dst, len(v))
		for i := range v {
			v := &v[i]
			{
				v := v.Topic
				dst = kbin.AppendString(dst, v)
			}
			{
				v := v.Partitions
				dst = kbin.AppendArrayLen(dst, len(v))
				for i := range v {
					v := &v[i]
					{
						v := v.ErrorCode
						dst = kbin.AppendInt16(dst, v)
					}
					{
						v := v.Partition
						dst = kbin.AppendInt32(dst, v)
					}
					{
						v := v.LeaderEpoch
						dst = kbin.AppendInt32(dst, v)
					}
					{
						v := v.EndOffset
						dst = kbin.AppendInt64(dst, v)
					}
				}
			}
		}
	}
	return dst
}
func (v *OffsetForLeaderEpochResponse) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	b := kbin.Reader{Src: src}
	s := v
	if version >= 2 {
		v := b.Int32()
		s.ThrottleMillis = v
	}
	{
		v := s.Topics
		a := v
		var l int32
		l = b.ArrayLen()
		if !b.Ok() {
			return b.Complete()
		}
		if l > 0 {
			a = make([]OffsetForLeaderEpochResponseTopic, l)
		}
		for i := int32(0); i < l; i++ {
			v := &a[i]
			s := v
			{
				v := b.String()
				s.Topic = v
			}
			{
				v := s.Partitions
				a := v
				var l int32
				l = b.ArrayLen()
				if !b.Ok() {
					return b.Complete()
				}
				if l > 0 {
					a = make([]OffsetForLeaderEpochResponseTopicPartition, l)
				}
				for i := int32(0); i < l; i++ {
					v := &a[i]
					s := v
					{
						v := b.Int16()
						s.ErrorCode = v
					}
					{
						v := b.Int32()
						s.Partition = v
					}
					{
						v := b.Int32()
						s.LeaderEpoch = v
					}
					{
						v := b.Int64()
						s.EndOffset = v
					}
				}
				v = a
				s.Partitions = v
			}
		}
		v = a
		s.Topics = v
	}
	return b.Complete()
}

type AddPartitionsToTxnRequestTopic struct {
	// Topic is a topic name.
	Topic string

	// Partitions are partitions within a topic to add as part of the producer
	// side of a transaction.
	Partitions []int32
}

// AddPartitionsToTxnRequest begins the producer side of a transaction for all
// partitions in the request. Before producing any records to a partition in
// the transaction, that partition must have been added to the transaction with
// this request.
type AddPartitionsToTxnRequest struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	// TransactionalID is the transactional ID to use for this request.
	TransactionalID string

	// ProducerID is the producer ID of the client for this transactional ID
	// as received from InitProducerID.
	ProducerID int64

	// ProducerEpoch is the producer epoch of the client for this transactional ID
	// as received from InitProducerID.
	ProducerEpoch int16

	// Topics are topics to add as part of the producer side of a transaction.
	Topics []AddPartitionsToTxnRequestTopic
}

func (*AddPartitionsToTxnRequest) Key() int16                 { return 24 }
func (*AddPartitionsToTxnRequest) MaxVersion() int16          { return 2 }
func (v *AddPartitionsToTxnRequest) SetVersion(version int16) { v.Version = version }
func (v *AddPartitionsToTxnRequest) GetVersion() int16        { return v.Version }
func (v *AddPartitionsToTxnRequest) IsFlexible() bool         { return false }
func (v *AddPartitionsToTxnRequest) IsTxnCoordinatorRequest() {}
func (v *AddPartitionsToTxnRequest) ResponseKind() Response {
	return &AddPartitionsToTxnResponse{Version: v.Version}
}

func (v *AddPartitionsToTxnRequest) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	{
		v := v.TransactionalID
		dst = kbin.AppendString(dst, v)
	}
	{
		v := v.ProducerID
		dst = kbin.AppendInt64(dst, v)
	}
	{
		v := v.ProducerEpoch
		dst = kbin.AppendInt16(dst, v)
	}
	{
		v := v.Topics
		dst = kbin.AppendArrayLen(dst, len(v))
		for i := range v {
			v := &v[i]
			{
				v := v.Topic
				dst = kbin.AppendString(dst, v)
			}
			{
				v := v.Partitions
				dst = kbin.AppendArrayLen(dst, len(v))
				for i := range v {
					v := v[i]
					dst = kbin.AppendInt32(dst, v)
				}
			}
		}
	}
	return dst
}
func (v *AddPartitionsToTxnRequest) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	b := kbin.Reader{Src: src}
	s := v
	{
		v := b.String()
		s.TransactionalID = v
	}
	{
		v := b.Int64()
		s.ProducerID = v
	}
	{
		v := b.Int16()
		s.ProducerEpoch = v
	}
	{
		v := s.Topics
		a := v
		var l int32
		l = b.ArrayLen()
		if !b.Ok() {
			return b.Complete()
		}
		if l > 0 {
			a = make([]AddPartitionsToTxnRequestTopic, l)
		}
		for i := int32(0); i < l; i++ {
			v := &a[i]
			s := v
			{
				v := b.String()
				s.Topic = v
			}
			{
				v := s.Partitions
				a := v
				var l int32
				l = b.ArrayLen()
				if !b.Ok() {
					return b.Complete()
				}
				if l > 0 {
					a = make([]int32, l)
				}
				for i := int32(0); i < l; i++ {
					v := b.Int32()
					a[i] = v
				}
				v = a
				s.Partitions = v
			}
		}
		v = a
		s.Topics = v
	}
	return b.Complete()
}

type AddPartitionsToTxnResponseTopicPartition struct {
	// Partition is a partition being responded to.
	Partition int32

	// ErrorCode is any error for this topic/partition commit.
	//
	// TRANSACTIONAL_ID_AUTHORIZATION_FAILED is returned if the client is
	// not authorized for write with transactional IDs with the requested
	// transactional ID.
	//
	// TOPIC_AUTHORIZATION_FAILED is returned for all topics that the client
	// is not authorized to write to.
	//
	// UNKNOWN_TOPIC_OR_PARTITION is returned for all topics or partitions
	// that the broker does not know of.
	//
	// OPERATION_NOT_ATTEMPTED is returned if any of the above errors occur
	// for all partitions that did not have the above errors.
	//
	// INVALID_REQUEST is returned if the transactional ID is invalid.
	//
	// COORDINATOR_LOAD_IN_PROGRESS is returned if the coordinator for this
	// transactional ID is still loading.
	//
	// NOT_COORDINATOR is returned if the broker is not the coordinator for
	// this transactional ID.
	//
	// INVALID_PRODUCER_ID_MAPPING is returned if the produce request used
	// a producer ID that is not tied to the transactional ID (i.e., mismatch
	// from what was returned from InitProducerID).
	//
	// INVALID_PRODUCER_EPOCH is returned if the requested epoch does not match
	// the broker epoch for this transactional ID.
	//
	// CONCURRENT_TRANSACTIONS is returned if there is an ongoing transaction for
	// this transactional ID, if the producer ID and epoch matches the broker's.
	ErrorCode int16
}
type AddPartitionsToTxnResponseTopic struct {
	// Topic is a topic being responded to.
	Topic string

	// Partitions are responses to partitions in the request.
	Partitions []AddPartitionsToTxnResponseTopicPartition
}

// AddPartitionsToTxnResponse is a response to an AddPartitionsToTxnRequest.
type AddPartitionsToTxnResponse struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	// ThrottleMillis is how long of a throttle Kafka will apply to the client
	// after this request.
	// For Kafka < 2.0.0, the throttle is applied before issuing a response.
	// For Kafka >= 2.0.0, the throttle is applied after issuing a response.
	ThrottleMillis int32

	// Topics are responses to topics in the request.
	Topics []AddPartitionsToTxnResponseTopic
}

func (*AddPartitionsToTxnResponse) Key() int16                 { return 24 }
func (*AddPartitionsToTxnResponse) MaxVersion() int16          { return 2 }
func (v *AddPartitionsToTxnResponse) SetVersion(version int16) { v.Version = version }
func (v *AddPartitionsToTxnResponse) GetVersion() int16        { return v.Version }
func (v *AddPartitionsToTxnResponse) IsFlexible() bool         { return false }
func (v *AddPartitionsToTxnResponse) RequestKind() Request {
	return &AddPartitionsToTxnRequest{Version: v.Version}
}

func (v *AddPartitionsToTxnResponse) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	{
		v := v.ThrottleMillis
		dst = kbin.AppendInt32(dst, v)
	}
	{
		v := v.Topics
		dst = kbin.AppendArrayLen(dst, len(v))
		for i := range v {
			v := &v[i]
			{
				v := v.Topic
				dst = kbin.AppendString(dst, v)
			}
			{
				v := v.Partitions
				dst = kbin.AppendArrayLen(dst, len(v))
				for i := range v {
					v := &v[i]
					{
						v := v.Partition
						dst = kbin.AppendInt32(dst, v)
					}
					{
						v := v.ErrorCode
						dst = kbin.AppendInt16(dst, v)
					}
				}
			}
		}
	}
	return dst
}
func (v *AddPartitionsToTxnResponse) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	b := kbin.Reader{Src: src}
	s := v
	{
		v := b.Int32()
		s.ThrottleMillis = v
	}
	{
		v := s.Topics
		a := v
		var l int32
		l = b.ArrayLen()
		if !b.Ok() {
			return b.Complete()
		}
		if l > 0 {
			a = make([]AddPartitionsToTxnResponseTopic, l)
		}
		for i := int32(0); i < l; i++ {
			v := &a[i]
			s := v
			{
				v := b.String()
				s.Topic = v
			}
			{
				v := s.Partitions
				a := v
				var l int32
				l = b.ArrayLen()
				if !b.Ok() {
					return b.Complete()
				}
				if l > 0 {
					a = make([]AddPartitionsToTxnResponseTopicPartition, l)
				}
				for i := int32(0); i < l; i++ {
					v := &a[i]
					s := v
					{
						v := b.Int32()
						s.Partition = v
					}
					{
						v := b.Int16()
						s.ErrorCode = v
					}
				}
				v = a
				s.Partitions = v
			}
		}
		v = a
		s.Topics = v
	}
	return b.Complete()
}

// AddOffsetsToTxnRequest is a request that ties produced records to what group
// is being consumed for the transaction.
//
// This request must be called before TxnOffsetCommitRequest.
//
// Internally, this request simply adds the __consumer_offsets topic as a
// partition for this transaction with AddPartitionsToTxn for the partition
// in that topic that contains the group.
type AddOffsetsToTxnRequest struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	// TransactionalID is the transactional ID to use for this request.
	TransactionalID string

	// ProducerID is the producer ID of the client for this transactional ID
	// as received from InitProducerID.
	ProducerID int64

	// ProducerEpoch is the producer epoch of the client for this transactional ID
	// as received from InitProducerID.
	ProducerEpoch int16

	// Group is the group to tie this transaction to.
	Group string
}

func (*AddOffsetsToTxnRequest) Key() int16                 { return 25 }
func (*AddOffsetsToTxnRequest) MaxVersion() int16          { return 2 }
func (v *AddOffsetsToTxnRequest) SetVersion(version int16) { v.Version = version }
func (v *AddOffsetsToTxnRequest) GetVersion() int16        { return v.Version }
func (v *AddOffsetsToTxnRequest) IsFlexible() bool         { return false }
func (v *AddOffsetsToTxnRequest) IsTxnCoordinatorRequest() {}
func (v *AddOffsetsToTxnRequest) ResponseKind() Response {
	return &AddOffsetsToTxnResponse{Version: v.Version}
}

func (v *AddOffsetsToTxnRequest) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	{
		v := v.TransactionalID
		dst = kbin.AppendString(dst, v)
	}
	{
		v := v.ProducerID
		dst = kbin.AppendInt64(dst, v)
	}
	{
		v := v.ProducerEpoch
		dst = kbin.AppendInt16(dst, v)
	}
	{
		v := v.Group
		dst = kbin.AppendString(dst, v)
	}
	return dst
}
func (v *AddOffsetsToTxnRequest) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	b := kbin.Reader{Src: src}
	s := v
	{
		v := b.String()
		s.TransactionalID = v
	}
	{
		v := b.Int64()
		s.ProducerID = v
	}
	{
		v := b.Int16()
		s.ProducerEpoch = v
	}
	{
		v := b.String()
		s.Group = v
	}
	return b.Complete()
}

// AddOffsetsToTxnResponse is a response to an AddOffsetsToTxnRequest.
type AddOffsetsToTxnResponse struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	// ThrottleMillis is how long of a throttle Kafka will apply to the client
	// after this request.
	// For Kafka < 2.0.0, the throttle is applied before issuing a response.
	// For Kafka >= 2.0.0, the throttle is applied after issuing a response.
	ThrottleMillis int32

	// ErrorCode is any error for this topic/partition commit.
	//
	// TRANSACTIONAL_ID_AUTHORIZATION_FAILED is returned if the client is
	// not authorized for write with transactional IDs with the requested
	// transactional ID.
	//
	// GROUP_AUTHORIZATION_FAILED is returned if the client is not authorized
	// to read group with the requested group id.
	//
	// This also can return any error that AddPartitionsToTxn returns.
	ErrorCode int16
}

func (*AddOffsetsToTxnResponse) Key() int16                 { return 25 }
func (*AddOffsetsToTxnResponse) MaxVersion() int16          { return 2 }
func (v *AddOffsetsToTxnResponse) SetVersion(version int16) { v.Version = version }
func (v *AddOffsetsToTxnResponse) GetVersion() int16        { return v.Version }
func (v *AddOffsetsToTxnResponse) IsFlexible() bool         { return false }
func (v *AddOffsetsToTxnResponse) RequestKind() Request {
	return &AddOffsetsToTxnRequest{Version: v.Version}
}

func (v *AddOffsetsToTxnResponse) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	{
		v := v.ThrottleMillis
		dst = kbin.AppendInt32(dst, v)
	}
	{
		v := v.ErrorCode
		dst = kbin.AppendInt16(dst, v)
	}
	return dst
}
func (v *AddOffsetsToTxnResponse) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	b := kbin.Reader{Src: src}
	s := v
	{
		v := b.Int32()
		s.ThrottleMillis = v
	}
	{
		v := b.Int16()
		s.ErrorCode = v
	}
	return b.Complete()
}

// EndTxnRequest ends a transaction. This should be called after
// TxnOffsetCommitRequest.
type EndTxnRequest struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	// TransactionalID is the transactional ID to use for this request.
	TransactionalID string

	// ProducerID is the producer ID of the client for this transactional ID
	// as received from InitProducerID.
	ProducerID int64

	// ProducerEpoch is the producer epoch of the client for this transactional ID
	// as received from InitProducerID.
	ProducerEpoch int16

	// Commit is whether to commit this transaction: true for yes, false for abort.
	Commit bool
}

func (*EndTxnRequest) Key() int16                 { return 26 }
func (*EndTxnRequest) MaxVersion() int16          { return 2 }
func (v *EndTxnRequest) SetVersion(version int16) { v.Version = version }
func (v *EndTxnRequest) GetVersion() int16        { return v.Version }
func (v *EndTxnRequest) IsFlexible() bool         { return false }
func (v *EndTxnRequest) IsTxnCoordinatorRequest() {}
func (v *EndTxnRequest) ResponseKind() Response   { return &EndTxnResponse{Version: v.Version} }

func (v *EndTxnRequest) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	{
		v := v.TransactionalID
		dst = kbin.AppendString(dst, v)
	}
	{
		v := v.ProducerID
		dst = kbin.AppendInt64(dst, v)
	}
	{
		v := v.ProducerEpoch
		dst = kbin.AppendInt16(dst, v)
	}
	{
		v := v.Commit
		dst = kbin.AppendBool(dst, v)
	}
	return dst
}
func (v *EndTxnRequest) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	b := kbin.Reader{Src: src}
	s := v
	{
		v := b.String()
		s.TransactionalID = v
	}
	{
		v := b.Int64()
		s.ProducerID = v
	}
	{
		v := b.Int16()
		s.ProducerEpoch = v
	}
	{
		v := b.Bool()
		s.Commit = v
	}
	return b.Complete()
}

// EndTxnResponse is a response for an EndTxnRequest.
type EndTxnResponse struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	// ThrottleMillis is how long of a throttle Kafka will apply to the client
	// after this request.
	// For Kafka < 2.0.0, the throttle is applied before issuing a response.
	// For Kafka >= 2.0.0, the throttle is applied after issuing a response.
	ThrottleMillis int32

	// ErrorCode is any error for this topic/partition commit.
	//
	// TRANSACTIONAL_ID_AUTHORIZATION_FAILED is returned if the client is
	// not authorized for write with transactional IDs with the requested
	// transactional ID.
	//
	// INVALID_REQUEST is returned if the transactional ID is invalid.
	//
	// INVALID_PRODUCER_ID_MAPPING is returned if the produce request used
	// a producer ID that is not tied to the transactional ID (i.e., mismatch
	// from what was returned from InitProducerID).
	//
	// INVALID_PRODUCER_EPOCH is returned if the requested epoch does not match
	// the broker epoch for this transactional ID.
	//
	// CONCURRENT_TRANSACTIONS is returned if there is an ongoing transaction for
	// this transactional ID, if the producer ID and epoch matches the broker's.
	//
	// INVALID_TXN_STATE is returned if this request is attempted at the wrong
	// time (given the order of how transaction requests should go).
	ErrorCode int16
}

func (*EndTxnResponse) Key() int16                 { return 26 }
func (*EndTxnResponse) MaxVersion() int16          { return 2 }
func (v *EndTxnResponse) SetVersion(version int16) { v.Version = version }
func (v *EndTxnResponse) GetVersion() int16        { return v.Version }
func (v *EndTxnResponse) IsFlexible() bool         { return false }
func (v *EndTxnResponse) RequestKind() Request     { return &EndTxnRequest{Version: v.Version} }

func (v *EndTxnResponse) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	{
		v := v.ThrottleMillis
		dst = kbin.AppendInt32(dst, v)
	}
	{
		v := v.ErrorCode
		dst = kbin.AppendInt16(dst, v)
	}
	return dst
}
func (v *EndTxnResponse) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	b := kbin.Reader{Src: src}
	s := v
	{
		v := b.Int32()
		s.ThrottleMillis = v
	}
	{
		v := b.Int16()
		s.ErrorCode = v
	}
	return b.Complete()
}

type WriteTxnMarkersRequestMarkerTopic struct {
	Topic string

	Partitions []int32
}
type WriteTxnMarkersRequestMarker struct {
	ProducerID int64

	ProducerEpoch int16

	Committed bool

	Topics []WriteTxnMarkersRequestMarkerTopic

	CoordinatorEpoch int32
}

// WriteTxnMarkersRequest is a broker-to-broker request that Kafka uses to
// finish transactions. Since this is specifically for inter-broker
// communication, this is left undocumented.
type WriteTxnMarkersRequest struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	Markers []WriteTxnMarkersRequestMarker
}

func (*WriteTxnMarkersRequest) Key() int16                 { return 27 }
func (*WriteTxnMarkersRequest) MaxVersion() int16          { return 0 }
func (v *WriteTxnMarkersRequest) SetVersion(version int16) { v.Version = version }
func (v *WriteTxnMarkersRequest) GetVersion() int16        { return v.Version }
func (v *WriteTxnMarkersRequest) IsFlexible() bool         { return false }
func (v *WriteTxnMarkersRequest) ResponseKind() Response {
	return &WriteTxnMarkersResponse{Version: v.Version}
}

func (v *WriteTxnMarkersRequest) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	{
		v := v.Markers
		dst = kbin.AppendArrayLen(dst, len(v))
		for i := range v {
			v := &v[i]
			{
				v := v.ProducerID
				dst = kbin.AppendInt64(dst, v)
			}
			{
				v := v.ProducerEpoch
				dst = kbin.AppendInt16(dst, v)
			}
			{
				v := v.Committed
				dst = kbin.AppendBool(dst, v)
			}
			{
				v := v.Topics
				dst = kbin.AppendArrayLen(dst, len(v))
				for i := range v {
					v := &v[i]
					{
						v := v.Topic
						dst = kbin.AppendString(dst, v)
					}
					{
						v := v.Partitions
						dst = kbin.AppendArrayLen(dst, len(v))
						for i := range v {
							v := v[i]
							dst = kbin.AppendInt32(dst, v)
						}
					}
				}
			}
			{
				v := v.CoordinatorEpoch
				dst = kbin.AppendInt32(dst, v)
			}
		}
	}
	return dst
}
func (v *WriteTxnMarkersRequest) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	b := kbin.Reader{Src: src}
	s := v
	{
		v := s.Markers
		a := v
		var l int32
		l = b.ArrayLen()
		if !b.Ok() {
			return b.Complete()
		}
		if l > 0 {
			a = make([]WriteTxnMarkersRequestMarker, l)
		}
		for i := int32(0); i < l; i++ {
			v := &a[i]
			s := v
			{
				v := b.Int64()
				s.ProducerID = v
			}
			{
				v := b.Int16()
				s.ProducerEpoch = v
			}
			{
				v := b.Bool()
				s.Committed = v
			}
			{
				v := s.Topics
				a := v
				var l int32
				l = b.ArrayLen()
				if !b.Ok() {
					return b.Complete()
				}
				if l > 0 {
					a = make([]WriteTxnMarkersRequestMarkerTopic, l)
				}
				for i := int32(0); i < l; i++ {
					v := &a[i]
					s := v
					{
						v := b.String()
						s.Topic = v
					}
					{
						v := s.Partitions
						a := v
						var l int32
						l = b.ArrayLen()
						if !b.Ok() {
							return b.Complete()
						}
						if l > 0 {
							a = make([]int32, l)
						}
						for i := int32(0); i < l; i++ {
							v := b.Int32()
							a[i] = v
						}
						v = a
						s.Partitions = v
					}
				}
				v = a
				s.Topics = v
			}
			{
				v := b.Int32()
				s.CoordinatorEpoch = v
			}
		}
		v = a
		s.Markers = v
	}
	return b.Complete()
}

type WriteTxnMarkersResponseMarkerTopicPartition struct {
	Partition int32

	ErrorCode int16
}
type WriteTxnMarkersResponseMarkerTopic struct {
	Topic string

	Partitions []WriteTxnMarkersResponseMarkerTopicPartition
}
type WriteTxnMarkersResponseMarker struct {
	ProducerID int64

	Topics []WriteTxnMarkersResponseMarkerTopic
}

// WriteTxnMarkersResponse is a response to a WriteTxnMarkersRequest.
type WriteTxnMarkersResponse struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	Markers []WriteTxnMarkersResponseMarker
}

func (*WriteTxnMarkersResponse) Key() int16                 { return 27 }
func (*WriteTxnMarkersResponse) MaxVersion() int16          { return 0 }
func (v *WriteTxnMarkersResponse) SetVersion(version int16) { v.Version = version }
func (v *WriteTxnMarkersResponse) GetVersion() int16        { return v.Version }
func (v *WriteTxnMarkersResponse) IsFlexible() bool         { return false }
func (v *WriteTxnMarkersResponse) RequestKind() Request {
	return &WriteTxnMarkersRequest{Version: v.Version}
}

func (v *WriteTxnMarkersResponse) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	{
		v := v.Markers
		dst = kbin.AppendArrayLen(dst, len(v))
		for i := range v {
			v := &v[i]
			{
				v := v.ProducerID
				dst = kbin.AppendInt64(dst, v)
			}
			{
				v := v.Topics
				dst = kbin.AppendArrayLen(dst, len(v))
				for i := range v {
					v := &v[i]
					{
						v := v.Topic
						dst = kbin.AppendString(dst, v)
					}
					{
						v := v.Partitions
						dst = kbin.AppendArrayLen(dst, len(v))
						for i := range v {
							v := &v[i]
							{
								v := v.Partition
								dst = kbin.AppendInt32(dst, v)
							}
							{
								v := v.ErrorCode
								dst = kbin.AppendInt16(dst, v)
							}
						}
					}
				}
			}
		}
	}
	return dst
}
func (v *WriteTxnMarkersResponse) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	b := kbin.Reader{Src: src}
	s := v
	{
		v := s.Markers
		a := v
		var l int32
		l = b.ArrayLen()
		if !b.Ok() {
			return b.Complete()
		}
		if l > 0 {
			a = make([]WriteTxnMarkersResponseMarker, l)
		}
		for i := int32(0); i < l; i++ {
			v := &a[i]
			s := v
			{
				v := b.Int64()
				s.ProducerID = v
			}
			{
				v := s.Topics
				a := v
				var l int32
				l = b.ArrayLen()
				if !b.Ok() {
					return b.Complete()
				}
				if l > 0 {
					a = make([]WriteTxnMarkersResponseMarkerTopic, l)
				}
				for i := int32(0); i < l; i++ {
					v := &a[i]
					s := v
					{
						v := b.String()
						s.Topic = v
					}
					{
						v := s.Partitions
						a := v
						var l int32
						l = b.ArrayLen()
						if !b.Ok() {
							return b.Complete()
						}
						if l > 0 {
							a = make([]WriteTxnMarkersResponseMarkerTopicPartition, l)
						}
						for i := int32(0); i < l; i++ {
							v := &a[i]
							s := v
							{
								v := b.Int32()
								s.Partition = v
							}
							{
								v := b.Int16()
								s.ErrorCode = v
							}
						}
						v = a
						s.Partitions = v
					}
				}
				v = a
				s.Topics = v
			}
		}
		v = a
		s.Markers = v
	}
	return b.Complete()
}

type TxnOffsetCommitRequestTopicPartition struct {
	// Partition is a partition to add for a pending commit.
	Partition int32

	// Offset is the offset within partition to commit once EndTxnRequest is
	// called (with commit; abort obviously aborts).
	Offset int64

	// LeaderEpoch, proposed in KIP-320 and introduced in Kafka 2.1.0,
	// allows brokers to check if the client is fenced (has an out of date
	// leader) or is using an unknown leader.
	//
	// The initial leader epoch can be determined from a MetadataResponse.
	// To skip log truncation checking, use -1.
	LeaderEpoch int32 // v2+

	// Metadata is optional metadata the client wants to include with this
	// commit.
	Metadata *string
}
type TxnOffsetCommitRequestTopic struct {
	// Topic is a topic to add for a pending commit.
	Topic string

	// Partitions are partitions to add for pending commits.
	Partitions []TxnOffsetCommitRequestTopicPartition
}

// TxnOffsetCommitRequest sends offsets that are a part of this transaction
// to be committed once the transaction itself finishes. This effectively
// replaces OffsetCommitRequest for when using transactions.
type TxnOffsetCommitRequest struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	// TransactionalID is the transactional ID to use for this request.
	TransactionalID string

	// Group is the group consumed in this transaction and to be used for
	// committing.
	Group string

	// ProducerID is the producer ID of the client for this transactional ID
	// as received from InitProducerID.
	ProducerID int64

	// ProducerEpoch is the producer epoch of the client for this transactional ID
	// as received from InitProducerID.
	ProducerEpoch int16

	// Generation is the group generation this transactional offset commit request is for.
	Generation int32 // v3+

	// MemberID is the member ID this member is for.
	MemberID string // v3+

	// InstanceID is the instance ID of this member in the group (KIP-345, KIP-447).
	InstanceID *string // v3+

	// Topics are topics to add for pending commits.
	Topics []TxnOffsetCommitRequestTopic
}

func (*TxnOffsetCommitRequest) Key() int16                   { return 28 }
func (*TxnOffsetCommitRequest) MaxVersion() int16            { return 3 }
func (v *TxnOffsetCommitRequest) SetVersion(version int16)   { v.Version = version }
func (v *TxnOffsetCommitRequest) GetVersion() int16          { return v.Version }
func (v *TxnOffsetCommitRequest) IsFlexible() bool           { return v.Version >= 3 }
func (v *TxnOffsetCommitRequest) IsGroupCoordinatorRequest() {}
func (v *TxnOffsetCommitRequest) ResponseKind() Response {
	return &TxnOffsetCommitResponse{Version: v.Version}
}

func (v *TxnOffsetCommitRequest) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	isFlexible := version >= 3
	_ = isFlexible
	{
		v := v.TransactionalID
		if isFlexible {
			dst = kbin.AppendCompactString(dst, v)
		} else {
			dst = kbin.AppendString(dst, v)
		}
	}
	{
		v := v.Group
		if isFlexible {
			dst = kbin.AppendCompactString(dst, v)
		} else {
			dst = kbin.AppendString(dst, v)
		}
	}
	{
		v := v.ProducerID
		dst = kbin.AppendInt64(dst, v)
	}
	{
		v := v.ProducerEpoch
		dst = kbin.AppendInt16(dst, v)
	}
	if version >= 3 {
		v := v.Generation
		dst = kbin.AppendInt32(dst, v)
	}
	if version >= 3 {
		v := v.MemberID
		if isFlexible {
			dst = kbin.AppendCompactString(dst, v)
		} else {
			dst = kbin.AppendString(dst, v)
		}
	}
	if version >= 3 {
		v := v.InstanceID
		if isFlexible {
			dst = kbin.AppendCompactNullableString(dst, v)
		} else {
			dst = kbin.AppendNullableString(dst, v)
		}
	}
	{
		v := v.Topics
		if isFlexible {
			dst = kbin.AppendCompactArrayLen(dst, len(v))
		} else {
			dst = kbin.AppendArrayLen(dst, len(v))
		}
		for i := range v {
			v := &v[i]
			{
				v := v.Topic
				if isFlexible {
					dst = kbin.AppendCompactString(dst, v)
				} else {
					dst = kbin.AppendString(dst, v)
				}
			}
			{
				v := v.Partitions
				if isFlexible {
					dst = kbin.AppendCompactArrayLen(dst, len(v))
				} else {
					dst = kbin.AppendArrayLen(dst, len(v))
				}
				for i := range v {
					v := &v[i]
					{
						v := v.Partition
						dst = kbin.AppendInt32(dst, v)
					}
					{
						v := v.Offset
						dst = kbin.AppendInt64(dst, v)
					}
					if version >= 2 {
						v := v.LeaderEpoch
						dst = kbin.AppendInt32(dst, v)
					}
					{
						v := v.Metadata
						if isFlexible {
							dst = kbin.AppendCompactNullableString(dst, v)
						} else {
							dst = kbin.AppendNullableString(dst, v)
						}
					}
					if isFlexible {
						dst = kbin.AppendUvarint(dst, 0)
					}
				}
			}
			if isFlexible {
				dst = kbin.AppendUvarint(dst, 0)
			}
		}
	}
	if isFlexible {
		dst = kbin.AppendUvarint(dst, 0)
	}
	return dst
}
func (v *TxnOffsetCommitRequest) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	isFlexible := version >= 3
	_ = isFlexible
	b := kbin.Reader{Src: src}
	s := v
	{
		var v string
		if isFlexible {
			v = b.CompactString()
		} else {
			v = b.String()
		}
		s.TransactionalID = v
	}
	{
		var v string
		if isFlexible {
			v = b.CompactString()
		} else {
			v = b.String()
		}
		s.Group = v
	}
	{
		v := b.Int64()
		s.ProducerID = v
	}
	{
		v := b.Int16()
		s.ProducerEpoch = v
	}
	if version >= 3 {
		v := b.Int32()
		s.Generation = v
	}
	if version >= 3 {
		var v string
		if isFlexible {
			v = b.CompactString()
		} else {
			v = b.String()
		}
		s.MemberID = v
	}
	if version >= 3 {
		var v *string
		if isFlexible {
			v = b.CompactNullableString()
		} else {
			v = b.NullableString()
		}
		s.InstanceID = v
	}
	{
		v := s.Topics
		a := v
		var l int32
		if isFlexible {
			l = b.CompactArrayLen()
		} else {
			l = b.ArrayLen()
		}
		if !b.Ok() {
			return b.Complete()
		}
		if l > 0 {
			a = make([]TxnOffsetCommitRequestTopic, l)
		}
		for i := int32(0); i < l; i++ {
			v := &a[i]
			s := v
			{
				var v string
				if isFlexible {
					v = b.CompactString()
				} else {
					v = b.String()
				}
				s.Topic = v
			}
			{
				v := s.Partitions
				a := v
				var l int32
				if isFlexible {
					l = b.CompactArrayLen()
				} else {
					l = b.ArrayLen()
				}
				if !b.Ok() {
					return b.Complete()
				}
				if l > 0 {
					a = make([]TxnOffsetCommitRequestTopicPartition, l)
				}
				for i := int32(0); i < l; i++ {
					v := &a[i]
					s := v
					{
						v := b.Int32()
						s.Partition = v
					}
					{
						v := b.Int64()
						s.Offset = v
					}
					if version >= 2 {
						v := b.Int32()
						s.LeaderEpoch = v
					}
					{
						var v *string
						if isFlexible {
							v = b.CompactNullableString()
						} else {
							v = b.NullableString()
						}
						s.Metadata = v
					}
					if isFlexible {
						SkipTags(&b)
					}
				}
				v = a
				s.Partitions = v
			}
			if isFlexible {
				SkipTags(&b)
			}
		}
		v = a
		s.Topics = v
	}
	if isFlexible {
		SkipTags(&b)
	}
	return b.Complete()
}

type TxnOffsetCommitResponseTopicPartition struct {
	// Partition is the partition this response is for.
	Partition int32

	// ErrorCode is any error for this topic/partition commit.
	//
	// TRANSACTIONAL_ID_AUTHORIZATION_FAILED is returned if the client is
	// not authorized for write with transactional IDs with the requested
	// transactional ID.
	//
	// GROUP_AUTHORIZATION_FAILED is returned if the client is not authorized
	// to read group with the requested group id.
	//
	// TOPIC_AUTHORIZATION_FAILED is returned for all topics that the client
	// is not authorized to read.
	//
	// UNKNOWN_TOPIC_OR_PARTITION is returned for all topics or partitions
	// that the broker does not know of.
	//
	// INVALID_GROUP_ID is returned if the requested group does not exist.
	//
	// COORDINATOR_NOT_AVAILABLE is returned if the broker is not yet fully
	// started or is shutting down, or if the group was just deleted or is
	// migrating to another broker.
	//
	// COORDINATOR_LOAD_IN_PROGRESS is returned if the group is still loading.
	//
	// NOT_COORDINATOR is returned if the broker is not the coordinator for
	// the group.
	//
	// FENCED_INSTANCE_ID is returned if the member is fenced (another newer
	// transactional member is using the same instance ID).
	//
	// UNKNOWN_MEMBER_ID is returned if the consumer group does not know of
	// this member.
	//
	// ILLEGAL_GENERATION is returned if the consumer group's generation is
	// different than the requested generation.
	//
	// OFFSET_METADATA_TOO_LARGE is returned if the commit metadata is too
	// large.
	//
	// REBALANCE_IN_PROGRESS is returned if the group is completing a rebalance.
	ErrorCode int16
}
type TxnOffsetCommitResponseTopic struct {
	// Topic is the topic this response is for.
	Topic string

	// Partitions contains responses to the partitions in this topic.
	Partitions []TxnOffsetCommitResponseTopicPartition
}

// TxnOffsetCommitResponse is a response to a TxnOffsetCommitRequest.
type TxnOffsetCommitResponse struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	// ThrottleMillis is how long of a throttle Kafka will apply to the client
	// after this request.
	// For Kafka < 2.0.0, the throttle is applied before issuing a response.
	// For Kafka >= 2.0.0, the throttle is applied after issuing a response.
	ThrottleMillis int32

	// Topics contains responses to the topics in the request.
	Topics []TxnOffsetCommitResponseTopic
}

func (*TxnOffsetCommitResponse) Key() int16                 { return 28 }
func (*TxnOffsetCommitResponse) MaxVersion() int16          { return 3 }
func (v *TxnOffsetCommitResponse) SetVersion(version int16) { v.Version = version }
func (v *TxnOffsetCommitResponse) GetVersion() int16        { return v.Version }
func (v *TxnOffsetCommitResponse) IsFlexible() bool         { return v.Version >= 3 }
func (v *TxnOffsetCommitResponse) RequestKind() Request {
	return &TxnOffsetCommitRequest{Version: v.Version}
}

func (v *TxnOffsetCommitResponse) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	isFlexible := version >= 3
	_ = isFlexible
	{
		v := v.ThrottleMillis
		dst = kbin.AppendInt32(dst, v)
	}
	{
		v := v.Topics
		if isFlexible {
			dst = kbin.AppendCompactArrayLen(dst, len(v))
		} else {
			dst = kbin.AppendArrayLen(dst, len(v))
		}
		for i := range v {
			v := &v[i]
			{
				v := v.Topic
				if isFlexible {
					dst = kbin.AppendCompactString(dst, v)
				} else {
					dst = kbin.AppendString(dst, v)
				}
			}
			{
				v := v.Partitions
				if isFlexible {
					dst = kbin.AppendCompactArrayLen(dst, len(v))
				} else {
					dst = kbin.AppendArrayLen(dst, len(v))
				}
				for i := range v {
					v := &v[i]
					{
						v := v.Partition
						dst = kbin.AppendInt32(dst, v)
					}
					{
						v := v.ErrorCode
						dst = kbin.AppendInt16(dst, v)
					}
					if isFlexible {
						dst = kbin.AppendUvarint(dst, 0)
					}
				}
			}
			if isFlexible {
				dst = kbin.AppendUvarint(dst, 0)
			}
		}
	}
	if isFlexible {
		dst = kbin.AppendUvarint(dst, 0)
	}
	return dst
}
func (v *TxnOffsetCommitResponse) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	isFlexible := version >= 3
	_ = isFlexible
	b := kbin.Reader{Src: src}
	s := v
	{
		v := b.Int32()
		s.ThrottleMillis = v
	}
	{
		v := s.Topics
		a := v
		var l int32
		if isFlexible {
			l = b.CompactArrayLen()
		} else {
			l = b.ArrayLen()
		}
		if !b.Ok() {
			return b.Complete()
		}
		if l > 0 {
			a = make([]TxnOffsetCommitResponseTopic, l)
		}
		for i := int32(0); i < l; i++ {
			v := &a[i]
			s := v
			{
				var v string
				if isFlexible {
					v = b.CompactString()
				} else {
					v = b.String()
				}
				s.Topic = v
			}
			{
				v := s.Partitions
				a := v
				var l int32
				if isFlexible {
					l = b.CompactArrayLen()
				} else {
					l = b.ArrayLen()
				}
				if !b.Ok() {
					return b.Complete()
				}
				if l > 0 {
					a = make([]TxnOffsetCommitResponseTopicPartition, l)
				}
				for i := int32(0); i < l; i++ {
					v := &a[i]
					s := v
					{
						v := b.Int32()
						s.Partition = v
					}
					{
						v := b.Int16()
						s.ErrorCode = v
					}
					if isFlexible {
						SkipTags(&b)
					}
				}
				v = a
				s.Partitions = v
			}
			if isFlexible {
				SkipTags(&b)
			}
		}
		v = a
		s.Topics = v
	}
	if isFlexible {
		SkipTags(&b)
	}
	return b.Complete()
}

// DescribeACLsRequest describes ACLs. Describing ACLs works on a filter basis:
// anything that matches the filter is described. Note that there are two
// "types" of filters in this request: the resource filter and the entry
// filter, with entries corresponding to users. The first three fields form the
// resource filter, the last four the entry filter.
type DescribeACLsRequest struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	// ResourceType is the type of resource to describe.
	//
	// UNKNOWN, 0, is unknown; you do not describe unknown types. Kafka replies
	// with unknown if it does not understand your type. ANY, 1 will match any
	// other type.
	//
	// Past these two, the following types filter for an individual type:
	// TOPIC is 2, GROUP is 3, CLUSTER is 4, TRANSACTIONAL_ID is 5, and
	// DELEGATION_TOKEN is 6.
	ResourceType int8

	// ResourceName is the name to filter out. For the CLUSTER resource type,
	// this must be "kafka-cluster".
	ResourceName *string

	// ResourcePatternType is how ResourceName is understood. UNKNOWN is 0 and is
	// meaningless in the request.
	//
	// MATCH is 1, which will match anything.
	//
	// LITERAL is 2, meaning the name must be an exact match.
	//
	// PREFIXED is 3, meaning a resource name must have our requested resource
	// name as a prefix. That is, topic "foobar" will match "foo".
	//
	// This field was added with Kafka 2.0.0 for KIP-290; the default during
	// creating is 2.
	ResourcePatternType int8 // v1+

	// Principal is the user to filter for. In Kafka with the simple authorizor,
	// all principals begin with "User:". Pluggable authorizors are allowed, but
	// Kafka still expects principals to lead with a principal type ("User") and
	// have a colon separating the principal name ("bob" in "User:bob").
	Principal *string

	// Host is a host to filter for.
	Host *string

	// Operation is an operation to filter for. UNKNOWN is 0.
	//
	// ANY is 1 and matches anything, otherwise... ALL is 2 and matches anything
	// granted ALL permissions, READ is 3, WRITE is 4, CREATE is 5, DELETE is 6,
	// ALTER is 7 DESCRIBE is 8, CLUSTER_ACTION is 9, DESCRIBE_CONFIGS is 10,
	// ALTER_CONFIGS is 11, and IDEMPOTENT_WRITE is 12.
	//
	// Note that READ, WRITE, DELETE, and ALTER imply DESCRIBE, and ALTER_CONFIGS
	// implies DESCRIBE_CONFIGS.
	Operation int8

	// PermissionType is the permission type to filter for. UNKNOWN is 0.
	//
	// ANY is 1 and matches anything, otherwise DENY (2) matches all deny
	// permissions and ALLOW (3) matches all allow permissions.
	PermissionType int8
}

func (*DescribeACLsRequest) Key() int16                 { return 29 }
func (*DescribeACLsRequest) MaxVersion() int16          { return 2 }
func (v *DescribeACLsRequest) SetVersion(version int16) { v.Version = version }
func (v *DescribeACLsRequest) GetVersion() int16        { return v.Version }
func (v *DescribeACLsRequest) IsFlexible() bool         { return v.Version >= 2 }
func (v *DescribeACLsRequest) ResponseKind() Response {
	return &DescribeACLsResponse{Version: v.Version}
}

func (v *DescribeACLsRequest) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	isFlexible := version >= 2
	_ = isFlexible
	{
		v := v.ResourceType
		dst = kbin.AppendInt8(dst, v)
	}
	{
		v := v.ResourceName
		if isFlexible {
			dst = kbin.AppendCompactNullableString(dst, v)
		} else {
			dst = kbin.AppendNullableString(dst, v)
		}
	}
	if version >= 1 {
		v := v.ResourcePatternType
		dst = kbin.AppendInt8(dst, v)
	}
	{
		v := v.Principal
		if isFlexible {
			dst = kbin.AppendCompactNullableString(dst, v)
		} else {
			dst = kbin.AppendNullableString(dst, v)
		}
	}
	{
		v := v.Host
		if isFlexible {
			dst = kbin.AppendCompactNullableString(dst, v)
		} else {
			dst = kbin.AppendNullableString(dst, v)
		}
	}
	{
		v := v.Operation
		dst = kbin.AppendInt8(dst, v)
	}
	{
		v := v.PermissionType
		dst = kbin.AppendInt8(dst, v)
	}
	if isFlexible {
		dst = kbin.AppendUvarint(dst, 0)
	}
	return dst
}
func (v *DescribeACLsRequest) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	isFlexible := version >= 2
	_ = isFlexible
	b := kbin.Reader{Src: src}
	s := v
	{
		v := b.Int8()
		s.ResourceType = v
	}
	{
		var v *string
		if isFlexible {
			v = b.CompactNullableString()
		} else {
			v = b.NullableString()
		}
		s.ResourceName = v
	}
	if version >= 1 {
		v := b.Int8()
		s.ResourcePatternType = v
	}
	{
		var v *string
		if isFlexible {
			v = b.CompactNullableString()
		} else {
			v = b.NullableString()
		}
		s.Principal = v
	}
	{
		var v *string
		if isFlexible {
			v = b.CompactNullableString()
		} else {
			v = b.NullableString()
		}
		s.Host = v
	}
	{
		v := b.Int8()
		s.Operation = v
	}
	{
		v := b.Int8()
		s.PermissionType = v
	}
	if isFlexible {
		SkipTags(&b)
	}
	return b.Complete()
}

type DescribeACLsResponseResourceACL struct {
	// Principal is who this ACL applies to.
	Principal string

	// Host is on which host this ACL applies.
	Host string

	// Operation is the operation being described.
	Operation int8

	// PermissionType is the permission being described.
	PermissionType int8
}
type DescribeACLsResponseResource struct {
	// ResourceType is the resource type being described.
	ResourceType int8

	// ResourceName is the resource name being described.
	ResourceName string

	// ResourcePatternType is the pattern type being described.
	ResourcePatternType int8 // v1+

	// ACLs contains users / entries being described.
	ACLs []DescribeACLsResponseResourceACL
}

// DescribeACLsResponse is a response to a describe acls request.
type DescribeACLsResponse struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	// ThrottleMillis is how long of a throttle Kafka will apply to the client
	// after responding to this request.
	ThrottleMillis int32

	// ErrorCode is the error code returned on request failure.
	//
	// SECURITY_DISABLED is returned if there is no authorizer configured on the
	// broker.
	//
	// There can be other authorization failures.
	ErrorCode int16

	// ErrorMessage is a message for an error.
	ErrorMessage *string

	// Resources are the describe resources.
	Resources []DescribeACLsResponseResource
}

func (*DescribeACLsResponse) Key() int16                 { return 29 }
func (*DescribeACLsResponse) MaxVersion() int16          { return 2 }
func (v *DescribeACLsResponse) SetVersion(version int16) { v.Version = version }
func (v *DescribeACLsResponse) GetVersion() int16        { return v.Version }
func (v *DescribeACLsResponse) IsFlexible() bool         { return v.Version >= 2 }
func (v *DescribeACLsResponse) RequestKind() Request     { return &DescribeACLsRequest{Version: v.Version} }

func (v *DescribeACLsResponse) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	isFlexible := version >= 2
	_ = isFlexible
	{
		v := v.ThrottleMillis
		dst = kbin.AppendInt32(dst, v)
	}
	{
		v := v.ErrorCode
		dst = kbin.AppendInt16(dst, v)
	}
	{
		v := v.ErrorMessage
		if isFlexible {
			dst = kbin.AppendCompactNullableString(dst, v)
		} else {
			dst = kbin.AppendNullableString(dst, v)
		}
	}
	{
		v := v.Resources
		if isFlexible {
			dst = kbin.AppendCompactArrayLen(dst, len(v))
		} else {
			dst = kbin.AppendArrayLen(dst, len(v))
		}
		for i := range v {
			v := &v[i]
			{
				v := v.ResourceType
				dst = kbin.AppendInt8(dst, v)
			}
			{
				v := v.ResourceName
				if isFlexible {
					dst = kbin.AppendCompactString(dst, v)
				} else {
					dst = kbin.AppendString(dst, v)
				}
			}
			if version >= 1 {
				v := v.ResourcePatternType
				dst = kbin.AppendInt8(dst, v)
			}
			{
				v := v.ACLs
				if isFlexible {
					dst = kbin.AppendCompactArrayLen(dst, len(v))
				} else {
					dst = kbin.AppendArrayLen(dst, len(v))
				}
				for i := range v {
					v := &v[i]
					{
						v := v.Principal
						if isFlexible {
							dst = kbin.AppendCompactString(dst, v)
						} else {
							dst = kbin.AppendString(dst, v)
						}
					}
					{
						v := v.Host
						if isFlexible {
							dst = kbin.AppendCompactString(dst, v)
						} else {
							dst = kbin.AppendString(dst, v)
						}
					}
					{
						v := v.Operation
						dst = kbin.AppendInt8(dst, v)
					}
					{
						v := v.PermissionType
						dst = kbin.AppendInt8(dst, v)
					}
					if isFlexible {
						dst = kbin.AppendUvarint(dst, 0)
					}
				}
			}
			if isFlexible {
				dst = kbin.AppendUvarint(dst, 0)
			}
		}
	}
	if isFlexible {
		dst = kbin.AppendUvarint(dst, 0)
	}
	return dst
}
func (v *DescribeACLsResponse) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	isFlexible := version >= 2
	_ = isFlexible
	b := kbin.Reader{Src: src}
	s := v
	{
		v := b.Int32()
		s.ThrottleMillis = v
	}
	{
		v := b.Int16()
		s.ErrorCode = v
	}
	{
		var v *string
		if isFlexible {
			v = b.CompactNullableString()
		} else {
			v = b.NullableString()
		}
		s.ErrorMessage = v
	}
	{
		v := s.Resources
		a := v
		var l int32
		if isFlexible {
			l = b.CompactArrayLen()
		} else {
			l = b.ArrayLen()
		}
		if !b.Ok() {
			return b.Complete()
		}
		if l > 0 {
			a = make([]DescribeACLsResponseResource, l)
		}
		for i := int32(0); i < l; i++ {
			v := &a[i]
			s := v
			{
				v := b.Int8()
				s.ResourceType = v
			}
			{
				var v string
				if isFlexible {
					v = b.CompactString()
				} else {
					v = b.String()
				}
				s.ResourceName = v
			}
			if version >= 1 {
				v := b.Int8()
				s.ResourcePatternType = v
			}
			{
				v := s.ACLs
				a := v
				var l int32
				if isFlexible {
					l = b.CompactArrayLen()
				} else {
					l = b.ArrayLen()
				}
				if !b.Ok() {
					return b.Complete()
				}
				if l > 0 {
					a = make([]DescribeACLsResponseResourceACL, l)
				}
				for i := int32(0); i < l; i++ {
					v := &a[i]
					s := v
					{
						var v string
						if isFlexible {
							v = b.CompactString()
						} else {
							v = b.String()
						}
						s.Principal = v
					}
					{
						var v string
						if isFlexible {
							v = b.CompactString()
						} else {
							v = b.String()
						}
						s.Host = v
					}
					{
						v := b.Int8()
						s.Operation = v
					}
					{
						v := b.Int8()
						s.PermissionType = v
					}
					if isFlexible {
						SkipTags(&b)
					}
				}
				v = a
				s.ACLs = v
			}
			if isFlexible {
				SkipTags(&b)
			}
		}
		v = a
		s.Resources = v
	}
	if isFlexible {
		SkipTags(&b)
	}
	return b.Complete()
}

type CreateACLsRequestCreation struct {
	// ResourceType is the type of resource this acl entry will be on.
	// It is invalid to use UNKNOWN or ANY.
	ResourceType int8

	// ResourceName is the name of the resource this acl entry will be on.
	// For CLUSTER, this must be "kafka-cluster".
	ResourceName string

	// ResourcePatternType is the pattern type to use for the resource name.
	// This cannot be UNKNOWN or MATCH (i.e. this must be LITERAL or PREFIXED).
	// The default for pre-Kafka 2.0.0 is effectively LITERAL.
	ResourcePatternType int8 // v1+

	// Principal is the user to apply this acl for. With the Kafka simple
	// authorizer, this must begin with "User:".
	Principal string

	// Host is the host address to use for this acl. Yes, each host to allow
	// the principal access from must be specified as a new creation. KIP-252
	// might solve this someday. The special wildcard host "*" allows all hosts.
	Host string

	// Operation is the operation this acl is for. This must not be UNKNOWN or
	// ANY.
	Operation int8

	// PermissionType is the permission of this acl. This must be either ALLOW
	// or DENY.
	PermissionType int8
}

// CreateACLsRequest creates acls. Creating acls can be done as a batch; each
// "creation" will be an acl entry.
//
// See the DescribeACLsRequest documentation for more descriptions of what
// valid values for the fields in this request are.
type CreateACLsRequest struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	Creations []CreateACLsRequestCreation
}

func (*CreateACLsRequest) Key() int16                 { return 30 }
func (*CreateACLsRequest) MaxVersion() int16          { return 2 }
func (v *CreateACLsRequest) SetVersion(version int16) { v.Version = version }
func (v *CreateACLsRequest) GetVersion() int16        { return v.Version }
func (v *CreateACLsRequest) IsFlexible() bool         { return v.Version >= 2 }
func (v *CreateACLsRequest) ResponseKind() Response   { return &CreateACLsResponse{Version: v.Version} }

func (v *CreateACLsRequest) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	isFlexible := version >= 2
	_ = isFlexible
	{
		v := v.Creations
		if isFlexible {
			dst = kbin.AppendCompactArrayLen(dst, len(v))
		} else {
			dst = kbin.AppendArrayLen(dst, len(v))
		}
		for i := range v {
			v := &v[i]
			{
				v := v.ResourceType
				dst = kbin.AppendInt8(dst, v)
			}
			{
				v := v.ResourceName
				if isFlexible {
					dst = kbin.AppendCompactString(dst, v)
				} else {
					dst = kbin.AppendString(dst, v)
				}
			}
			if version >= 1 {
				v := v.ResourcePatternType
				dst = kbin.AppendInt8(dst, v)
			}
			{
				v := v.Principal
				if isFlexible {
					dst = kbin.AppendCompactString(dst, v)
				} else {
					dst = kbin.AppendString(dst, v)
				}
			}
			{
				v := v.Host
				if isFlexible {
					dst = kbin.AppendCompactString(dst, v)
				} else {
					dst = kbin.AppendString(dst, v)
				}
			}
			{
				v := v.Operation
				dst = kbin.AppendInt8(dst, v)
			}
			{
				v := v.PermissionType
				dst = kbin.AppendInt8(dst, v)
			}
			if isFlexible {
				dst = kbin.AppendUvarint(dst, 0)
			}
		}
	}
	if isFlexible {
		dst = kbin.AppendUvarint(dst, 0)
	}
	return dst
}
func (v *CreateACLsRequest) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	isFlexible := version >= 2
	_ = isFlexible
	b := kbin.Reader{Src: src}
	s := v
	{
		v := s.Creations
		a := v
		var l int32
		if isFlexible {
			l = b.CompactArrayLen()
		} else {
			l = b.ArrayLen()
		}
		if !b.Ok() {
			return b.Complete()
		}
		if l > 0 {
			a = make([]CreateACLsRequestCreation, l)
		}
		for i := int32(0); i < l; i++ {
			v := &a[i]
			s := v
			{
				v := b.Int8()
				s.ResourceType = v
			}
			{
				var v string
				if isFlexible {
					v = b.CompactString()
				} else {
					v = b.String()
				}
				s.ResourceName = v
			}
			if version >= 1 {
				v := b.Int8()
				s.ResourcePatternType = v
			}
			{
				var v string
				if isFlexible {
					v = b.CompactString()
				} else {
					v = b.String()
				}
				s.Principal = v
			}
			{
				var v string
				if isFlexible {
					v = b.CompactString()
				} else {
					v = b.String()
				}
				s.Host = v
			}
			{
				v := b.Int8()
				s.Operation = v
			}
			{
				v := b.Int8()
				s.PermissionType = v
			}
			if isFlexible {
				SkipTags(&b)
			}
		}
		v = a
		s.Creations = v
	}
	if isFlexible {
		SkipTags(&b)
	}
	return b.Complete()
}

type CreateACLsResponseResult struct {
	// ErrorCode is an error for this particular creation (index wise).
	ErrorCode int16

	// ErrorMessage is a message for this error.
	ErrorMessage *string
}

// CreateACLsResponse is a response for a CreateACLsRequest.
type CreateACLsResponse struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	// ThrottleMillis is how long of a throttle Kafka will apply to the client
	// after responding to this request.
	ThrottleMillis int32

	// Results contains responses to each creation request.
	Results []CreateACLsResponseResult
}

func (*CreateACLsResponse) Key() int16                 { return 30 }
func (*CreateACLsResponse) MaxVersion() int16          { return 2 }
func (v *CreateACLsResponse) SetVersion(version int16) { v.Version = version }
func (v *CreateACLsResponse) GetVersion() int16        { return v.Version }
func (v *CreateACLsResponse) IsFlexible() bool         { return v.Version >= 2 }
func (v *CreateACLsResponse) RequestKind() Request     { return &CreateACLsRequest{Version: v.Version} }

func (v *CreateACLsResponse) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	isFlexible := version >= 2
	_ = isFlexible
	{
		v := v.ThrottleMillis
		dst = kbin.AppendInt32(dst, v)
	}
	{
		v := v.Results
		if isFlexible {
			dst = kbin.AppendCompactArrayLen(dst, len(v))
		} else {
			dst = kbin.AppendArrayLen(dst, len(v))
		}
		for i := range v {
			v := &v[i]
			{
				v := v.ErrorCode
				dst = kbin.AppendInt16(dst, v)
			}
			{
				v := v.ErrorMessage
				if isFlexible {
					dst = kbin.AppendCompactNullableString(dst, v)
				} else {
					dst = kbin.AppendNullableString(dst, v)
				}
			}
			if isFlexible {
				dst = kbin.AppendUvarint(dst, 0)
			}
		}
	}
	if isFlexible {
		dst = kbin.AppendUvarint(dst, 0)
	}
	return dst
}
func (v *CreateACLsResponse) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	isFlexible := version >= 2
	_ = isFlexible
	b := kbin.Reader{Src: src}
	s := v
	{
		v := b.Int32()
		s.ThrottleMillis = v
	}
	{
		v := s.Results
		a := v
		var l int32
		if isFlexible {
			l = b.CompactArrayLen()
		} else {
			l = b.ArrayLen()
		}
		if !b.Ok() {
			return b.Complete()
		}
		if l > 0 {
			a = make([]CreateACLsResponseResult, l)
		}
		for i := int32(0); i < l; i++ {
			v := &a[i]
			s := v
			{
				v := b.Int16()
				s.ErrorCode = v
			}
			{
				var v *string
				if isFlexible {
					v = b.CompactNullableString()
				} else {
					v = b.NullableString()
				}
				s.ErrorMessage = v
			}
			if isFlexible {
				SkipTags(&b)
			}
		}
		v = a
		s.Results = v
	}
	if isFlexible {
		SkipTags(&b)
	}
	return b.Complete()
}

type DeleteACLsRequestFilter struct {
	ResourceType int8

	ResourceName *string

	ResourcePatternType int8 // v1+

	Principal *string

	Host *string

	Operation int8

	PermissionType int8
}

// DeleteACLsRequest deletes acls. This request works on filters the same way
// that DescribeACLsRequest does. See DescribeACLsRequest for documentation of
// the fields.
type DeleteACLsRequest struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	// Filters are filters for acls to delete.
	Filters []DeleteACLsRequestFilter
}

func (*DeleteACLsRequest) Key() int16                 { return 31 }
func (*DeleteACLsRequest) MaxVersion() int16          { return 2 }
func (v *DeleteACLsRequest) SetVersion(version int16) { v.Version = version }
func (v *DeleteACLsRequest) GetVersion() int16        { return v.Version }
func (v *DeleteACLsRequest) IsFlexible() bool         { return v.Version >= 2 }
func (v *DeleteACLsRequest) ResponseKind() Response   { return &DeleteACLsResponse{Version: v.Version} }

func (v *DeleteACLsRequest) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	isFlexible := version >= 2
	_ = isFlexible
	{
		v := v.Filters
		if isFlexible {
			dst = kbin.AppendCompactArrayLen(dst, len(v))
		} else {
			dst = kbin.AppendArrayLen(dst, len(v))
		}
		for i := range v {
			v := &v[i]
			{
				v := v.ResourceType
				dst = kbin.AppendInt8(dst, v)
			}
			{
				v := v.ResourceName
				if isFlexible {
					dst = kbin.AppendCompactNullableString(dst, v)
				} else {
					dst = kbin.AppendNullableString(dst, v)
				}
			}
			if version >= 1 {
				v := v.ResourcePatternType
				dst = kbin.AppendInt8(dst, v)
			}
			{
				v := v.Principal
				if isFlexible {
					dst = kbin.AppendCompactNullableString(dst, v)
				} else {
					dst = kbin.AppendNullableString(dst, v)
				}
			}
			{
				v := v.Host
				if isFlexible {
					dst = kbin.AppendCompactNullableString(dst, v)
				} else {
					dst = kbin.AppendNullableString(dst, v)
				}
			}
			{
				v := v.Operation
				dst = kbin.AppendInt8(dst, v)
			}
			{
				v := v.PermissionType
				dst = kbin.AppendInt8(dst, v)
			}
			if isFlexible {
				dst = kbin.AppendUvarint(dst, 0)
			}
		}
	}
	if isFlexible {
		dst = kbin.AppendUvarint(dst, 0)
	}
	return dst
}
func (v *DeleteACLsRequest) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	isFlexible := version >= 2
	_ = isFlexible
	b := kbin.Reader{Src: src}
	s := v
	{
		v := s.Filters
		a := v
		var l int32
		if isFlexible {
			l = b.CompactArrayLen()
		} else {
			l = b.ArrayLen()
		}
		if !b.Ok() {
			return b.Complete()
		}
		if l > 0 {
			a = make([]DeleteACLsRequestFilter, l)
		}
		for i := int32(0); i < l; i++ {
			v := &a[i]
			s := v
			{
				v := b.Int8()
				s.ResourceType = v
			}
			{
				var v *string
				if isFlexible {
					v = b.CompactNullableString()
				} else {
					v = b.NullableString()
				}
				s.ResourceName = v
			}
			if version >= 1 {
				v := b.Int8()
				s.ResourcePatternType = v
			}
			{
				var v *string
				if isFlexible {
					v = b.CompactNullableString()
				} else {
					v = b.NullableString()
				}
				s.Principal = v
			}
			{
				var v *string
				if isFlexible {
					v = b.CompactNullableString()
				} else {
					v = b.NullableString()
				}
				s.Host = v
			}
			{
				v := b.Int8()
				s.Operation = v
			}
			{
				v := b.Int8()
				s.PermissionType = v
			}
			if isFlexible {
				SkipTags(&b)
			}
		}
		v = a
		s.Filters = v
	}
	if isFlexible {
		SkipTags(&b)
	}
	return b.Complete()
}

type DeleteACLsResponseResultMatchingACL struct {
	// ErrorCode contains an error for this individual acl for this filter.
	ErrorCode int16

	// ErrorMessage is a message for this error.
	ErrorMessage *string

	ResourceType int8

	ResourceName string

	ResourcePatternType int8 // v1+

	Principal string

	Host string

	Operation int8

	PermissionType int8
}
type DeleteACLsResponseResult struct {
	// ErrorCode is the overall error code for this individual filter.
	ErrorCode int16

	// ErrorMessage is a message for this error.
	ErrorMessage *string

	// MatchingACLs contains all acls that were matched for this filter.
	MatchingACLs []DeleteACLsResponseResultMatchingACL
}

// DeleteACLsResponse is a response for a DeleteACLsRequest.
type DeleteACLsResponse struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	// ThrottleMillis is how long of a throttle Kafka will apply to the client
	// after responding to this request.
	ThrottleMillis int32

	// Results contains a response to each requested filter.
	Results []DeleteACLsResponseResult
}

func (*DeleteACLsResponse) Key() int16                 { return 31 }
func (*DeleteACLsResponse) MaxVersion() int16          { return 2 }
func (v *DeleteACLsResponse) SetVersion(version int16) { v.Version = version }
func (v *DeleteACLsResponse) GetVersion() int16        { return v.Version }
func (v *DeleteACLsResponse) IsFlexible() bool         { return v.Version >= 2 }
func (v *DeleteACLsResponse) RequestKind() Request     { return &DeleteACLsRequest{Version: v.Version} }

func (v *DeleteACLsResponse) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	isFlexible := version >= 2
	_ = isFlexible
	{
		v := v.ThrottleMillis
		dst = kbin.AppendInt32(dst, v)
	}
	{
		v := v.Results
		if isFlexible {
			dst = kbin.AppendCompactArrayLen(dst, len(v))
		} else {
			dst = kbin.AppendArrayLen(dst, len(v))
		}
		for i := range v {
			v := &v[i]
			{
				v := v.ErrorCode
				dst = kbin.AppendInt16(dst, v)
			}
			{
				v := v.ErrorMessage
				if isFlexible {
					dst = kbin.AppendCompactNullableString(dst, v)
				} else {
					dst = kbin.AppendNullableString(dst, v)
				}
			}
			{
				v := v.MatchingACLs
				if isFlexible {
					dst = kbin.AppendCompactArrayLen(dst, len(v))
				} else {
					dst = kbin.AppendArrayLen(dst, len(v))
				}
				for i := range v {
					v := &v[i]
					{
						v := v.ErrorCode
						dst = kbin.AppendInt16(dst, v)
					}
					{
						v := v.ErrorMessage
						if isFlexible {
							dst = kbin.AppendCompactNullableString(dst, v)
						} else {
							dst = kbin.AppendNullableString(dst, v)
						}
					}
					{
						v := v.ResourceType
						dst = kbin.AppendInt8(dst, v)
					}
					{
						v := v.ResourceName
						if isFlexible {
							dst = kbin.AppendCompactString(dst, v)
						} else {
							dst = kbin.AppendString(dst, v)
						}
					}
					if version >= 1 {
						v := v.ResourcePatternType
						dst = kbin.AppendInt8(dst, v)
					}
					{
						v := v.Principal
						if isFlexible {
							dst = kbin.AppendCompactString(dst, v)
						} else {
							dst = kbin.AppendString(dst, v)
						}
					}
					{
						v := v.Host
						if isFlexible {
							dst = kbin.AppendCompactString(dst, v)
						} else {
							dst = kbin.AppendString(dst, v)
						}
					}
					{
						v := v.Operation
						dst = kbin.AppendInt8(dst, v)
					}
					{
						v := v.PermissionType
						dst = kbin.AppendInt8(dst, v)
					}
					if isFlexible {
						dst = kbin.AppendUvarint(dst, 0)
					}
				}
			}
			if isFlexible {
				dst = kbin.AppendUvarint(dst, 0)
			}
		}
	}
	if isFlexible {
		dst = kbin.AppendUvarint(dst, 0)
	}
	return dst
}
func (v *DeleteACLsResponse) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	isFlexible := version >= 2
	_ = isFlexible
	b := kbin.Reader{Src: src}
	s := v
	{
		v := b.Int32()
		s.ThrottleMillis = v
	}
	{
		v := s.Results
		a := v
		var l int32
		if isFlexible {
			l = b.CompactArrayLen()
		} else {
			l = b.ArrayLen()
		}
		if !b.Ok() {
			return b.Complete()
		}
		if l > 0 {
			a = make([]DeleteACLsResponseResult, l)
		}
		for i := int32(0); i < l; i++ {
			v := &a[i]
			s := v
			{
				v := b.Int16()
				s.ErrorCode = v
			}
			{
				var v *string
				if isFlexible {
					v = b.CompactNullableString()
				} else {
					v = b.NullableString()
				}
				s.ErrorMessage = v
			}
			{
				v := s.MatchingACLs
				a := v
				var l int32
				if isFlexible {
					l = b.CompactArrayLen()
				} else {
					l = b.ArrayLen()
				}
				if !b.Ok() {
					return b.Complete()
				}
				if l > 0 {
					a = make([]DeleteACLsResponseResultMatchingACL, l)
				}
				for i := int32(0); i < l; i++ {
					v := &a[i]
					s := v
					{
						v := b.Int16()
						s.ErrorCode = v
					}
					{
						var v *string
						if isFlexible {
							v = b.CompactNullableString()
						} else {
							v = b.NullableString()
						}
						s.ErrorMessage = v
					}
					{
						v := b.Int8()
						s.ResourceType = v
					}
					{
						var v string
						if isFlexible {
							v = b.CompactString()
						} else {
							v = b.String()
						}
						s.ResourceName = v
					}
					if version >= 1 {
						v := b.Int8()
						s.ResourcePatternType = v
					}
					{
						var v string
						if isFlexible {
							v = b.CompactString()
						} else {
							v = b.String()
						}
						s.Principal = v
					}
					{
						var v string
						if isFlexible {
							v = b.CompactString()
						} else {
							v = b.String()
						}
						s.Host = v
					}
					{
						v := b.Int8()
						s.Operation = v
					}
					{
						v := b.Int8()
						s.PermissionType = v
					}
					if isFlexible {
						SkipTags(&b)
					}
				}
				v = a
				s.MatchingACLs = v
			}
			if isFlexible {
				SkipTags(&b)
			}
		}
		v = a
		s.Results = v
	}
	if isFlexible {
		SkipTags(&b)
	}
	return b.Complete()
}

type DescribeConfigsRequestResource struct {
	// ResourceType is an enum corresponding to the type of config to describe.
	// Valid values are 2 (topic), 4 (broker), or 8 (broker logger).
	ResourceType int8

	// ResourceName is the name of config to describe.
	//
	// If the requested type is a topic, this corresponds to a topic name.
	//
	// If the requested type if a broker, this should either be empty or be
	// the ID of the broker this request is issued to. If it is empty, this
	// returns all broker configs, but only the dynamic configuration values.
	// If a specific ID, this returns all broker config values.
	ResourceName string

	// ConfigNames is a list of config entries to return. Null requests all.
	ConfigNames []string
}

// DescribeConfigsRequest issues a request to describe configs that Kafka
// currently has. These are the key/value pairs that one uses to configure
// brokers and topics.
type DescribeConfigsRequest struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	// Resources is a list of resources to describe.
	Resources []DescribeConfigsRequestResource

	// IncludeSynonyms signifies whether to return config entry synonyms for
	// all config entries.
	IncludeSynonyms bool // v1+

	// IncludeDocumentation signifies whether to return documentation for
	// config entries.
	IncludeDocumentation bool // v3+
}

func (*DescribeConfigsRequest) Key() int16                 { return 32 }
func (*DescribeConfigsRequest) MaxVersion() int16          { return 3 }
func (v *DescribeConfigsRequest) SetVersion(version int16) { v.Version = version }
func (v *DescribeConfigsRequest) GetVersion() int16        { return v.Version }
func (v *DescribeConfigsRequest) IsFlexible() bool         { return false }
func (v *DescribeConfigsRequest) ResponseKind() Response {
	return &DescribeConfigsResponse{Version: v.Version}
}

func (v *DescribeConfigsRequest) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	{
		v := v.Resources
		dst = kbin.AppendArrayLen(dst, len(v))
		for i := range v {
			v := &v[i]
			{
				v := v.ResourceType
				dst = kbin.AppendInt8(dst, v)
			}
			{
				v := v.ResourceName
				dst = kbin.AppendString(dst, v)
			}
			{
				v := v.ConfigNames
				dst = kbin.AppendNullableArrayLen(dst, len(v), v == nil)
				for i := range v {
					v := v[i]
					dst = kbin.AppendString(dst, v)
				}
			}
		}
	}
	if version >= 1 {
		v := v.IncludeSynonyms
		dst = kbin.AppendBool(dst, v)
	}
	if version >= 3 {
		v := v.IncludeDocumentation
		dst = kbin.AppendBool(dst, v)
	}
	return dst
}
func (v *DescribeConfigsRequest) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	b := kbin.Reader{Src: src}
	s := v
	{
		v := s.Resources
		a := v
		var l int32
		l = b.ArrayLen()
		if !b.Ok() {
			return b.Complete()
		}
		if l > 0 {
			a = make([]DescribeConfigsRequestResource, l)
		}
		for i := int32(0); i < l; i++ {
			v := &a[i]
			s := v
			{
				v := b.Int8()
				s.ResourceType = v
			}
			{
				v := b.String()
				s.ResourceName = v
			}
			{
				v := s.ConfigNames
				a := v
				var l int32
				l = b.ArrayLen()
				if version < 0 || l == 0 {
					a = []string{}
				}
				if !b.Ok() {
					return b.Complete()
				}
				if l > 0 {
					a = make([]string, l)
				}
				for i := int32(0); i < l; i++ {
					v := b.String()
					a[i] = v
				}
				v = a
				s.ConfigNames = v
			}
		}
		v = a
		s.Resources = v
	}
	if version >= 1 {
		v := b.Bool()
		s.IncludeSynonyms = v
	}
	if version >= 3 {
		v := b.Bool()
		s.IncludeDocumentation = v
	}
	return b.Complete()
}

type DescribeConfigsResponseResourceConfigConfigSynonym struct {
	Name string

	Value *string

	Source int8
}
type DescribeConfigsResponseResourceConfig struct {
	// Name is a key this entry corresponds to (e.g. segment.bytes).
	Name string

	// Value is the value for this config key. If the key is sensitive,
	// the value will be null.
	Value *string

	// ReadOnly signifies whether this is not a dynamic config option.
	ReadOnly bool

	// IsDefault is whether this is a default config option. This has been
	// replaced in favor of Source.
	IsDefault bool

	// Source is where this config entry is from. Note that if there
	// are no config synonyms, the source is DEFAULT_CONFIG. The values of
	// this enum are as follows.
	//
	// UNKNOWN (0): unknown; e.g. an altar request was issued with no source set
	//
	// DYNAMIC_TOPIC_CONFIG (1): dynamic topic config for a specific topic
	//
	// DYNAMIC_BROKER_CONFIG (2): dynamic broker config for a specific broker
	//
	// DYNAMIC_DEFAULT_BROKER_CONFIG (3): dynamic broker config used as the default for all brokers in a cluster
	//
	// STATIC_BROKER_CONFIG (4): static broker config provided at start up
	//
	// DEFAULT_CONFIG (5): built-in default configuration for those that have defaults
	//
	// DYNAMIC_BROKER_LOGGER_CONFIG (6): broker logger; see KIP 412.
	Source int8 // v1+

	// IsSensitive signifies whether this is a sensitive config key, which
	// is either a password or an unknown type.
	IsSensitive bool

	// ConfigSynonyms contains config key/value pairs that can be used in
	// place of this config entry, in order of preference.
	ConfigSynonyms []DescribeConfigsResponseResourceConfigConfigSynonym // v1+

	// ConfigType specifies the configuration data type. The values of this
	// enum are as follows: UNKNOWN (0), BOOLEAN (1), STRING (2), INT (3),
	// SHORT (4), LONG (5), DOUBLE (6), LIST (7), CLASS (8), PASSWORD (9).
	ConfigType int8 // v3+

	// Documentation is optional documentation for the config entry.
	Documentation *string // v3+
}
type DescribeConfigsResponseResource struct {
	// ErrorCode is the error code returned for describing configs.
	//
	// INVALID_REQUEST is returned if asking to descibe an invalid resource
	// type.
	//
	// CLUSTER_AUTHORIZATION_FAILED is returned if asking to describe broker
	// configs but the client is not authorized to do so.
	//
	// TOPIC_AUTHORIZATION_FAILED is returned if asking to describe topic
	// configs but the client is not authorized to do so.
	//
	// INVALID_TOPIC_EXCEPTION is returned if the requested topic was invalid.
	//
	// UNKNOWN_TOPIC_OR_PARTITION is returned if the broker does not know of
	// the requested topic.
	ErrorCode int16

	// ErrorMessage is an informative message if the describe config failed.
	ErrorMessage *string

	// ResourceType is the enum corresponding to the type of described config.
	ResourceType int8

	// ResourceName is the name corresponding to the describe config request.
	ResourceName string

	// Configs contains information about key/value config pairs for
	// the requested resource.
	Configs []DescribeConfigsResponseResourceConfig
}

// DescribeConfigsResponse is returned from a DescribeConfigsRequest.
type DescribeConfigsResponse struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	// ThrottleMillis is how long of a throttle Kafka will apply to the client
	// after this request.
	// For Kafka < 2.0.0, the throttle is applied before issuing a response.
	// For Kafka >= 2.0.0, the throttle is applied after issuing a response.
	ThrottleMillis int32

	// Resources are responses for each resource in the describe config request.
	Resources []DescribeConfigsResponseResource
}

func (*DescribeConfigsResponse) Key() int16                 { return 32 }
func (*DescribeConfigsResponse) MaxVersion() int16          { return 3 }
func (v *DescribeConfigsResponse) SetVersion(version int16) { v.Version = version }
func (v *DescribeConfigsResponse) GetVersion() int16        { return v.Version }
func (v *DescribeConfigsResponse) IsFlexible() bool         { return false }
func (v *DescribeConfigsResponse) RequestKind() Request {
	return &DescribeConfigsRequest{Version: v.Version}
}

func (v *DescribeConfigsResponse) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	{
		v := v.ThrottleMillis
		dst = kbin.AppendInt32(dst, v)
	}
	{
		v := v.Resources
		dst = kbin.AppendArrayLen(dst, len(v))
		for i := range v {
			v := &v[i]
			{
				v := v.ErrorCode
				dst = kbin.AppendInt16(dst, v)
			}
			{
				v := v.ErrorMessage
				dst = kbin.AppendNullableString(dst, v)
			}
			{
				v := v.ResourceType
				dst = kbin.AppendInt8(dst, v)
			}
			{
				v := v.ResourceName
				dst = kbin.AppendString(dst, v)
			}
			{
				v := v.Configs
				dst = kbin.AppendArrayLen(dst, len(v))
				for i := range v {
					v := &v[i]
					{
						v := v.Name
						dst = kbin.AppendString(dst, v)
					}
					{
						v := v.Value
						dst = kbin.AppendNullableString(dst, v)
					}
					{
						v := v.ReadOnly
						dst = kbin.AppendBool(dst, v)
					}
					if version >= 0 && version <= 0 {
						v := v.IsDefault
						dst = kbin.AppendBool(dst, v)
					}
					if version >= 1 {
						v := v.Source
						dst = kbin.AppendInt8(dst, v)
					}
					{
						v := v.IsSensitive
						dst = kbin.AppendBool(dst, v)
					}
					if version >= 1 {
						v := v.ConfigSynonyms
						dst = kbin.AppendArrayLen(dst, len(v))
						for i := range v {
							v := &v[i]
							{
								v := v.Name
								dst = kbin.AppendString(dst, v)
							}
							{
								v := v.Value
								dst = kbin.AppendNullableString(dst, v)
							}
							{
								v := v.Source
								dst = kbin.AppendInt8(dst, v)
							}
						}
					}
					if version >= 3 {
						v := v.ConfigType
						dst = kbin.AppendInt8(dst, v)
					}
					if version >= 3 {
						v := v.Documentation
						dst = kbin.AppendNullableString(dst, v)
					}
				}
			}
		}
	}
	return dst
}
func (v *DescribeConfigsResponse) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	b := kbin.Reader{Src: src}
	s := v
	{
		v := b.Int32()
		s.ThrottleMillis = v
	}
	{
		v := s.Resources
		a := v
		var l int32
		l = b.ArrayLen()
		if !b.Ok() {
			return b.Complete()
		}
		if l > 0 {
			a = make([]DescribeConfigsResponseResource, l)
		}
		for i := int32(0); i < l; i++ {
			v := &a[i]
			s := v
			{
				v := b.Int16()
				s.ErrorCode = v
			}
			{
				v := b.NullableString()
				s.ErrorMessage = v
			}
			{
				v := b.Int8()
				s.ResourceType = v
			}
			{
				v := b.String()
				s.ResourceName = v
			}
			{
				v := s.Configs
				a := v
				var l int32
				l = b.ArrayLen()
				if !b.Ok() {
					return b.Complete()
				}
				if l > 0 {
					a = make([]DescribeConfigsResponseResourceConfig, l)
				}
				for i := int32(0); i < l; i++ {
					v := &a[i]
					s := v
					{
						v := b.String()
						s.Name = v
					}
					{
						v := b.NullableString()
						s.Value = v
					}
					{
						v := b.Bool()
						s.ReadOnly = v
					}
					if version >= 0 && version <= 0 {
						v := b.Bool()
						s.IsDefault = v
					}
					if version >= 1 {
						v := b.Int8()
						s.Source = v
					}
					{
						v := b.Bool()
						s.IsSensitive = v
					}
					if version >= 1 {
						v := s.ConfigSynonyms
						a := v
						var l int32
						l = b.ArrayLen()
						if !b.Ok() {
							return b.Complete()
						}
						if l > 0 {
							a = make([]DescribeConfigsResponseResourceConfigConfigSynonym, l)
						}
						for i := int32(0); i < l; i++ {
							v := &a[i]
							s := v
							{
								v := b.String()
								s.Name = v
							}
							{
								v := b.NullableString()
								s.Value = v
							}
							{
								v := b.Int8()
								s.Source = v
							}
						}
						v = a
						s.ConfigSynonyms = v
					}
					if version >= 3 {
						v := b.Int8()
						s.ConfigType = v
					}
					if version >= 3 {
						v := b.NullableString()
						s.Documentation = v
					}
				}
				v = a
				s.Configs = v
			}
		}
		v = a
		s.Resources = v
	}
	return b.Complete()
}

type AlterConfigsRequestResourceConfig struct {
	// Name is a key to set (e.g. segment.bytes).
	Name string

	// Value is a value to set for the key (e.g. 10).
	Value *string
}
type AlterConfigsRequestResource struct {
	// ResourceType is an enum corresponding to the type of config to alter.
	// The only two valid values are 2 (for topic) and 4 (for broker).
	ResourceType int8

	// ResourceName is the name of config to alter.
	//
	// If the requested type is a topic, this corresponds to a topic name.
	//
	// If the requested type if a broker, this should either be empty or be
	// the ID of the broker this request is issued to. If it is empty, this
	// updates all broker configs. If a specific ID, this updates just the
	// broker. Using a specific ID also ensures that brokers reload config
	// or secret files even if the file path has not changed. Lastly, password
	// config options can only be defined on a per broker basis.
	//
	// If the type is broker logger, this must be a broker ID.
	ResourceName string

	// Configs contains key/value config pairs to set on the resource.
	Configs []AlterConfigsRequestResourceConfig
}

// AlterConfigsRequest issues a request to alter either topic or broker
// configs.
//
// Note that to alter configs, you must specify the whole config on every
// request. All existing non-static values will be removed. This means that
// to add one key/value to a config, you must describe the config and then
// issue an alter request with the current config with the new key value.
// This also means that dynamic sensitive values, which are not returned
// in describe configs, will be lost.
//
// To fix this problem, the AlterConfigs request / response was deprecated
// in Kafka 2.3.0 in favor of the new IncrementalAlterConfigs request / response.
// See KIP-339 for more details.
type AlterConfigsRequest struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	// Resources is an array of configs to alter.
	Resources []AlterConfigsRequestResource

	// ValidateOnly validates the request but does not apply it.
	ValidateOnly bool
}

func (*AlterConfigsRequest) Key() int16                 { return 33 }
func (*AlterConfigsRequest) MaxVersion() int16          { return 1 }
func (v *AlterConfigsRequest) SetVersion(version int16) { v.Version = version }
func (v *AlterConfigsRequest) GetVersion() int16        { return v.Version }
func (v *AlterConfigsRequest) IsFlexible() bool         { return false }
func (v *AlterConfigsRequest) ResponseKind() Response {
	return &AlterConfigsResponse{Version: v.Version}
}

func (v *AlterConfigsRequest) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	{
		v := v.Resources
		dst = kbin.AppendArrayLen(dst, len(v))
		for i := range v {
			v := &v[i]
			{
				v := v.ResourceType
				dst = kbin.AppendInt8(dst, v)
			}
			{
				v := v.ResourceName
				dst = kbin.AppendString(dst, v)
			}
			{
				v := v.Configs
				dst = kbin.AppendArrayLen(dst, len(v))
				for i := range v {
					v := &v[i]
					{
						v := v.Name
						dst = kbin.AppendString(dst, v)
					}
					{
						v := v.Value
						dst = kbin.AppendNullableString(dst, v)
					}
				}
			}
		}
	}
	{
		v := v.ValidateOnly
		dst = kbin.AppendBool(dst, v)
	}
	return dst
}
func (v *AlterConfigsRequest) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	b := kbin.Reader{Src: src}
	s := v
	{
		v := s.Resources
		a := v
		var l int32
		l = b.ArrayLen()
		if !b.Ok() {
			return b.Complete()
		}
		if l > 0 {
			a = make([]AlterConfigsRequestResource, l)
		}
		for i := int32(0); i < l; i++ {
			v := &a[i]
			s := v
			{
				v := b.Int8()
				s.ResourceType = v
			}
			{
				v := b.String()
				s.ResourceName = v
			}
			{
				v := s.Configs
				a := v
				var l int32
				l = b.ArrayLen()
				if !b.Ok() {
					return b.Complete()
				}
				if l > 0 {
					a = make([]AlterConfigsRequestResourceConfig, l)
				}
				for i := int32(0); i < l; i++ {
					v := &a[i]
					s := v
					{
						v := b.String()
						s.Name = v
					}
					{
						v := b.NullableString()
						s.Value = v
					}
				}
				v = a
				s.Configs = v
			}
		}
		v = a
		s.Resources = v
	}
	{
		v := b.Bool()
		s.ValidateOnly = v
	}
	return b.Complete()
}

type AlterConfigsResponseResource struct {
	// ErrorCode is the error code returned for altering configs.
	//
	// CLUSTER_AUTHORIZATION_FAILED is returned if asking to alter broker
	// configs but the client is not authorized to do so.
	//
	// TOPIC_AUTHORIZATION_FAILED is returned if asking to alter topic
	// configs but the client is not authorized to do so.
	//
	// INVALID_TOPIC_EXCEPTION is returned if the requested topic was invalid.
	//
	// UNKNOWN_TOPIC_OR_PARTITION is returned if the broker does not know of
	// the requested topic.
	//
	// INVALID_REQUEST is returned if the requested config is invalid or if
	// asking Kafka to alter an invalid resource.
	ErrorCode int16

	// ErrorMessage is an informative message if the alter config failed.
	ErrorMessage *string

	// ResourceType is the enum corresponding to the type of altered config.
	ResourceType int8

	// ResourceName is the name corresponding to the alter config request.
	ResourceName string
}

// AlterConfigsResponse is returned from an AlterConfigsRequest.
type AlterConfigsResponse struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	// ThrottleMillis is how long of a throttle Kafka will apply to the client
	// after this request.
	// For Kafka < 2.0.0, the throttle is applied before issuing a response.
	// For Kafka >= 2.0.0, the throttle is applied after issuing a response.
	ThrottleMillis int32

	// Resources are responses for each resource in the alter request.
	Resources []AlterConfigsResponseResource
}

func (*AlterConfigsResponse) Key() int16                 { return 33 }
func (*AlterConfigsResponse) MaxVersion() int16          { return 1 }
func (v *AlterConfigsResponse) SetVersion(version int16) { v.Version = version }
func (v *AlterConfigsResponse) GetVersion() int16        { return v.Version }
func (v *AlterConfigsResponse) IsFlexible() bool         { return false }
func (v *AlterConfigsResponse) RequestKind() Request     { return &AlterConfigsRequest{Version: v.Version} }

func (v *AlterConfigsResponse) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	{
		v := v.ThrottleMillis
		dst = kbin.AppendInt32(dst, v)
	}
	{
		v := v.Resources
		dst = kbin.AppendArrayLen(dst, len(v))
		for i := range v {
			v := &v[i]
			{
				v := v.ErrorCode
				dst = kbin.AppendInt16(dst, v)
			}
			{
				v := v.ErrorMessage
				dst = kbin.AppendNullableString(dst, v)
			}
			{
				v := v.ResourceType
				dst = kbin.AppendInt8(dst, v)
			}
			{
				v := v.ResourceName
				dst = kbin.AppendString(dst, v)
			}
		}
	}
	return dst
}
func (v *AlterConfigsResponse) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	b := kbin.Reader{Src: src}
	s := v
	{
		v := b.Int32()
		s.ThrottleMillis = v
	}
	{
		v := s.Resources
		a := v
		var l int32
		l = b.ArrayLen()
		if !b.Ok() {
			return b.Complete()
		}
		if l > 0 {
			a = make([]AlterConfigsResponseResource, l)
		}
		for i := int32(0); i < l; i++ {
			v := &a[i]
			s := v
			{
				v := b.Int16()
				s.ErrorCode = v
			}
			{
				v := b.NullableString()
				s.ErrorMessage = v
			}
			{
				v := b.Int8()
				s.ResourceType = v
			}
			{
				v := b.String()
				s.ResourceName = v
			}
		}
		v = a
		s.Resources = v
	}
	return b.Complete()
}

type AlterReplicaLogDirsRequestDirTopic struct {
	// Topic is a topic to move.
	Topic string

	// Partitions contains partitions for the topic to move.
	Partitions []int32
}
type AlterReplicaLogDirsRequestDir struct {
	// Dir is an absolute path where everything listed below should
	// end up.
	Dir string

	// Topics contains topics to move to the above log directory.
	Topics []AlterReplicaLogDirsRequestDirTopic
}

// AlterReplicaLogDirsRequest requests for log directories to be moved
// within Kafka.
//
// This is primarily useful for moving directories between disks.
type AlterReplicaLogDirsRequest struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	// Dirs contains absolute paths of where you want things to end up.
	Dirs []AlterReplicaLogDirsRequestDir
}

func (*AlterReplicaLogDirsRequest) Key() int16                 { return 34 }
func (*AlterReplicaLogDirsRequest) MaxVersion() int16          { return 1 }
func (v *AlterReplicaLogDirsRequest) SetVersion(version int16) { v.Version = version }
func (v *AlterReplicaLogDirsRequest) GetVersion() int16        { return v.Version }
func (v *AlterReplicaLogDirsRequest) IsFlexible() bool         { return false }
func (v *AlterReplicaLogDirsRequest) ResponseKind() Response {
	return &AlterReplicaLogDirsResponse{Version: v.Version}
}

func (v *AlterReplicaLogDirsRequest) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	{
		v := v.Dirs
		dst = kbin.AppendArrayLen(dst, len(v))
		for i := range v {
			v := &v[i]
			{
				v := v.Dir
				dst = kbin.AppendString(dst, v)
			}
			{
				v := v.Topics
				dst = kbin.AppendArrayLen(dst, len(v))
				for i := range v {
					v := &v[i]
					{
						v := v.Topic
						dst = kbin.AppendString(dst, v)
					}
					{
						v := v.Partitions
						dst = kbin.AppendArrayLen(dst, len(v))
						for i := range v {
							v := v[i]
							dst = kbin.AppendInt32(dst, v)
						}
					}
				}
			}
		}
	}
	return dst
}
func (v *AlterReplicaLogDirsRequest) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	b := kbin.Reader{Src: src}
	s := v
	{
		v := s.Dirs
		a := v
		var l int32
		l = b.ArrayLen()
		if !b.Ok() {
			return b.Complete()
		}
		if l > 0 {
			a = make([]AlterReplicaLogDirsRequestDir, l)
		}
		for i := int32(0); i < l; i++ {
			v := &a[i]
			s := v
			{
				v := b.String()
				s.Dir = v
			}
			{
				v := s.Topics
				a := v
				var l int32
				l = b.ArrayLen()
				if !b.Ok() {
					return b.Complete()
				}
				if l > 0 {
					a = make([]AlterReplicaLogDirsRequestDirTopic, l)
				}
				for i := int32(0); i < l; i++ {
					v := &a[i]
					s := v
					{
						v := b.String()
						s.Topic = v
					}
					{
						v := s.Partitions
						a := v
						var l int32
						l = b.ArrayLen()
						if !b.Ok() {
							return b.Complete()
						}
						if l > 0 {
							a = make([]int32, l)
						}
						for i := int32(0); i < l; i++ {
							v := b.Int32()
							a[i] = v
						}
						v = a
						s.Partitions = v
					}
				}
				v = a
				s.Topics = v
			}
		}
		v = a
		s.Dirs = v
	}
	return b.Complete()
}

type AlterReplicaLogDirsResponseTopicPartition struct {
	// Partition is the partition this array slot corresponds to.
	Partition int32

	// CLUSTER_AUTHORIZATION_FAILED is returned if the client is not
	// authorized to alter replica dirs.
	//
	// LOG_DIR_NOT_FOUND is returned when the requested log directory
	// is not in the broker config.
	//
	// KAFKA_STORAGE_EXCEPTION is returned when destination directory or
	// requested replica is offline.
	//
	// REPLICA_NOT_AVAILABLE is returned if the replica does not exist
	// yet.
	ErrorCode int16
}
type AlterReplicaLogDirsResponseTopic struct {
	// Topic is the topic this array slot corresponds to.
	Topic string

	// Partitions contains responses to each partition that was requested
	// to move.
	Partitions []AlterReplicaLogDirsResponseTopicPartition
}

// AlterReplicaLogDirsResponse is returned from an AlterReplicaLogDirsRequest.
type AlterReplicaLogDirsResponse struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	// ThrottleMillis is how long of a throttle Kafka will apply to the client
	// after this request.
	// For Kafka < 2.0.0, the throttle is applied before issuing a response.
	// For Kafka >= 2.0.0, the throttle is applied after issuing a response.
	ThrottleMillis int32

	// Topics contains responses to each topic that had partitions requested
	// for moving.
	Topics []AlterReplicaLogDirsResponseTopic
}

func (*AlterReplicaLogDirsResponse) Key() int16                 { return 34 }
func (*AlterReplicaLogDirsResponse) MaxVersion() int16          { return 1 }
func (v *AlterReplicaLogDirsResponse) SetVersion(version int16) { v.Version = version }
func (v *AlterReplicaLogDirsResponse) GetVersion() int16        { return v.Version }
func (v *AlterReplicaLogDirsResponse) IsFlexible() bool         { return false }
func (v *AlterReplicaLogDirsResponse) RequestKind() Request {
	return &AlterReplicaLogDirsRequest{Version: v.Version}
}

func (v *AlterReplicaLogDirsResponse) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	{
		v := v.ThrottleMillis
		dst = kbin.AppendInt32(dst, v)
	}
	{
		v := v.Topics
		dst = kbin.AppendArrayLen(dst, len(v))
		for i := range v {
			v := &v[i]
			{
				v := v.Topic
				dst = kbin.AppendString(dst, v)
			}
			{
				v := v.Partitions
				dst = kbin.AppendArrayLen(dst, len(v))
				for i := range v {
					v := &v[i]
					{
						v := v.Partition
						dst = kbin.AppendInt32(dst, v)
					}
					{
						v := v.ErrorCode
						dst = kbin.AppendInt16(dst, v)
					}
				}
			}
		}
	}
	return dst
}
func (v *AlterReplicaLogDirsResponse) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	b := kbin.Reader{Src: src}
	s := v
	{
		v := b.Int32()
		s.ThrottleMillis = v
	}
	{
		v := s.Topics
		a := v
		var l int32
		l = b.ArrayLen()
		if !b.Ok() {
			return b.Complete()
		}
		if l > 0 {
			a = make([]AlterReplicaLogDirsResponseTopic, l)
		}
		for i := int32(0); i < l; i++ {
			v := &a[i]
			s := v
			{
				v := b.String()
				s.Topic = v
			}
			{
				v := s.Partitions
				a := v
				var l int32
				l = b.ArrayLen()
				if !b.Ok() {
					return b.Complete()
				}
				if l > 0 {
					a = make([]AlterReplicaLogDirsResponseTopicPartition, l)
				}
				for i := int32(0); i < l; i++ {
					v := &a[i]
					s := v
					{
						v := b.Int32()
						s.Partition = v
					}
					{
						v := b.Int16()
						s.ErrorCode = v
					}
				}
				v = a
				s.Partitions = v
			}
		}
		v = a
		s.Topics = v
	}
	return b.Complete()
}

type DescribeLogDirsRequestTopic struct {
	// Topic is a topic to describe the log dir of.
	Topic string

	// Partitions contains topic partitions to describe the log dirs of.
	Partitions []int32
}

// DescribeLogDirsRequest requests directory information for topic partitions.
// This request was added in support of KIP-113.
type DescribeLogDirsRequest struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	// Topics is an array of topics to describe the log dirs of. If this is
	// null, the response includes all topics and all of their partitions.
	Topics []DescribeLogDirsRequestTopic
}

func (*DescribeLogDirsRequest) Key() int16                 { return 35 }
func (*DescribeLogDirsRequest) MaxVersion() int16          { return 2 }
func (v *DescribeLogDirsRequest) SetVersion(version int16) { v.Version = version }
func (v *DescribeLogDirsRequest) GetVersion() int16        { return v.Version }
func (v *DescribeLogDirsRequest) IsFlexible() bool         { return v.Version >= 2 }
func (v *DescribeLogDirsRequest) ResponseKind() Response {
	return &DescribeLogDirsResponse{Version: v.Version}
}

func (v *DescribeLogDirsRequest) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	isFlexible := version >= 2
	_ = isFlexible
	{
		v := v.Topics
		if isFlexible {
			dst = kbin.AppendCompactNullableArrayLen(dst, len(v), v == nil)
		} else {
			dst = kbin.AppendNullableArrayLen(dst, len(v), v == nil)
		}
		for i := range v {
			v := &v[i]
			{
				v := v.Topic
				if isFlexible {
					dst = kbin.AppendCompactString(dst, v)
				} else {
					dst = kbin.AppendString(dst, v)
				}
			}
			{
				v := v.Partitions
				if isFlexible {
					dst = kbin.AppendCompactArrayLen(dst, len(v))
				} else {
					dst = kbin.AppendArrayLen(dst, len(v))
				}
				for i := range v {
					v := v[i]
					dst = kbin.AppendInt32(dst, v)
				}
			}
			if isFlexible {
				dst = kbin.AppendUvarint(dst, 0)
			}
		}
	}
	if isFlexible {
		dst = kbin.AppendUvarint(dst, 0)
	}
	return dst
}
func (v *DescribeLogDirsRequest) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	isFlexible := version >= 2
	_ = isFlexible
	b := kbin.Reader{Src: src}
	s := v
	{
		v := s.Topics
		a := v
		var l int32
		if isFlexible {
			l = b.CompactArrayLen()
		} else {
			l = b.ArrayLen()
		}
		if version < 0 || l == 0 {
			a = []DescribeLogDirsRequestTopic{}
		}
		if !b.Ok() {
			return b.Complete()
		}
		if l > 0 {
			a = make([]DescribeLogDirsRequestTopic, l)
		}
		for i := int32(0); i < l; i++ {
			v := &a[i]
			s := v
			{
				var v string
				if isFlexible {
					v = b.CompactString()
				} else {
					v = b.String()
				}
				s.Topic = v
			}
			{
				v := s.Partitions
				a := v
				var l int32
				if isFlexible {
					l = b.CompactArrayLen()
				} else {
					l = b.ArrayLen()
				}
				if !b.Ok() {
					return b.Complete()
				}
				if l > 0 {
					a = make([]int32, l)
				}
				for i := int32(0); i < l; i++ {
					v := b.Int32()
					a[i] = v
				}
				v = a
				s.Partitions = v
			}
			if isFlexible {
				SkipTags(&b)
			}
		}
		v = a
		s.Topics = v
	}
	if isFlexible {
		SkipTags(&b)
	}
	return b.Complete()
}

type DescribeLogDirsResponseDirTopicPartition struct {
	// Partition is a partition ID.
	Partition int32

	// Size is the total size of the log sements of this partition, in bytes.
	Size int64

	// OffsetLag is how far behind the log end offset is compared to
	// the partition's high watermark (if this is the current log for
	// the partition) or compared to the current replica's log end
	// offset (if this is the future log for the patition).
	//
	// The math is,
	//
	// if IsFuture, localLogEndOffset - futurelogEndOffset.
	//
	// otherwise, max(localHighWatermark - logEndOffset, 0).
	OffsetLag int64

	// IsFuture is true if this replica was created by an
	// AlterReplicaLogDirsRequest and will replace the current log of the
	// replica in the future.
	IsFuture bool
}
type DescribeLogDirsResponseDirTopic struct {
	// Topic is the name of a Kafka topic.
	Topic string

	// Partitions is the set of queried partitions for a topic that are
	// within a log directory.
	Partitions []DescribeLogDirsResponseDirTopicPartition
}
type DescribeLogDirsResponseDir struct {
	// ErrorCode is the error code returned for descrbing log dirs.
	//
	// KAFKA_STORAGE_ERROR is returned if the log directoy is offline.
	ErrorCode int16

	// Dir is the absolute path of a log directory.
	Dir string

	// Topics is an array of topics within a log directory.
	Topics []DescribeLogDirsResponseDirTopic
}

// DescribeLogDirsResponse is returned from a DescribeLogDirsRequest.
type DescribeLogDirsResponse struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	// ThrottleMillis is how long of a throttle Kafka will apply to the client
	// after this request.
	// For Kafka < 2.0.0, the throttle is applied before issuing a response.
	// For Kafka >= 2.0.0, the throttle is applied after issuing a response.
	ThrottleMillis int32

	// Dirs pairs log directories with the topics and partitions that are
	// stored in those directores.
	Dirs []DescribeLogDirsResponseDir
}

func (*DescribeLogDirsResponse) Key() int16                 { return 35 }
func (*DescribeLogDirsResponse) MaxVersion() int16          { return 2 }
func (v *DescribeLogDirsResponse) SetVersion(version int16) { v.Version = version }
func (v *DescribeLogDirsResponse) GetVersion() int16        { return v.Version }
func (v *DescribeLogDirsResponse) IsFlexible() bool         { return v.Version >= 2 }
func (v *DescribeLogDirsResponse) RequestKind() Request {
	return &DescribeLogDirsRequest{Version: v.Version}
}

func (v *DescribeLogDirsResponse) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	isFlexible := version >= 2
	_ = isFlexible
	{
		v := v.ThrottleMillis
		dst = kbin.AppendInt32(dst, v)
	}
	{
		v := v.Dirs
		if isFlexible {
			dst = kbin.AppendCompactArrayLen(dst, len(v))
		} else {
			dst = kbin.AppendArrayLen(dst, len(v))
		}
		for i := range v {
			v := &v[i]
			{
				v := v.ErrorCode
				dst = kbin.AppendInt16(dst, v)
			}
			{
				v := v.Dir
				if isFlexible {
					dst = kbin.AppendCompactString(dst, v)
				} else {
					dst = kbin.AppendString(dst, v)
				}
			}
			{
				v := v.Topics
				if isFlexible {
					dst = kbin.AppendCompactArrayLen(dst, len(v))
				} else {
					dst = kbin.AppendArrayLen(dst, len(v))
				}
				for i := range v {
					v := &v[i]
					{
						v := v.Topic
						if isFlexible {
							dst = kbin.AppendCompactString(dst, v)
						} else {
							dst = kbin.AppendString(dst, v)
						}
					}
					{
						v := v.Partitions
						if isFlexible {
							dst = kbin.AppendCompactArrayLen(dst, len(v))
						} else {
							dst = kbin.AppendArrayLen(dst, len(v))
						}
						for i := range v {
							v := &v[i]
							{
								v := v.Partition
								dst = kbin.AppendInt32(dst, v)
							}
							{
								v := v.Size
								dst = kbin.AppendInt64(dst, v)
							}
							{
								v := v.OffsetLag
								dst = kbin.AppendInt64(dst, v)
							}
							{
								v := v.IsFuture
								dst = kbin.AppendBool(dst, v)
							}
							if isFlexible {
								dst = kbin.AppendUvarint(dst, 0)
							}
						}
					}
					if isFlexible {
						dst = kbin.AppendUvarint(dst, 0)
					}
				}
			}
			if isFlexible {
				dst = kbin.AppendUvarint(dst, 0)
			}
		}
	}
	if isFlexible {
		dst = kbin.AppendUvarint(dst, 0)
	}
	return dst
}
func (v *DescribeLogDirsResponse) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	isFlexible := version >= 2
	_ = isFlexible
	b := kbin.Reader{Src: src}
	s := v
	{
		v := b.Int32()
		s.ThrottleMillis = v
	}
	{
		v := s.Dirs
		a := v
		var l int32
		if isFlexible {
			l = b.CompactArrayLen()
		} else {
			l = b.ArrayLen()
		}
		if !b.Ok() {
			return b.Complete()
		}
		if l > 0 {
			a = make([]DescribeLogDirsResponseDir, l)
		}
		for i := int32(0); i < l; i++ {
			v := &a[i]
			s := v
			{
				v := b.Int16()
				s.ErrorCode = v
			}
			{
				var v string
				if isFlexible {
					v = b.CompactString()
				} else {
					v = b.String()
				}
				s.Dir = v
			}
			{
				v := s.Topics
				a := v
				var l int32
				if isFlexible {
					l = b.CompactArrayLen()
				} else {
					l = b.ArrayLen()
				}
				if !b.Ok() {
					return b.Complete()
				}
				if l > 0 {
					a = make([]DescribeLogDirsResponseDirTopic, l)
				}
				for i := int32(0); i < l; i++ {
					v := &a[i]
					s := v
					{
						var v string
						if isFlexible {
							v = b.CompactString()
						} else {
							v = b.String()
						}
						s.Topic = v
					}
					{
						v := s.Partitions
						a := v
						var l int32
						if isFlexible {
							l = b.CompactArrayLen()
						} else {
							l = b.ArrayLen()
						}
						if !b.Ok() {
							return b.Complete()
						}
						if l > 0 {
							a = make([]DescribeLogDirsResponseDirTopicPartition, l)
						}
						for i := int32(0); i < l; i++ {
							v := &a[i]
							s := v
							{
								v := b.Int32()
								s.Partition = v
							}
							{
								v := b.Int64()
								s.Size = v
							}
							{
								v := b.Int64()
								s.OffsetLag = v
							}
							{
								v := b.Bool()
								s.IsFuture = v
							}
							if isFlexible {
								SkipTags(&b)
							}
						}
						v = a
						s.Partitions = v
					}
					if isFlexible {
						SkipTags(&b)
					}
				}
				v = a
				s.Topics = v
			}
			if isFlexible {
				SkipTags(&b)
			}
		}
		v = a
		s.Dirs = v
	}
	if isFlexible {
		SkipTags(&b)
	}
	return b.Complete()
}

// SASLAuthenticate continues a sasl authentication flow. Prior to Kafka 1.0.0,
// authenticating with sasl involved sending raw blobs of data back and forth.
// After, those blobs are wrapped in a SASLAuthenticateRequest The benefit of
// this wrapping is that Kafka can indicate errors in the response, rather than
// just closing the connection. Additionally, the response allows for further
// extension fields.
type SASLAuthenticateRequest struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	// SASLAuthBytes contains bytes for a SASL client request.
	SASLAuthBytes []byte
}

func (*SASLAuthenticateRequest) Key() int16                 { return 36 }
func (*SASLAuthenticateRequest) MaxVersion() int16          { return 2 }
func (v *SASLAuthenticateRequest) SetVersion(version int16) { v.Version = version }
func (v *SASLAuthenticateRequest) GetVersion() int16        { return v.Version }
func (v *SASLAuthenticateRequest) IsFlexible() bool         { return v.Version >= 2 }
func (v *SASLAuthenticateRequest) ResponseKind() Response {
	return &SASLAuthenticateResponse{Version: v.Version}
}

func (v *SASLAuthenticateRequest) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	isFlexible := version >= 2
	_ = isFlexible
	{
		v := v.SASLAuthBytes
		if isFlexible {
			dst = kbin.AppendCompactBytes(dst, v)
		} else {
			dst = kbin.AppendBytes(dst, v)
		}
	}
	if isFlexible {
		dst = kbin.AppendUvarint(dst, 0)
	}
	return dst
}
func (v *SASLAuthenticateRequest) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	isFlexible := version >= 2
	_ = isFlexible
	b := kbin.Reader{Src: src}
	s := v
	{
		var v []byte
		if isFlexible {
			v = b.CompactBytes()
		} else {
			v = b.Bytes()
		}
		s.SASLAuthBytes = v
	}
	if isFlexible {
		SkipTags(&b)
	}
	return b.Complete()
}

// SASLAuthenticateResponse is returned for a SASLAuthenticateRequest.
type SASLAuthenticateResponse struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	// ErrorCode is a potential error.
	ErrorCode int16

	// ErrorMessage can contain a message for an error.
	ErrorMessage *string

	// SASLAuthBytes is the server challenge continuing SASL flow.
	SASLAuthBytes []byte

	// SessionLifetimeMillis, added in Kafka 2.2.0, is how long the SASL
	// authentication is valid for. This timeout is only enforced if the request
	// was v1. After this timeout, Kafka expects the next bytes on the wire to
	// begin reauthentication. Otherwise, Kafka closes the connection.
	SessionLifetimeMillis int64 // v1+
}

func (*SASLAuthenticateResponse) Key() int16                 { return 36 }
func (*SASLAuthenticateResponse) MaxVersion() int16          { return 2 }
func (v *SASLAuthenticateResponse) SetVersion(version int16) { v.Version = version }
func (v *SASLAuthenticateResponse) GetVersion() int16        { return v.Version }
func (v *SASLAuthenticateResponse) IsFlexible() bool         { return v.Version >= 2 }
func (v *SASLAuthenticateResponse) RequestKind() Request {
	return &SASLAuthenticateRequest{Version: v.Version}
}

func (v *SASLAuthenticateResponse) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	isFlexible := version >= 2
	_ = isFlexible
	{
		v := v.ErrorCode
		dst = kbin.AppendInt16(dst, v)
	}
	{
		v := v.ErrorMessage
		if isFlexible {
			dst = kbin.AppendCompactNullableString(dst, v)
		} else {
			dst = kbin.AppendNullableString(dst, v)
		}
	}
	{
		v := v.SASLAuthBytes
		if isFlexible {
			dst = kbin.AppendCompactBytes(dst, v)
		} else {
			dst = kbin.AppendBytes(dst, v)
		}
	}
	if version >= 1 {
		v := v.SessionLifetimeMillis
		dst = kbin.AppendInt64(dst, v)
	}
	if isFlexible {
		dst = kbin.AppendUvarint(dst, 0)
	}
	return dst
}
func (v *SASLAuthenticateResponse) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	isFlexible := version >= 2
	_ = isFlexible
	b := kbin.Reader{Src: src}
	s := v
	{
		v := b.Int16()
		s.ErrorCode = v
	}
	{
		var v *string
		if isFlexible {
			v = b.CompactNullableString()
		} else {
			v = b.NullableString()
		}
		s.ErrorMessage = v
	}
	{
		var v []byte
		if isFlexible {
			v = b.CompactBytes()
		} else {
			v = b.Bytes()
		}
		s.SASLAuthBytes = v
	}
	if version >= 1 {
		v := b.Int64()
		s.SessionLifetimeMillis = v
	}
	if isFlexible {
		SkipTags(&b)
	}
	return b.Complete()
}

type CreatePartitionsRequestTopicAssignment struct {
	// Replicas are replicas to assign a new partition to.
	Replicas []int32
}
type CreatePartitionsRequestTopic struct {
	// Topic is a topic for which to create additional partitions for.
	Topic string

	// Count is the final count of partitions this topic must have after this
	// request. This must be greater than the current number of partitions.
	Count int32

	// Assignment is a two-level array, the first corresponding to new
	// partitions, the second contining broker IDs for where new partition
	// replicas should live.
	//
	// The second level, the replicas, cannot have duplicate broker IDs (i.e.
	// you cannot replicate a single partition twice on the same broker).
	// Additionally, the number of replicas must match the current number of
	// replicas per partition on the topic.
	//
	// The first level's length must be equal to the delta of Count and the
	// current number of partitions.
	Assignment []CreatePartitionsRequestTopicAssignment
}

// CreatePartitionsRequest creates additional partitions for topics.
type CreatePartitionsRequest struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	// Topics contains topics to create partitions for.
	Topics []CreatePartitionsRequestTopic

	// TimeoutMillis is how long to allow for this request.
	TimeoutMillis int32

	// ValidateOnly is makes this request a dry-run; everything is validated but
	// no partitions are actually created.
	ValidateOnly bool
}

func (*CreatePartitionsRequest) Key() int16                 { return 37 }
func (*CreatePartitionsRequest) MaxVersion() int16          { return 3 }
func (v *CreatePartitionsRequest) SetVersion(version int16) { v.Version = version }
func (v *CreatePartitionsRequest) GetVersion() int16        { return v.Version }
func (v *CreatePartitionsRequest) IsFlexible() bool         { return v.Version >= 2 }
func (v *CreatePartitionsRequest) IsAdminRequest()          {}
func (v *CreatePartitionsRequest) ResponseKind() Response {
	return &CreatePartitionsResponse{Version: v.Version}
}

func (v *CreatePartitionsRequest) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	isFlexible := version >= 2
	_ = isFlexible
	{
		v := v.Topics
		if isFlexible {
			dst = kbin.AppendCompactArrayLen(dst, len(v))
		} else {
			dst = kbin.AppendArrayLen(dst, len(v))
		}
		for i := range v {
			v := &v[i]
			{
				v := v.Topic
				if isFlexible {
					dst = kbin.AppendCompactString(dst, v)
				} else {
					dst = kbin.AppendString(dst, v)
				}
			}
			{
				v := v.Count
				dst = kbin.AppendInt32(dst, v)
			}
			{
				v := v.Assignment
				if isFlexible {
					dst = kbin.AppendCompactNullableArrayLen(dst, len(v), v == nil)
				} else {
					dst = kbin.AppendNullableArrayLen(dst, len(v), v == nil)
				}
				for i := range v {
					v := &v[i]
					{
						v := v.Replicas
						if isFlexible {
							dst = kbin.AppendCompactArrayLen(dst, len(v))
						} else {
							dst = kbin.AppendArrayLen(dst, len(v))
						}
						for i := range v {
							v := v[i]
							dst = kbin.AppendInt32(dst, v)
						}
					}
					if isFlexible {
						dst = kbin.AppendUvarint(dst, 0)
					}
				}
			}
			if isFlexible {
				dst = kbin.AppendUvarint(dst, 0)
			}
		}
	}
	{
		v := v.TimeoutMillis
		dst = kbin.AppendInt32(dst, v)
	}
	{
		v := v.ValidateOnly
		dst = kbin.AppendBool(dst, v)
	}
	if isFlexible {
		dst = kbin.AppendUvarint(dst, 0)
	}
	return dst
}
func (v *CreatePartitionsRequest) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	isFlexible := version >= 2
	_ = isFlexible
	b := kbin.Reader{Src: src}
	s := v
	{
		v := s.Topics
		a := v
		var l int32
		if isFlexible {
			l = b.CompactArrayLen()
		} else {
			l = b.ArrayLen()
		}
		if !b.Ok() {
			return b.Complete()
		}
		if l > 0 {
			a = make([]CreatePartitionsRequestTopic, l)
		}
		for i := int32(0); i < l; i++ {
			v := &a[i]
			s := v
			{
				var v string
				if isFlexible {
					v = b.CompactString()
				} else {
					v = b.String()
				}
				s.Topic = v
			}
			{
				v := b.Int32()
				s.Count = v
			}
			{
				v := s.Assignment
				a := v
				var l int32
				if isFlexible {
					l = b.CompactArrayLen()
				} else {
					l = b.ArrayLen()
				}
				if version < 0 || l == 0 {
					a = []CreatePartitionsRequestTopicAssignment{}
				}
				if !b.Ok() {
					return b.Complete()
				}
				if l > 0 {
					a = make([]CreatePartitionsRequestTopicAssignment, l)
				}
				for i := int32(0); i < l; i++ {
					v := &a[i]
					s := v
					{
						v := s.Replicas
						a := v
						var l int32
						if isFlexible {
							l = b.CompactArrayLen()
						} else {
							l = b.ArrayLen()
						}
						if !b.Ok() {
							return b.Complete()
						}
						if l > 0 {
							a = make([]int32, l)
						}
						for i := int32(0); i < l; i++ {
							v := b.Int32()
							a[i] = v
						}
						v = a
						s.Replicas = v
					}
					if isFlexible {
						SkipTags(&b)
					}
				}
				v = a
				s.Assignment = v
			}
			if isFlexible {
				SkipTags(&b)
			}
		}
		v = a
		s.Topics = v
	}
	{
		v := b.Int32()
		s.TimeoutMillis = v
	}
	{
		v := b.Bool()
		s.ValidateOnly = v
	}
	if isFlexible {
		SkipTags(&b)
	}
	return b.Complete()
}

type CreatePartitionsResponseTopic struct {
	// Topic is the topic that partitions were requested to be made for.
	Topic string

	// ErrorCode is the error code returned for each topic in the request.
	//
	// NOT_CONTROLLER is returned if the request was not issued to a Kafka
	// controller.
	//
	// TOPIC_AUTHORIZATION_FAILED is returned if the client is not authorized
	// to create partitions for a topic.
	//
	// INVALID_REQUEST is returned for duplicate topics in the request.
	//
	// INVALID_TOPIC_EXCEPTION is returned if the topic is queued for deletion.
	//
	// REASSIGNMENT_IN_PROGRESS is returned if the request was issued while
	// partitions were being reassigned.
	//
	// UNKNOWN_TOPIC_OR_PARTITION is returned if the broker does not know of
	// the topic for which to create partitions.
	//
	// INVALID_PARTITIONS is returned if the request would drop the total
	// count of partitions down, or if the request would not add any more
	// partitions, or if the request uses unknown brokers, or if the request
	// assigns a different number of brokers than the increase in the
	// partition count.
	ErrorCode int16

	// ErrorMessage is an informative message if the topic creation failed.
	ErrorMessage *string
}

// CreatePartitionsResponse is returned from a CreatePartitionsRequest.
type CreatePartitionsResponse struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	// ThrottleMillis is how long of a throttle Kafka will apply to the client
	// after this request.
	// For Kafka < 2.0.0, the throttle is applied before issuing a response.
	// For Kafka >= 2.0.0, the throttle is applied after issuing a response.
	ThrottleMillis int32

	// Topics is a response to each topic in the creation request.
	Topics []CreatePartitionsResponseTopic
}

func (*CreatePartitionsResponse) Key() int16                 { return 37 }
func (*CreatePartitionsResponse) MaxVersion() int16          { return 3 }
func (v *CreatePartitionsResponse) SetVersion(version int16) { v.Version = version }
func (v *CreatePartitionsResponse) GetVersion() int16        { return v.Version }
func (v *CreatePartitionsResponse) IsFlexible() bool         { return v.Version >= 2 }
func (v *CreatePartitionsResponse) RequestKind() Request {
	return &CreatePartitionsRequest{Version: v.Version}
}

func (v *CreatePartitionsResponse) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	isFlexible := version >= 2
	_ = isFlexible
	{
		v := v.ThrottleMillis
		dst = kbin.AppendInt32(dst, v)
	}
	{
		v := v.Topics
		if isFlexible {
			dst = kbin.AppendCompactArrayLen(dst, len(v))
		} else {
			dst = kbin.AppendArrayLen(dst, len(v))
		}
		for i := range v {
			v := &v[i]
			{
				v := v.Topic
				if isFlexible {
					dst = kbin.AppendCompactString(dst, v)
				} else {
					dst = kbin.AppendString(dst, v)
				}
			}
			{
				v := v.ErrorCode
				dst = kbin.AppendInt16(dst, v)
			}
			{
				v := v.ErrorMessage
				if isFlexible {
					dst = kbin.AppendCompactNullableString(dst, v)
				} else {
					dst = kbin.AppendNullableString(dst, v)
				}
			}
			if isFlexible {
				dst = kbin.AppendUvarint(dst, 0)
			}
		}
	}
	if isFlexible {
		dst = kbin.AppendUvarint(dst, 0)
	}
	return dst
}
func (v *CreatePartitionsResponse) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	isFlexible := version >= 2
	_ = isFlexible
	b := kbin.Reader{Src: src}
	s := v
	{
		v := b.Int32()
		s.ThrottleMillis = v
	}
	{
		v := s.Topics
		a := v
		var l int32
		if isFlexible {
			l = b.CompactArrayLen()
		} else {
			l = b.ArrayLen()
		}
		if !b.Ok() {
			return b.Complete()
		}
		if l > 0 {
			a = make([]CreatePartitionsResponseTopic, l)
		}
		for i := int32(0); i < l; i++ {
			v := &a[i]
			s := v
			{
				var v string
				if isFlexible {
					v = b.CompactString()
				} else {
					v = b.String()
				}
				s.Topic = v
			}
			{
				v := b.Int16()
				s.ErrorCode = v
			}
			{
				var v *string
				if isFlexible {
					v = b.CompactNullableString()
				} else {
					v = b.NullableString()
				}
				s.ErrorMessage = v
			}
			if isFlexible {
				SkipTags(&b)
			}
		}
		v = a
		s.Topics = v
	}
	if isFlexible {
		SkipTags(&b)
	}
	return b.Complete()
}

type CreateDelegationTokenRequestRenewer struct {
	// PrincipalType is the "type" this principal is. This must be "User".
	PrincipalType string

	// PrincipalName is the user name allowed to renew the returned token.
	PrincipalName string
}

// CreateDelegationTokenRequest issues a request to create a delegation token.
//
// Creating delegation tokens allows for an (ideally) quicker and easier method
// of enabling authorization for a wide array of clients. Rather than having to
// manage many passwords external to Kafka, you only need to manage a few
// accounts and use those to create delegation tokens per client.
//
// Note that delegation tokens inherit the same ACLs as the user creating the
// token. Thus, if you want to properly scope ACLs, you should not create
// delegation tokens with admin accounts.
//
// Delegation tokens live inside of Kafka and use SASL SCRAM-SHA-256 for
// authorization.
type CreateDelegationTokenRequest struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	// Renewers is a list of who can renew this delegation token. If empty, the
	// default is the principal (user) who created the token.
	Renewers []CreateDelegationTokenRequestRenewer

	// MaxLifetimeMillis is how long this delegation token will be valid for.
	// If -1, the default will be the server's delegation.token.max.lifetime.ms.
	MaxLifetimeMillis int64
}

func (*CreateDelegationTokenRequest) Key() int16                 { return 38 }
func (*CreateDelegationTokenRequest) MaxVersion() int16          { return 2 }
func (v *CreateDelegationTokenRequest) SetVersion(version int16) { v.Version = version }
func (v *CreateDelegationTokenRequest) GetVersion() int16        { return v.Version }
func (v *CreateDelegationTokenRequest) IsFlexible() bool         { return v.Version >= 2 }
func (v *CreateDelegationTokenRequest) ResponseKind() Response {
	return &CreateDelegationTokenResponse{Version: v.Version}
}

func (v *CreateDelegationTokenRequest) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	isFlexible := version >= 2
	_ = isFlexible
	{
		v := v.Renewers
		if isFlexible {
			dst = kbin.AppendCompactArrayLen(dst, len(v))
		} else {
			dst = kbin.AppendArrayLen(dst, len(v))
		}
		for i := range v {
			v := &v[i]
			{
				v := v.PrincipalType
				if isFlexible {
					dst = kbin.AppendCompactString(dst, v)
				} else {
					dst = kbin.AppendString(dst, v)
				}
			}
			{
				v := v.PrincipalName
				if isFlexible {
					dst = kbin.AppendCompactString(dst, v)
				} else {
					dst = kbin.AppendString(dst, v)
				}
			}
			if isFlexible {
				dst = kbin.AppendUvarint(dst, 0)
			}
		}
	}
	{
		v := v.MaxLifetimeMillis
		dst = kbin.AppendInt64(dst, v)
	}
	if isFlexible {
		dst = kbin.AppendUvarint(dst, 0)
	}
	return dst
}
func (v *CreateDelegationTokenRequest) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	isFlexible := version >= 2
	_ = isFlexible
	b := kbin.Reader{Src: src}
	s := v
	{
		v := s.Renewers
		a := v
		var l int32
		if isFlexible {
			l = b.CompactArrayLen()
		} else {
			l = b.ArrayLen()
		}
		if !b.Ok() {
			return b.Complete()
		}
		if l > 0 {
			a = make([]CreateDelegationTokenRequestRenewer, l)
		}
		for i := int32(0); i < l; i++ {
			v := &a[i]
			s := v
			{
				var v string
				if isFlexible {
					v = b.CompactString()
				} else {
					v = b.String()
				}
				s.PrincipalType = v
			}
			{
				var v string
				if isFlexible {
					v = b.CompactString()
				} else {
					v = b.String()
				}
				s.PrincipalName = v
			}
			if isFlexible {
				SkipTags(&b)
			}
		}
		v = a
		s.Renewers = v
	}
	{
		v := b.Int64()
		s.MaxLifetimeMillis = v
	}
	if isFlexible {
		SkipTags(&b)
	}
	return b.Complete()
}

// CreateDelegationTokenResponse is a response to a CreateDelegationTokenRequest.
type CreateDelegationTokenResponse struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	// ErrorCode is any error that caused the request to fail.
	ErrorCode int16

	// PrincipalType is the type of principal that granted this delegation token.
	// This will always be "User" with the simple authorizer.
	PrincipalType string

	// PrincipalName is the name of the principal that granted this delegation
	// token.
	PrincipalName string

	// IssueTimestamp is the millisecond timestamp this delegation token was
	// issued.
	IssueTimestamp int64

	// ExpiryTimestamp is the millisecond timestamp this token will expire. The
	// token can be renewed up to MaxTimestamp, past which point, it will be
	// invalid. The Kafka default is 24h.
	ExpiryTimestamp int64

	// MaxTimestamp is the millisecond timestamp past which this token cannot
	// be renewed.
	MaxTimestamp int64

	// TokenID is the ID of this token; this will be used as the username for
	// scram authentication.
	TokenID string

	// HMAC is the password of this token; this will be used as the password for
	// scram authentication.
	HMAC []byte

	// ThrottleMillis is how long of a throttle Kafka will apply to the client
	// after this request.
	// For Kafka < 2.0.0, the throttle is applied before issuing a response.
	// For Kafka >= 2.0.0, the throttle is applied after issuing a response.
	ThrottleMillis int32
}

func (*CreateDelegationTokenResponse) Key() int16                 { return 38 }
func (*CreateDelegationTokenResponse) MaxVersion() int16          { return 2 }
func (v *CreateDelegationTokenResponse) SetVersion(version int16) { v.Version = version }
func (v *CreateDelegationTokenResponse) GetVersion() int16        { return v.Version }
func (v *CreateDelegationTokenResponse) IsFlexible() bool         { return v.Version >= 2 }
func (v *CreateDelegationTokenResponse) RequestKind() Request {
	return &CreateDelegationTokenRequest{Version: v.Version}
}

func (v *CreateDelegationTokenResponse) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	isFlexible := version >= 2
	_ = isFlexible
	{
		v := v.ErrorCode
		dst = kbin.AppendInt16(dst, v)
	}
	{
		v := v.PrincipalType
		if isFlexible {
			dst = kbin.AppendCompactString(dst, v)
		} else {
			dst = kbin.AppendString(dst, v)
		}
	}
	{
		v := v.PrincipalName
		if isFlexible {
			dst = kbin.AppendCompactString(dst, v)
		} else {
			dst = kbin.AppendString(dst, v)
		}
	}
	{
		v := v.IssueTimestamp
		dst = kbin.AppendInt64(dst, v)
	}
	{
		v := v.ExpiryTimestamp
		dst = kbin.AppendInt64(dst, v)
	}
	{
		v := v.MaxTimestamp
		dst = kbin.AppendInt64(dst, v)
	}
	{
		v := v.TokenID
		if isFlexible {
			dst = kbin.AppendCompactString(dst, v)
		} else {
			dst = kbin.AppendString(dst, v)
		}
	}
	{
		v := v.HMAC
		if isFlexible {
			dst = kbin.AppendCompactBytes(dst, v)
		} else {
			dst = kbin.AppendBytes(dst, v)
		}
	}
	{
		v := v.ThrottleMillis
		dst = kbin.AppendInt32(dst, v)
	}
	if isFlexible {
		dst = kbin.AppendUvarint(dst, 0)
	}
	return dst
}
func (v *CreateDelegationTokenResponse) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	isFlexible := version >= 2
	_ = isFlexible
	b := kbin.Reader{Src: src}
	s := v
	{
		v := b.Int16()
		s.ErrorCode = v
	}
	{
		var v string
		if isFlexible {
			v = b.CompactString()
		} else {
			v = b.String()
		}
		s.PrincipalType = v
	}
	{
		var v string
		if isFlexible {
			v = b.CompactString()
		} else {
			v = b.String()
		}
		s.PrincipalName = v
	}
	{
		v := b.Int64()
		s.IssueTimestamp = v
	}
	{
		v := b.Int64()
		s.ExpiryTimestamp = v
	}
	{
		v := b.Int64()
		s.MaxTimestamp = v
	}
	{
		var v string
		if isFlexible {
			v = b.CompactString()
		} else {
			v = b.String()
		}
		s.TokenID = v
	}
	{
		var v []byte
		if isFlexible {
			v = b.CompactBytes()
		} else {
			v = b.Bytes()
		}
		s.HMAC = v
	}
	{
		v := b.Int32()
		s.ThrottleMillis = v
	}
	if isFlexible {
		SkipTags(&b)
	}
	return b.Complete()
}

// RenewDelegationTokenRequest is a request to renew a delegation token that
// has not yet hit its max timestamp. Note that a client using a token cannot
// renew its own token.
type RenewDelegationTokenRequest struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	// HMAC is the HMAC of the token to be renewed.
	HMAC []byte

	// RenewTimeMillis is how long to renew the token for. If -1, Kafka uses its
	// delegation.token.max.lifetime.ms.
	RenewTimeMillis int64
}

func (*RenewDelegationTokenRequest) Key() int16                 { return 39 }
func (*RenewDelegationTokenRequest) MaxVersion() int16          { return 2 }
func (v *RenewDelegationTokenRequest) SetVersion(version int16) { v.Version = version }
func (v *RenewDelegationTokenRequest) GetVersion() int16        { return v.Version }
func (v *RenewDelegationTokenRequest) IsFlexible() bool         { return v.Version >= 2 }
func (v *RenewDelegationTokenRequest) ResponseKind() Response {
	return &RenewDelegationTokenResponse{Version: v.Version}
}

func (v *RenewDelegationTokenRequest) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	isFlexible := version >= 2
	_ = isFlexible
	{
		v := v.HMAC
		if isFlexible {
			dst = kbin.AppendCompactBytes(dst, v)
		} else {
			dst = kbin.AppendBytes(dst, v)
		}
	}
	{
		v := v.RenewTimeMillis
		dst = kbin.AppendInt64(dst, v)
	}
	if isFlexible {
		dst = kbin.AppendUvarint(dst, 0)
	}
	return dst
}
func (v *RenewDelegationTokenRequest) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	isFlexible := version >= 2
	_ = isFlexible
	b := kbin.Reader{Src: src}
	s := v
	{
		var v []byte
		if isFlexible {
			v = b.CompactBytes()
		} else {
			v = b.Bytes()
		}
		s.HMAC = v
	}
	{
		v := b.Int64()
		s.RenewTimeMillis = v
	}
	if isFlexible {
		SkipTags(&b)
	}
	return b.Complete()
}

// RenewDelegationTokenResponse is a response to a RenewDelegationTokenRequest.
type RenewDelegationTokenResponse struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	// ErrorCode is any error that caused the request to fail.
	ErrorCode int16

	// ExpiryTimestamp is the millisecond timestamp this token will expire. The
	// token can be renewed up to MaxTimestamp, past which point, it will be
	// invalid. The Kafka default is 24h.
	ExpiryTimestamp int64

	// ThrottleMillis is how long of a throttle Kafka will apply to the client
	// after this request.
	// For Kafka < 2.0.0, the throttle is applied before issuing a response.
	// For Kafka >= 2.0.0, the throttle is applied after issuing a response.
	ThrottleMillis int32
}

func (*RenewDelegationTokenResponse) Key() int16                 { return 39 }
func (*RenewDelegationTokenResponse) MaxVersion() int16          { return 2 }
func (v *RenewDelegationTokenResponse) SetVersion(version int16) { v.Version = version }
func (v *RenewDelegationTokenResponse) GetVersion() int16        { return v.Version }
func (v *RenewDelegationTokenResponse) IsFlexible() bool         { return v.Version >= 2 }
func (v *RenewDelegationTokenResponse) RequestKind() Request {
	return &RenewDelegationTokenRequest{Version: v.Version}
}

func (v *RenewDelegationTokenResponse) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	isFlexible := version >= 2
	_ = isFlexible
	{
		v := v.ErrorCode
		dst = kbin.AppendInt16(dst, v)
	}
	{
		v := v.ExpiryTimestamp
		dst = kbin.AppendInt64(dst, v)
	}
	{
		v := v.ThrottleMillis
		dst = kbin.AppendInt32(dst, v)
	}
	if isFlexible {
		dst = kbin.AppendUvarint(dst, 0)
	}
	return dst
}
func (v *RenewDelegationTokenResponse) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	isFlexible := version >= 2
	_ = isFlexible
	b := kbin.Reader{Src: src}
	s := v
	{
		v := b.Int16()
		s.ErrorCode = v
	}
	{
		v := b.Int64()
		s.ExpiryTimestamp = v
	}
	{
		v := b.Int32()
		s.ThrottleMillis = v
	}
	if isFlexible {
		SkipTags(&b)
	}
	return b.Complete()
}

// ExpireDelegationTokenRequest is a request to change the expiry timestamp
// of a delegation token. Note that a client using a token cannot expire its
// own token.
type ExpireDelegationTokenRequest struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	// HMAC is the HMAC of the token to change the expiry timestamp of.
	HMAC []byte

	// ExpiryPeriodMillis changes the delegation token's expiry timestamp to
	// now + expiry time millis. This can be used to force tokens to expiry
	// quickly, or to allow tokens a grace period before expiry. This can only
	// change the final expiry timestamp down; you cannot add enough time that
	// would increase the expiry timestamp.
	//
	// Note that you can change the expiry timestamp down and then back up, so
	// long as you change it back up before the timestamp expires.
	ExpiryPeriodMillis int64
}

func (*ExpireDelegationTokenRequest) Key() int16                 { return 40 }
func (*ExpireDelegationTokenRequest) MaxVersion() int16          { return 2 }
func (v *ExpireDelegationTokenRequest) SetVersion(version int16) { v.Version = version }
func (v *ExpireDelegationTokenRequest) GetVersion() int16        { return v.Version }
func (v *ExpireDelegationTokenRequest) IsFlexible() bool         { return v.Version >= 2 }
func (v *ExpireDelegationTokenRequest) ResponseKind() Response {
	return &ExpireDelegationTokenResponse{Version: v.Version}
}

func (v *ExpireDelegationTokenRequest) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	isFlexible := version >= 2
	_ = isFlexible
	{
		v := v.HMAC
		if isFlexible {
			dst = kbin.AppendCompactBytes(dst, v)
		} else {
			dst = kbin.AppendBytes(dst, v)
		}
	}
	{
		v := v.ExpiryPeriodMillis
		dst = kbin.AppendInt64(dst, v)
	}
	if isFlexible {
		dst = kbin.AppendUvarint(dst, 0)
	}
	return dst
}
func (v *ExpireDelegationTokenRequest) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	isFlexible := version >= 2
	_ = isFlexible
	b := kbin.Reader{Src: src}
	s := v
	{
		var v []byte
		if isFlexible {
			v = b.CompactBytes()
		} else {
			v = b.Bytes()
		}
		s.HMAC = v
	}
	{
		v := b.Int64()
		s.ExpiryPeriodMillis = v
	}
	if isFlexible {
		SkipTags(&b)
	}
	return b.Complete()
}

// ExpireDelegationTokenResponse is a response to an ExpireDelegationTokenRequest.
type ExpireDelegationTokenResponse struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	// ErrorCode is any error that caused the request to fail.
	ErrorCode int16

	// ExpiryTimestamp is the new timestamp at which the delegation token will
	// expire.
	ExpiryTimestamp int64

	// ThrottleMillis is how long of a throttle Kafka will apply to the client
	// after this request.
	// For Kafka < 2.0.0, the throttle is applied before issuing a response.
	// For Kafka >= 2.0.0, the throttle is applied after issuing a response.
	ThrottleMillis int32
}

func (*ExpireDelegationTokenResponse) Key() int16                 { return 40 }
func (*ExpireDelegationTokenResponse) MaxVersion() int16          { return 2 }
func (v *ExpireDelegationTokenResponse) SetVersion(version int16) { v.Version = version }
func (v *ExpireDelegationTokenResponse) GetVersion() int16        { return v.Version }
func (v *ExpireDelegationTokenResponse) IsFlexible() bool         { return v.Version >= 2 }
func (v *ExpireDelegationTokenResponse) RequestKind() Request {
	return &ExpireDelegationTokenRequest{Version: v.Version}
}

func (v *ExpireDelegationTokenResponse) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	isFlexible := version >= 2
	_ = isFlexible
	{
		v := v.ErrorCode
		dst = kbin.AppendInt16(dst, v)
	}
	{
		v := v.ExpiryTimestamp
		dst = kbin.AppendInt64(dst, v)
	}
	{
		v := v.ThrottleMillis
		dst = kbin.AppendInt32(dst, v)
	}
	if isFlexible {
		dst = kbin.AppendUvarint(dst, 0)
	}
	return dst
}
func (v *ExpireDelegationTokenResponse) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	isFlexible := version >= 2
	_ = isFlexible
	b := kbin.Reader{Src: src}
	s := v
	{
		v := b.Int16()
		s.ErrorCode = v
	}
	{
		v := b.Int64()
		s.ExpiryTimestamp = v
	}
	{
		v := b.Int32()
		s.ThrottleMillis = v
	}
	if isFlexible {
		SkipTags(&b)
	}
	return b.Complete()
}

type DescribeDelegationTokenRequestOwner struct {
	// PrincipalType is a type to match to describe delegation tokens created
	// with this principal. This would be "User" with the simple authorizer.
	PrincipalType string

	// PrincipalName is the name to match to describe delegation tokens created
	// with this principal.
	PrincipalName string
}

// DescribeDelegationTokenRequest is a request to describe delegation tokens.
type DescribeDelegationTokenRequest struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	// Owners contains owners to describe delegation tokens for, or null for all.
	// If non-null, only tokens created from a matching principal type, name
	// combination are printed.
	Owners []DescribeDelegationTokenRequestOwner
}

func (*DescribeDelegationTokenRequest) Key() int16                 { return 41 }
func (*DescribeDelegationTokenRequest) MaxVersion() int16          { return 2 }
func (v *DescribeDelegationTokenRequest) SetVersion(version int16) { v.Version = version }
func (v *DescribeDelegationTokenRequest) GetVersion() int16        { return v.Version }
func (v *DescribeDelegationTokenRequest) IsFlexible() bool         { return v.Version >= 2 }
func (v *DescribeDelegationTokenRequest) ResponseKind() Response {
	return &DescribeDelegationTokenResponse{Version: v.Version}
}

func (v *DescribeDelegationTokenRequest) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	isFlexible := version >= 2
	_ = isFlexible
	{
		v := v.Owners
		if isFlexible {
			dst = kbin.AppendCompactNullableArrayLen(dst, len(v), v == nil)
		} else {
			dst = kbin.AppendNullableArrayLen(dst, len(v), v == nil)
		}
		for i := range v {
			v := &v[i]
			{
				v := v.PrincipalType
				if isFlexible {
					dst = kbin.AppendCompactString(dst, v)
				} else {
					dst = kbin.AppendString(dst, v)
				}
			}
			{
				v := v.PrincipalName
				if isFlexible {
					dst = kbin.AppendCompactString(dst, v)
				} else {
					dst = kbin.AppendString(dst, v)
				}
			}
			if isFlexible {
				dst = kbin.AppendUvarint(dst, 0)
			}
		}
	}
	if isFlexible {
		dst = kbin.AppendUvarint(dst, 0)
	}
	return dst
}
func (v *DescribeDelegationTokenRequest) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	isFlexible := version >= 2
	_ = isFlexible
	b := kbin.Reader{Src: src}
	s := v
	{
		v := s.Owners
		a := v
		var l int32
		if isFlexible {
			l = b.CompactArrayLen()
		} else {
			l = b.ArrayLen()
		}
		if version < 0 || l == 0 {
			a = []DescribeDelegationTokenRequestOwner{}
		}
		if !b.Ok() {
			return b.Complete()
		}
		if l > 0 {
			a = make([]DescribeDelegationTokenRequestOwner, l)
		}
		for i := int32(0); i < l; i++ {
			v := &a[i]
			s := v
			{
				var v string
				if isFlexible {
					v = b.CompactString()
				} else {
					v = b.String()
				}
				s.PrincipalType = v
			}
			{
				var v string
				if isFlexible {
					v = b.CompactString()
				} else {
					v = b.String()
				}
				s.PrincipalName = v
			}
			if isFlexible {
				SkipTags(&b)
			}
		}
		v = a
		s.Owners = v
	}
	if isFlexible {
		SkipTags(&b)
	}
	return b.Complete()
}

type DescribeDelegationTokenResponseTokenDetailRenewer struct {
	PrincipalType string

	PrincipalName string
}
type DescribeDelegationTokenResponseTokenDetail struct {
	// PrincipalType is the principal type of who created this token.
	PrincipalType string

	// PrincipalName is the principal name of who created this token.
	PrincipalName string

	// IssueTimestamp is the millisecond timestamp of when this token was issued.
	IssueTimestamp int64

	// ExpiryTimestamp is the millisecond timestamp of when this token will expire.
	ExpiryTimestamp int64

	// MaxTimestamp is the millisecond timestamp past which whis token cannot
	// be renewed.
	MaxTimestamp int64

	// TokenID is the ID (scram username) of this token.
	TokenID string

	// HMAC is the password of this token.
	HMAC []byte

	// Renewers is a list of users that can renew this token.
	Renewers []DescribeDelegationTokenResponseTokenDetailRenewer
}

// DescribeDelegationTokenResponsee is a response to a DescribeDelegationTokenRequest.
type DescribeDelegationTokenResponse struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	// ErrorCode is any error that caused the request to fail.
	ErrorCode int16

	// TokenDetails shows information about each token created from any principal
	// in the request.
	TokenDetails []DescribeDelegationTokenResponseTokenDetail

	// ThrottleMillis is how long of a throttle Kafka will apply to the client
	// after this request.
	// For Kafka < 2.0.0, the throttle is applied before issuing a response.
	// For Kafka >= 2.0.0, the throttle is applied after issuing a response.
	ThrottleMillis int32
}

func (*DescribeDelegationTokenResponse) Key() int16                 { return 41 }
func (*DescribeDelegationTokenResponse) MaxVersion() int16          { return 2 }
func (v *DescribeDelegationTokenResponse) SetVersion(version int16) { v.Version = version }
func (v *DescribeDelegationTokenResponse) GetVersion() int16        { return v.Version }
func (v *DescribeDelegationTokenResponse) IsFlexible() bool         { return v.Version >= 2 }
func (v *DescribeDelegationTokenResponse) RequestKind() Request {
	return &DescribeDelegationTokenRequest{Version: v.Version}
}

func (v *DescribeDelegationTokenResponse) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	isFlexible := version >= 2
	_ = isFlexible
	{
		v := v.ErrorCode
		dst = kbin.AppendInt16(dst, v)
	}
	{
		v := v.TokenDetails
		if isFlexible {
			dst = kbin.AppendCompactArrayLen(dst, len(v))
		} else {
			dst = kbin.AppendArrayLen(dst, len(v))
		}
		for i := range v {
			v := &v[i]
			{
				v := v.PrincipalType
				if isFlexible {
					dst = kbin.AppendCompactString(dst, v)
				} else {
					dst = kbin.AppendString(dst, v)
				}
			}
			{
				v := v.PrincipalName
				if isFlexible {
					dst = kbin.AppendCompactString(dst, v)
				} else {
					dst = kbin.AppendString(dst, v)
				}
			}
			{
				v := v.IssueTimestamp
				dst = kbin.AppendInt64(dst, v)
			}
			{
				v := v.ExpiryTimestamp
				dst = kbin.AppendInt64(dst, v)
			}
			{
				v := v.MaxTimestamp
				dst = kbin.AppendInt64(dst, v)
			}
			{
				v := v.TokenID
				if isFlexible {
					dst = kbin.AppendCompactString(dst, v)
				} else {
					dst = kbin.AppendString(dst, v)
				}
			}
			{
				v := v.HMAC
				if isFlexible {
					dst = kbin.AppendCompactBytes(dst, v)
				} else {
					dst = kbin.AppendBytes(dst, v)
				}
			}
			{
				v := v.Renewers
				if isFlexible {
					dst = kbin.AppendCompactArrayLen(dst, len(v))
				} else {
					dst = kbin.AppendArrayLen(dst, len(v))
				}
				for i := range v {
					v := &v[i]
					{
						v := v.PrincipalType
						if isFlexible {
							dst = kbin.AppendCompactString(dst, v)
						} else {
							dst = kbin.AppendString(dst, v)
						}
					}
					{
						v := v.PrincipalName
						if isFlexible {
							dst = kbin.AppendCompactString(dst, v)
						} else {
							dst = kbin.AppendString(dst, v)
						}
					}
					if isFlexible {
						dst = kbin.AppendUvarint(dst, 0)
					}
				}
			}
			if isFlexible {
				dst = kbin.AppendUvarint(dst, 0)
			}
		}
	}
	{
		v := v.ThrottleMillis
		dst = kbin.AppendInt32(dst, v)
	}
	if isFlexible {
		dst = kbin.AppendUvarint(dst, 0)
	}
	return dst
}
func (v *DescribeDelegationTokenResponse) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	isFlexible := version >= 2
	_ = isFlexible
	b := kbin.Reader{Src: src}
	s := v
	{
		v := b.Int16()
		s.ErrorCode = v
	}
	{
		v := s.TokenDetails
		a := v
		var l int32
		if isFlexible {
			l = b.CompactArrayLen()
		} else {
			l = b.ArrayLen()
		}
		if !b.Ok() {
			return b.Complete()
		}
		if l > 0 {
			a = make([]DescribeDelegationTokenResponseTokenDetail, l)
		}
		for i := int32(0); i < l; i++ {
			v := &a[i]
			s := v
			{
				var v string
				if isFlexible {
					v = b.CompactString()
				} else {
					v = b.String()
				}
				s.PrincipalType = v
			}
			{
				var v string
				if isFlexible {
					v = b.CompactString()
				} else {
					v = b.String()
				}
				s.PrincipalName = v
			}
			{
				v := b.Int64()
				s.IssueTimestamp = v
			}
			{
				v := b.Int64()
				s.ExpiryTimestamp = v
			}
			{
				v := b.Int64()
				s.MaxTimestamp = v
			}
			{
				var v string
				if isFlexible {
					v = b.CompactString()
				} else {
					v = b.String()
				}
				s.TokenID = v
			}
			{
				var v []byte
				if isFlexible {
					v = b.CompactBytes()
				} else {
					v = b.Bytes()
				}
				s.HMAC = v
			}
			{
				v := s.Renewers
				a := v
				var l int32
				if isFlexible {
					l = b.CompactArrayLen()
				} else {
					l = b.ArrayLen()
				}
				if !b.Ok() {
					return b.Complete()
				}
				if l > 0 {
					a = make([]DescribeDelegationTokenResponseTokenDetailRenewer, l)
				}
				for i := int32(0); i < l; i++ {
					v := &a[i]
					s := v
					{
						var v string
						if isFlexible {
							v = b.CompactString()
						} else {
							v = b.String()
						}
						s.PrincipalType = v
					}
					{
						var v string
						if isFlexible {
							v = b.CompactString()
						} else {
							v = b.String()
						}
						s.PrincipalName = v
					}
					if isFlexible {
						SkipTags(&b)
					}
				}
				v = a
				s.Renewers = v
			}
			if isFlexible {
				SkipTags(&b)
			}
		}
		v = a
		s.TokenDetails = v
	}
	{
		v := b.Int32()
		s.ThrottleMillis = v
	}
	if isFlexible {
		SkipTags(&b)
	}
	return b.Complete()
}

// DeleteGroupsRequest deletes consumer groups. This request was added for
// Kafka 1.1.0 corresponding to the removal of RetentionTimeMillis from
// OffsetCommitRequest. See KIP-229 for more details.
type DeleteGroupsRequest struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	// Groups is a list of groups to delete.
	Groups []string
}

func (*DeleteGroupsRequest) Key() int16                   { return 42 }
func (*DeleteGroupsRequest) MaxVersion() int16            { return 2 }
func (v *DeleteGroupsRequest) SetVersion(version int16)   { v.Version = version }
func (v *DeleteGroupsRequest) GetVersion() int16          { return v.Version }
func (v *DeleteGroupsRequest) IsFlexible() bool           { return v.Version >= 2 }
func (v *DeleteGroupsRequest) IsGroupCoordinatorRequest() {}
func (v *DeleteGroupsRequest) ResponseKind() Response {
	return &DeleteGroupsResponse{Version: v.Version}
}

func (v *DeleteGroupsRequest) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	isFlexible := version >= 2
	_ = isFlexible
	{
		v := v.Groups
		if isFlexible {
			dst = kbin.AppendCompactArrayLen(dst, len(v))
		} else {
			dst = kbin.AppendArrayLen(dst, len(v))
		}
		for i := range v {
			v := v[i]
			if isFlexible {
				dst = kbin.AppendCompactString(dst, v)
			} else {
				dst = kbin.AppendString(dst, v)
			}
		}
	}
	if isFlexible {
		dst = kbin.AppendUvarint(dst, 0)
	}
	return dst
}
func (v *DeleteGroupsRequest) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	isFlexible := version >= 2
	_ = isFlexible
	b := kbin.Reader{Src: src}
	s := v
	{
		v := s.Groups
		a := v
		var l int32
		if isFlexible {
			l = b.CompactArrayLen()
		} else {
			l = b.ArrayLen()
		}
		if !b.Ok() {
			return b.Complete()
		}
		if l > 0 {
			a = make([]string, l)
		}
		for i := int32(0); i < l; i++ {
			var v string
			if isFlexible {
				v = b.CompactString()
			} else {
				v = b.String()
			}
			a[i] = v
		}
		v = a
		s.Groups = v
	}
	if isFlexible {
		SkipTags(&b)
	}
	return b.Complete()
}

type DeleteGroupsResponseGroup struct {
	// Group is a group ID requested for deletion.
	Group string

	// ErrorCode is the error code returned for this group's deletion request.
	//
	// GROUP_AUTHORIZATION_FAILED is returned if the client is not authorized
	// to delete a group.
	//
	// INVALID_GROUP_ID is returned if the requested group ID is invalid.
	//
	// COORDINATOR_NOT_AVAILABLE is returned if the coordinator for this
	// group is not yet active.
	//
	// GROUP_ID_NOT_FOUND is returned if the group ID does not exist.
	//
	// NON_EMPTY_GROUP is returned if attempting to delete a group that is
	// not in the empty state.
	ErrorCode int16
}

// DeleteGroupsResponse is returned from a DeleteGroupsRequest.
type DeleteGroupsResponse struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	// ThrottleMillis is how long of a throttle Kafka will apply to the client
	// after this request.
	// For Kafka < 2.0.0, the throttle is applied before issuing a response.
	// For Kafka >= 2.0.0, the throttle is applied after issuing a response.
	ThrottleMillis int32

	// Groups are the responses to each group requested for deletion.
	Groups []DeleteGroupsResponseGroup
}

func (*DeleteGroupsResponse) Key() int16                 { return 42 }
func (*DeleteGroupsResponse) MaxVersion() int16          { return 2 }
func (v *DeleteGroupsResponse) SetVersion(version int16) { v.Version = version }
func (v *DeleteGroupsResponse) GetVersion() int16        { return v.Version }
func (v *DeleteGroupsResponse) IsFlexible() bool         { return v.Version >= 2 }
func (v *DeleteGroupsResponse) RequestKind() Request     { return &DeleteGroupsRequest{Version: v.Version} }

func (v *DeleteGroupsResponse) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	isFlexible := version >= 2
	_ = isFlexible
	{
		v := v.ThrottleMillis
		dst = kbin.AppendInt32(dst, v)
	}
	{
		v := v.Groups
		if isFlexible {
			dst = kbin.AppendCompactArrayLen(dst, len(v))
		} else {
			dst = kbin.AppendArrayLen(dst, len(v))
		}
		for i := range v {
			v := &v[i]
			{
				v := v.Group
				if isFlexible {
					dst = kbin.AppendCompactString(dst, v)
				} else {
					dst = kbin.AppendString(dst, v)
				}
			}
			{
				v := v.ErrorCode
				dst = kbin.AppendInt16(dst, v)
			}
			if isFlexible {
				dst = kbin.AppendUvarint(dst, 0)
			}
		}
	}
	if isFlexible {
		dst = kbin.AppendUvarint(dst, 0)
	}
	return dst
}
func (v *DeleteGroupsResponse) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	isFlexible := version >= 2
	_ = isFlexible
	b := kbin.Reader{Src: src}
	s := v
	{
		v := b.Int32()
		s.ThrottleMillis = v
	}
	{
		v := s.Groups
		a := v
		var l int32
		if isFlexible {
			l = b.CompactArrayLen()
		} else {
			l = b.ArrayLen()
		}
		if !b.Ok() {
			return b.Complete()
		}
		if l > 0 {
			a = make([]DeleteGroupsResponseGroup, l)
		}
		for i := int32(0); i < l; i++ {
			v := &a[i]
			s := v
			{
				var v string
				if isFlexible {
					v = b.CompactString()
				} else {
					v = b.String()
				}
				s.Group = v
			}
			{
				v := b.Int16()
				s.ErrorCode = v
			}
			if isFlexible {
				SkipTags(&b)
			}
		}
		v = a
		s.Groups = v
	}
	if isFlexible {
		SkipTags(&b)
	}
	return b.Complete()
}

type ElectLeadersRequestTopic struct {
	// Topic is a topic to trigger leader elections for (but only for the
	// partitions below).
	Topic string

	// Partitions is an array of partitions in a topic to trigger leader
	// elections for.
	Partitions []int32
}

// ElectLeadersRequest begins a leader election for all given topic
// partitions. This request was added in Kafka 2.2.0 to replace the zookeeper
// only option of triggering leader elections before. See KIP-183 for more
// details. KIP-460 introduced the ElectionType field with Kafka 2.4.0.
type ElectLeadersRequest struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	// ElectionType is the type of election to conduct. 0 elects the preferred
	// replica, 1 elects the first live replica if there are no in-sync replicas
	// (i.e., unclean leader election).
	ElectionType int8 // v1+

	// Topics is an array of topics and corresponding partitions to
	// trigger leader elections for, or null for all.
	Topics []ElectLeadersRequestTopic

	// TimeoutMillis is how long to wait for the response. This limits how long to
	// wait since responses are not sent until election results are complete.
	TimeoutMillis int32
}

func (*ElectLeadersRequest) Key() int16                 { return 43 }
func (*ElectLeadersRequest) MaxVersion() int16          { return 2 }
func (v *ElectLeadersRequest) SetVersion(version int16) { v.Version = version }
func (v *ElectLeadersRequest) GetVersion() int16        { return v.Version }
func (v *ElectLeadersRequest) IsFlexible() bool         { return v.Version >= 2 }
func (v *ElectLeadersRequest) IsAdminRequest()          {}
func (v *ElectLeadersRequest) ResponseKind() Response {
	return &ElectLeadersResponse{Version: v.Version}
}

func (v *ElectLeadersRequest) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	isFlexible := version >= 2
	_ = isFlexible
	if version >= 1 {
		v := v.ElectionType
		dst = kbin.AppendInt8(dst, v)
	}
	{
		v := v.Topics
		if isFlexible {
			dst = kbin.AppendCompactNullableArrayLen(dst, len(v), v == nil)
		} else {
			dst = kbin.AppendNullableArrayLen(dst, len(v), v == nil)
		}
		for i := range v {
			v := &v[i]
			{
				v := v.Topic
				if isFlexible {
					dst = kbin.AppendCompactString(dst, v)
				} else {
					dst = kbin.AppendString(dst, v)
				}
			}
			{
				v := v.Partitions
				if isFlexible {
					dst = kbin.AppendCompactArrayLen(dst, len(v))
				} else {
					dst = kbin.AppendArrayLen(dst, len(v))
				}
				for i := range v {
					v := v[i]
					dst = kbin.AppendInt32(dst, v)
				}
			}
			if isFlexible {
				dst = kbin.AppendUvarint(dst, 0)
			}
		}
	}
	{
		v := v.TimeoutMillis
		dst = kbin.AppendInt32(dst, v)
	}
	if isFlexible {
		dst = kbin.AppendUvarint(dst, 0)
	}
	return dst
}
func (v *ElectLeadersRequest) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	isFlexible := version >= 2
	_ = isFlexible
	b := kbin.Reader{Src: src}
	s := v
	if version >= 1 {
		v := b.Int8()
		s.ElectionType = v
	}
	{
		v := s.Topics
		a := v
		var l int32
		if isFlexible {
			l = b.CompactArrayLen()
		} else {
			l = b.ArrayLen()
		}
		if version < 0 || l == 0 {
			a = []ElectLeadersRequestTopic{}
		}
		if !b.Ok() {
			return b.Complete()
		}
		if l > 0 {
			a = make([]ElectLeadersRequestTopic, l)
		}
		for i := int32(0); i < l; i++ {
			v := &a[i]
			s := v
			{
				var v string
				if isFlexible {
					v = b.CompactString()
				} else {
					v = b.String()
				}
				s.Topic = v
			}
			{
				v := s.Partitions
				a := v
				var l int32
				if isFlexible {
					l = b.CompactArrayLen()
				} else {
					l = b.ArrayLen()
				}
				if !b.Ok() {
					return b.Complete()
				}
				if l > 0 {
					a = make([]int32, l)
				}
				for i := int32(0); i < l; i++ {
					v := b.Int32()
					a[i] = v
				}
				v = a
				s.Partitions = v
			}
			if isFlexible {
				SkipTags(&b)
			}
		}
		v = a
		s.Topics = v
	}
	{
		v := b.Int32()
		s.TimeoutMillis = v
	}
	if isFlexible {
		SkipTags(&b)
	}
	return b.Complete()
}

type ElectLeadersResponseTopicPartition struct {
	// Partition is the partition for this result.
	Partition int32

	// ErrorCode is the error code returned for this topic/partition leader
	// election.
	//
	// CLUSTER_AUTHORIZATION_FAILED is returned if the client is not
	// authorized to trigger leader elections.
	//
	// NOT_CONTROLLER is returned if the request was not issued to a Kafka
	// controller.
	//
	// UNKNOWN_TOPIC_OR_PARTITION is returned if the topic/partition does
	// not exist on any broker in the cluster (this is slightly different
	// from the usual meaning of a single broker not knowing of the topic
	// partition).
	//
	// PREFERRED_LEADER_NOT_AVAILABLE is returned if the preferred leader
	// could not be elected (for example, the preferred leader was not in
	// the ISR).
	ErrorCode int16

	// ErrorMessage is an informative message if the leader election failed.
	ErrorMessage *string
}
type ElectLeadersResponseTopic struct {
	// Topic is topic for the given partition results below.
	Topic string

	// Partitions contains election results for a topic's partitions.
	Partitions []ElectLeadersResponseTopicPartition
}

// ElectLeadersResponse is a response for an ElectLeadersRequest.
type ElectLeadersResponse struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	// ThrottleMillis is how long of a throttle Kafka will apply to the client
	// after responding to this request.
	ThrottleMillis int32

	// ErrorCode is any error that applies to all partitions.
	//
	// CLUSTER_AUTHORIZATION_FAILED is returned if the client is not
	// authorized to reassign partitions.
	ErrorCode int16 // v1+

	// Topics contains leader election results for each requested topic.
	Topics []ElectLeadersResponseTopic
}

func (*ElectLeadersResponse) Key() int16                 { return 43 }
func (*ElectLeadersResponse) MaxVersion() int16          { return 2 }
func (v *ElectLeadersResponse) SetVersion(version int16) { v.Version = version }
func (v *ElectLeadersResponse) GetVersion() int16        { return v.Version }
func (v *ElectLeadersResponse) IsFlexible() bool         { return v.Version >= 2 }
func (v *ElectLeadersResponse) RequestKind() Request     { return &ElectLeadersRequest{Version: v.Version} }

func (v *ElectLeadersResponse) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	isFlexible := version >= 2
	_ = isFlexible
	{
		v := v.ThrottleMillis
		dst = kbin.AppendInt32(dst, v)
	}
	if version >= 1 {
		v := v.ErrorCode
		dst = kbin.AppendInt16(dst, v)
	}
	{
		v := v.Topics
		if isFlexible {
			dst = kbin.AppendCompactArrayLen(dst, len(v))
		} else {
			dst = kbin.AppendArrayLen(dst, len(v))
		}
		for i := range v {
			v := &v[i]
			{
				v := v.Topic
				if isFlexible {
					dst = kbin.AppendCompactString(dst, v)
				} else {
					dst = kbin.AppendString(dst, v)
				}
			}
			{
				v := v.Partitions
				if isFlexible {
					dst = kbin.AppendCompactArrayLen(dst, len(v))
				} else {
					dst = kbin.AppendArrayLen(dst, len(v))
				}
				for i := range v {
					v := &v[i]
					{
						v := v.Partition
						dst = kbin.AppendInt32(dst, v)
					}
					{
						v := v.ErrorCode
						dst = kbin.AppendInt16(dst, v)
					}
					{
						v := v.ErrorMessage
						if isFlexible {
							dst = kbin.AppendCompactNullableString(dst, v)
						} else {
							dst = kbin.AppendNullableString(dst, v)
						}
					}
					if isFlexible {
						dst = kbin.AppendUvarint(dst, 0)
					}
				}
			}
			if isFlexible {
				dst = kbin.AppendUvarint(dst, 0)
			}
		}
	}
	if isFlexible {
		dst = kbin.AppendUvarint(dst, 0)
	}
	return dst
}
func (v *ElectLeadersResponse) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	isFlexible := version >= 2
	_ = isFlexible
	b := kbin.Reader{Src: src}
	s := v
	{
		v := b.Int32()
		s.ThrottleMillis = v
	}
	if version >= 1 {
		v := b.Int16()
		s.ErrorCode = v
	}
	{
		v := s.Topics
		a := v
		var l int32
		if isFlexible {
			l = b.CompactArrayLen()
		} else {
			l = b.ArrayLen()
		}
		if !b.Ok() {
			return b.Complete()
		}
		if l > 0 {
			a = make([]ElectLeadersResponseTopic, l)
		}
		for i := int32(0); i < l; i++ {
			v := &a[i]
			s := v
			{
				var v string
				if isFlexible {
					v = b.CompactString()
				} else {
					v = b.String()
				}
				s.Topic = v
			}
			{
				v := s.Partitions
				a := v
				var l int32
				if isFlexible {
					l = b.CompactArrayLen()
				} else {
					l = b.ArrayLen()
				}
				if !b.Ok() {
					return b.Complete()
				}
				if l > 0 {
					a = make([]ElectLeadersResponseTopicPartition, l)
				}
				for i := int32(0); i < l; i++ {
					v := &a[i]
					s := v
					{
						v := b.Int32()
						s.Partition = v
					}
					{
						v := b.Int16()
						s.ErrorCode = v
					}
					{
						var v *string
						if isFlexible {
							v = b.CompactNullableString()
						} else {
							v = b.NullableString()
						}
						s.ErrorMessage = v
					}
					if isFlexible {
						SkipTags(&b)
					}
				}
				v = a
				s.Partitions = v
			}
			if isFlexible {
				SkipTags(&b)
			}
		}
		v = a
		s.Topics = v
	}
	if isFlexible {
		SkipTags(&b)
	}
	return b.Complete()
}

type IncrementalAlterConfigsRequestResourceConfig struct {
	// Name is a key to modify (e.g. segment.bytes).
	//
	// For broker loggers, see KIP-412 section "Request/Response Overview"
	// for details on how to change per logger log levels.
	Name string

	// Op is the type of operation to perform for this config name.
	//
	// SET (0) is to set a configuration value; the value must not be null.
	//
	// DELETE (1) is to delete a configuration key.
	//
	// APPEND (2) is to add a value to the list of values for a key (if the
	// key is for a list of values).
	//
	// SUBTRACT (3) is to remove a value from a list of values (if the key
	// is for a list of values).
	Op int8

	// Value is a value to set for the key (e.g. 10).
	Value *string
}
type IncrementalAlterConfigsRequestResource struct {
	// ResourceType is an enum corresponding to the type of config to alter.
	// The possible valid values are 2 (for topic), 4 (for broker),
	// and 8 (for broker logger).
	ResourceType int8

	// ResourceName is the name of config to alter.
	//
	// If the requested type is a topic, this corresponds to a topic name.
	//
	// If the requested type if a broker, this should either be empty or be
	// the ID of the broker this request is issued to. If it is empty, this
	// updates all broker configs. If a specific ID, this updates just the
	// broker. Using a specific ID also ensures that brokers reload config
	// or secret files even if the file path has not changed. Lastly, password
	// config options can only be defined on a per broker basis.
	//
	// If the type is broker logger, this must be a broker ID.
	ResourceName string

	// Configs contains key/value config pairs to set on the resource.
	Configs []IncrementalAlterConfigsRequestResourceConfig
}

// IncrementalAlterConfigsRequest issues ar equest to alter either topic or
// broker configs.
//
// This API was added in Kafka 2.3.0 to replace AlterConfigs. The key benefit
// of this API is that consumers do not need to know the full config state
// to add or remove new config options. See KIP-339 for more details.
type IncrementalAlterConfigsRequest struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	// Resources is an array of configs to alter.
	Resources []IncrementalAlterConfigsRequestResource

	// ValidateOnly validates the request but does not apply it.
	ValidateOnly bool
}

func (*IncrementalAlterConfigsRequest) Key() int16                 { return 44 }
func (*IncrementalAlterConfigsRequest) MaxVersion() int16          { return 1 }
func (v *IncrementalAlterConfigsRequest) SetVersion(version int16) { v.Version = version }
func (v *IncrementalAlterConfigsRequest) GetVersion() int16        { return v.Version }
func (v *IncrementalAlterConfigsRequest) IsFlexible() bool         { return v.Version >= 1 }
func (v *IncrementalAlterConfigsRequest) ResponseKind() Response {
	return &IncrementalAlterConfigsResponse{Version: v.Version}
}

func (v *IncrementalAlterConfigsRequest) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	isFlexible := version >= 1
	_ = isFlexible
	{
		v := v.Resources
		if isFlexible {
			dst = kbin.AppendCompactArrayLen(dst, len(v))
		} else {
			dst = kbin.AppendArrayLen(dst, len(v))
		}
		for i := range v {
			v := &v[i]
			{
				v := v.ResourceType
				dst = kbin.AppendInt8(dst, v)
			}
			{
				v := v.ResourceName
				if isFlexible {
					dst = kbin.AppendCompactString(dst, v)
				} else {
					dst = kbin.AppendString(dst, v)
				}
			}
			{
				v := v.Configs
				if isFlexible {
					dst = kbin.AppendCompactArrayLen(dst, len(v))
				} else {
					dst = kbin.AppendArrayLen(dst, len(v))
				}
				for i := range v {
					v := &v[i]
					{
						v := v.Name
						if isFlexible {
							dst = kbin.AppendCompactString(dst, v)
						} else {
							dst = kbin.AppendString(dst, v)
						}
					}
					{
						v := v.Op
						dst = kbin.AppendInt8(dst, v)
					}
					{
						v := v.Value
						if isFlexible {
							dst = kbin.AppendCompactNullableString(dst, v)
						} else {
							dst = kbin.AppendNullableString(dst, v)
						}
					}
					if isFlexible {
						dst = kbin.AppendUvarint(dst, 0)
					}
				}
			}
			if isFlexible {
				dst = kbin.AppendUvarint(dst, 0)
			}
		}
	}
	{
		v := v.ValidateOnly
		dst = kbin.AppendBool(dst, v)
	}
	if isFlexible {
		dst = kbin.AppendUvarint(dst, 0)
	}
	return dst
}
func (v *IncrementalAlterConfigsRequest) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	isFlexible := version >= 1
	_ = isFlexible
	b := kbin.Reader{Src: src}
	s := v
	{
		v := s.Resources
		a := v
		var l int32
		if isFlexible {
			l = b.CompactArrayLen()
		} else {
			l = b.ArrayLen()
		}
		if !b.Ok() {
			return b.Complete()
		}
		if l > 0 {
			a = make([]IncrementalAlterConfigsRequestResource, l)
		}
		for i := int32(0); i < l; i++ {
			v := &a[i]
			s := v
			{
				v := b.Int8()
				s.ResourceType = v
			}
			{
				var v string
				if isFlexible {
					v = b.CompactString()
				} else {
					v = b.String()
				}
				s.ResourceName = v
			}
			{
				v := s.Configs
				a := v
				var l int32
				if isFlexible {
					l = b.CompactArrayLen()
				} else {
					l = b.ArrayLen()
				}
				if !b.Ok() {
					return b.Complete()
				}
				if l > 0 {
					a = make([]IncrementalAlterConfigsRequestResourceConfig, l)
				}
				for i := int32(0); i < l; i++ {
					v := &a[i]
					s := v
					{
						var v string
						if isFlexible {
							v = b.CompactString()
						} else {
							v = b.String()
						}
						s.Name = v
					}
					{
						v := b.Int8()
						s.Op = v
					}
					{
						var v *string
						if isFlexible {
							v = b.CompactNullableString()
						} else {
							v = b.NullableString()
						}
						s.Value = v
					}
					if isFlexible {
						SkipTags(&b)
					}
				}
				v = a
				s.Configs = v
			}
			if isFlexible {
				SkipTags(&b)
			}
		}
		v = a
		s.Resources = v
	}
	{
		v := b.Bool()
		s.ValidateOnly = v
	}
	if isFlexible {
		SkipTags(&b)
	}
	return b.Complete()
}

type IncrementalAlterConfigsResponseResource struct {
	// ErrorCode is the error code returned for incrementally altering configs.
	//
	// CLUSTER_AUTHORIZATION_FAILED is returned if asking to alter broker
	// configs but the client is not authorized to do so.
	//
	// TOPIC_AUTHORIZATION_FAILED is returned if asking to alter topic
	// configs but the client is not authorized to do so.
	//
	// INVALID_TOPIC_EXCEPTION is returned if the requested topic was invalid.
	//
	// UNKNOWN_TOPIC_OR_PARTITION is returned if the broker does not know of
	// the requested topic.
	//
	// INVALID_REQUEST is returned if the requested config is invalid or if
	// asking Kafka to alter an invalid resource.
	ErrorCode int16

	// ErrorMessage is an informative message if the incremental alter config failed.
	ErrorMessage *string

	// ResourceType is the enum corresponding to the type of altered config.
	ResourceType int8

	// ResourceName is the name corresponding to the incremental alter config
	// request.
	ResourceName string
}

// IncrementalAlterConfigsResponse is returned from an IncrementalAlterConfigsRequest.
type IncrementalAlterConfigsResponse struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	// ThrottleMillis is how long of a throttle Kafka will apply to the client
	// after responding to this request.
	ThrottleMillis int32

	// Resources are responses for each resources in the alter request.
	Resources []IncrementalAlterConfigsResponseResource
}

func (*IncrementalAlterConfigsResponse) Key() int16                 { return 44 }
func (*IncrementalAlterConfigsResponse) MaxVersion() int16          { return 1 }
func (v *IncrementalAlterConfigsResponse) SetVersion(version int16) { v.Version = version }
func (v *IncrementalAlterConfigsResponse) GetVersion() int16        { return v.Version }
func (v *IncrementalAlterConfigsResponse) IsFlexible() bool         { return v.Version >= 1 }
func (v *IncrementalAlterConfigsResponse) RequestKind() Request {
	return &IncrementalAlterConfigsRequest{Version: v.Version}
}

func (v *IncrementalAlterConfigsResponse) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	isFlexible := version >= 1
	_ = isFlexible
	{
		v := v.ThrottleMillis
		dst = kbin.AppendInt32(dst, v)
	}
	{
		v := v.Resources
		if isFlexible {
			dst = kbin.AppendCompactArrayLen(dst, len(v))
		} else {
			dst = kbin.AppendArrayLen(dst, len(v))
		}
		for i := range v {
			v := &v[i]
			{
				v := v.ErrorCode
				dst = kbin.AppendInt16(dst, v)
			}
			{
				v := v.ErrorMessage
				if isFlexible {
					dst = kbin.AppendCompactNullableString(dst, v)
				} else {
					dst = kbin.AppendNullableString(dst, v)
				}
			}
			{
				v := v.ResourceType
				dst = kbin.AppendInt8(dst, v)
			}
			{
				v := v.ResourceName
				if isFlexible {
					dst = kbin.AppendCompactString(dst, v)
				} else {
					dst = kbin.AppendString(dst, v)
				}
			}
			if isFlexible {
				dst = kbin.AppendUvarint(dst, 0)
			}
		}
	}
	if isFlexible {
		dst = kbin.AppendUvarint(dst, 0)
	}
	return dst
}
func (v *IncrementalAlterConfigsResponse) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	isFlexible := version >= 1
	_ = isFlexible
	b := kbin.Reader{Src: src}
	s := v
	{
		v := b.Int32()
		s.ThrottleMillis = v
	}
	{
		v := s.Resources
		a := v
		var l int32
		if isFlexible {
			l = b.CompactArrayLen()
		} else {
			l = b.ArrayLen()
		}
		if !b.Ok() {
			return b.Complete()
		}
		if l > 0 {
			a = make([]IncrementalAlterConfigsResponseResource, l)
		}
		for i := int32(0); i < l; i++ {
			v := &a[i]
			s := v
			{
				v := b.Int16()
				s.ErrorCode = v
			}
			{
				var v *string
				if isFlexible {
					v = b.CompactNullableString()
				} else {
					v = b.NullableString()
				}
				s.ErrorMessage = v
			}
			{
				v := b.Int8()
				s.ResourceType = v
			}
			{
				var v string
				if isFlexible {
					v = b.CompactString()
				} else {
					v = b.String()
				}
				s.ResourceName = v
			}
			if isFlexible {
				SkipTags(&b)
			}
		}
		v = a
		s.Resources = v
	}
	if isFlexible {
		SkipTags(&b)
	}
	return b.Complete()
}

type AlterPartitionAssignmentsRequestTopicPartition struct {
	// Partition is a partition to reassign.
	Partition int32

	// Replicas are replicas to place the partition on, or null to
	// cancel a pending reassignment of this partition.
	Replicas []int32
}
type AlterPartitionAssignmentsRequestTopic struct {
	// Topic is a topic to reassign the partitions of.
	Topic string

	// Partitions contains partitions to reassign.
	Partitions []AlterPartitionAssignmentsRequestTopicPartition
}

// AlterPartitionAssignmentsRequest, proposed in KIP-455 and implemented in
// Kafka 2.4.0, is a request to reassign partitions to certain brokers.
//
// ACL wise, this requires ALTER on CLUSTER.
type AlterPartitionAssignmentsRequest struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	// TimeoutMillis is how long to wait for the response.
	TimeoutMillis int32

	// Topics are topics for which to reassign partitions of.
	Topics []AlterPartitionAssignmentsRequestTopic
}

func (*AlterPartitionAssignmentsRequest) Key() int16                 { return 45 }
func (*AlterPartitionAssignmentsRequest) MaxVersion() int16          { return 0 }
func (v *AlterPartitionAssignmentsRequest) SetVersion(version int16) { v.Version = version }
func (v *AlterPartitionAssignmentsRequest) GetVersion() int16        { return v.Version }
func (v *AlterPartitionAssignmentsRequest) IsFlexible() bool         { return v.Version >= 0 }
func (v *AlterPartitionAssignmentsRequest) IsAdminRequest()          {}
func (v *AlterPartitionAssignmentsRequest) ResponseKind() Response {
	return &AlterPartitionAssignmentsResponse{Version: v.Version}
}

func (v *AlterPartitionAssignmentsRequest) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	isFlexible := version >= 0
	_ = isFlexible
	{
		v := v.TimeoutMillis
		dst = kbin.AppendInt32(dst, v)
	}
	{
		v := v.Topics
		if isFlexible {
			dst = kbin.AppendCompactArrayLen(dst, len(v))
		} else {
			dst = kbin.AppendArrayLen(dst, len(v))
		}
		for i := range v {
			v := &v[i]
			{
				v := v.Topic
				if isFlexible {
					dst = kbin.AppendCompactString(dst, v)
				} else {
					dst = kbin.AppendString(dst, v)
				}
			}
			{
				v := v.Partitions
				if isFlexible {
					dst = kbin.AppendCompactArrayLen(dst, len(v))
				} else {
					dst = kbin.AppendArrayLen(dst, len(v))
				}
				for i := range v {
					v := &v[i]
					{
						v := v.Partition
						dst = kbin.AppendInt32(dst, v)
					}
					{
						v := v.Replicas
						if isFlexible {
							dst = kbin.AppendCompactNullableArrayLen(dst, len(v), v == nil)
						} else {
							dst = kbin.AppendNullableArrayLen(dst, len(v), v == nil)
						}
						for i := range v {
							v := v[i]
							dst = kbin.AppendInt32(dst, v)
						}
					}
					if isFlexible {
						dst = kbin.AppendUvarint(dst, 0)
					}
				}
			}
			if isFlexible {
				dst = kbin.AppendUvarint(dst, 0)
			}
		}
	}
	if isFlexible {
		dst = kbin.AppendUvarint(dst, 0)
	}
	return dst
}
func (v *AlterPartitionAssignmentsRequest) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	isFlexible := version >= 0
	_ = isFlexible
	b := kbin.Reader{Src: src}
	s := v
	{
		v := b.Int32()
		s.TimeoutMillis = v
	}
	{
		v := s.Topics
		a := v
		var l int32
		if isFlexible {
			l = b.CompactArrayLen()
		} else {
			l = b.ArrayLen()
		}
		if !b.Ok() {
			return b.Complete()
		}
		if l > 0 {
			a = make([]AlterPartitionAssignmentsRequestTopic, l)
		}
		for i := int32(0); i < l; i++ {
			v := &a[i]
			s := v
			{
				var v string
				if isFlexible {
					v = b.CompactString()
				} else {
					v = b.String()
				}
				s.Topic = v
			}
			{
				v := s.Partitions
				a := v
				var l int32
				if isFlexible {
					l = b.CompactArrayLen()
				} else {
					l = b.ArrayLen()
				}
				if !b.Ok() {
					return b.Complete()
				}
				if l > 0 {
					a = make([]AlterPartitionAssignmentsRequestTopicPartition, l)
				}
				for i := int32(0); i < l; i++ {
					v := &a[i]
					s := v
					{
						v := b.Int32()
						s.Partition = v
					}
					{
						v := s.Replicas
						a := v
						var l int32
						if isFlexible {
							l = b.CompactArrayLen()
						} else {
							l = b.ArrayLen()
						}
						if version < 0 || l == 0 {
							a = []int32{}
						}
						if !b.Ok() {
							return b.Complete()
						}
						if l > 0 {
							a = make([]int32, l)
						}
						for i := int32(0); i < l; i++ {
							v := b.Int32()
							a[i] = v
						}
						v = a
						s.Replicas = v
					}
					if isFlexible {
						SkipTags(&b)
					}
				}
				v = a
				s.Partitions = v
			}
			if isFlexible {
				SkipTags(&b)
			}
		}
		v = a
		s.Topics = v
	}
	if isFlexible {
		SkipTags(&b)
	}
	return b.Complete()
}

type AlterPartitionAssignmentsResponseTopicPartition struct {
	// Partition is the partition being responded to.
	Partition int32

	// ErrorCode is the error code returned for partition reassignments.
	//
	// REQUEST_TIMED_OUT is returned if the request timed out.
	//
	// NOT_CONTROLLER is returned if the request was not issued to a Kafka
	// controller.
	//
	// CLUSTER_AUTHORIZATION_FAILED is returned if the client is not
	// authorized to reassign partitions.
	//
	// NO_REASSIGNMENT_IN_PROGRESS is returned for partition reassignment
	// cancellations when the partition was not being reassigned.
	//
	// UNKNOWN_TOPIC_OR_PARTITION is returned if the broker does not know of
	// the requested topic or the topic is being deleted.
	ErrorCode int16

	// ErrorMessage is an informative message if the partition reassignment failed.
	ErrorMessage *string
}
type AlterPartitionAssignmentsResponseTopic struct {
	// Topic is the topic being responded to.
	Topic string

	// Partitions contains responses for partitions.
	Partitions []AlterPartitionAssignmentsResponseTopicPartition
}

// AlterPartitionAssignmentsResponse is returned for an AlterPartitionAssignmentsRequest.
type AlterPartitionAssignmentsResponse struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	// ThrottleMillis is how long of a throttle Kafka will apply to the client
	// after responding to this request.
	ThrottleMillis int32

	// ErrorCode is any global (applied to all partitions) error code.
	ErrorCode int16

	// ErrorMessage is any global (applied to all partitions) error message.
	ErrorMessage *string

	// Topics contains responses for each topic requested.
	Topics []AlterPartitionAssignmentsResponseTopic
}

func (*AlterPartitionAssignmentsResponse) Key() int16                 { return 45 }
func (*AlterPartitionAssignmentsResponse) MaxVersion() int16          { return 0 }
func (v *AlterPartitionAssignmentsResponse) SetVersion(version int16) { v.Version = version }
func (v *AlterPartitionAssignmentsResponse) GetVersion() int16        { return v.Version }
func (v *AlterPartitionAssignmentsResponse) IsFlexible() bool         { return v.Version >= 0 }
func (v *AlterPartitionAssignmentsResponse) RequestKind() Request {
	return &AlterPartitionAssignmentsRequest{Version: v.Version}
}

func (v *AlterPartitionAssignmentsResponse) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	isFlexible := version >= 0
	_ = isFlexible
	{
		v := v.ThrottleMillis
		dst = kbin.AppendInt32(dst, v)
	}
	{
		v := v.ErrorCode
		dst = kbin.AppendInt16(dst, v)
	}
	{
		v := v.ErrorMessage
		if isFlexible {
			dst = kbin.AppendCompactNullableString(dst, v)
		} else {
			dst = kbin.AppendNullableString(dst, v)
		}
	}
	{
		v := v.Topics
		if isFlexible {
			dst = kbin.AppendCompactArrayLen(dst, len(v))
		} else {
			dst = kbin.AppendArrayLen(dst, len(v))
		}
		for i := range v {
			v := &v[i]
			{
				v := v.Topic
				if isFlexible {
					dst = kbin.AppendCompactString(dst, v)
				} else {
					dst = kbin.AppendString(dst, v)
				}
			}
			{
				v := v.Partitions
				if isFlexible {
					dst = kbin.AppendCompactArrayLen(dst, len(v))
				} else {
					dst = kbin.AppendArrayLen(dst, len(v))
				}
				for i := range v {
					v := &v[i]
					{
						v := v.Partition
						dst = kbin.AppendInt32(dst, v)
					}
					{
						v := v.ErrorCode
						dst = kbin.AppendInt16(dst, v)
					}
					{
						v := v.ErrorMessage
						if isFlexible {
							dst = kbin.AppendCompactNullableString(dst, v)
						} else {
							dst = kbin.AppendNullableString(dst, v)
						}
					}
					if isFlexible {
						dst = kbin.AppendUvarint(dst, 0)
					}
				}
			}
			if isFlexible {
				dst = kbin.AppendUvarint(dst, 0)
			}
		}
	}
	if isFlexible {
		dst = kbin.AppendUvarint(dst, 0)
	}
	return dst
}
func (v *AlterPartitionAssignmentsResponse) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	isFlexible := version >= 0
	_ = isFlexible
	b := kbin.Reader{Src: src}
	s := v
	{
		v := b.Int32()
		s.ThrottleMillis = v
	}
	{
		v := b.Int16()
		s.ErrorCode = v
	}
	{
		var v *string
		if isFlexible {
			v = b.CompactNullableString()
		} else {
			v = b.NullableString()
		}
		s.ErrorMessage = v
	}
	{
		v := s.Topics
		a := v
		var l int32
		if isFlexible {
			l = b.CompactArrayLen()
		} else {
			l = b.ArrayLen()
		}
		if !b.Ok() {
			return b.Complete()
		}
		if l > 0 {
			a = make([]AlterPartitionAssignmentsResponseTopic, l)
		}
		for i := int32(0); i < l; i++ {
			v := &a[i]
			s := v
			{
				var v string
				if isFlexible {
					v = b.CompactString()
				} else {
					v = b.String()
				}
				s.Topic = v
			}
			{
				v := s.Partitions
				a := v
				var l int32
				if isFlexible {
					l = b.CompactArrayLen()
				} else {
					l = b.ArrayLen()
				}
				if !b.Ok() {
					return b.Complete()
				}
				if l > 0 {
					a = make([]AlterPartitionAssignmentsResponseTopicPartition, l)
				}
				for i := int32(0); i < l; i++ {
					v := &a[i]
					s := v
					{
						v := b.Int32()
						s.Partition = v
					}
					{
						v := b.Int16()
						s.ErrorCode = v
					}
					{
						var v *string
						if isFlexible {
							v = b.CompactNullableString()
						} else {
							v = b.NullableString()
						}
						s.ErrorMessage = v
					}
					if isFlexible {
						SkipTags(&b)
					}
				}
				v = a
				s.Partitions = v
			}
			if isFlexible {
				SkipTags(&b)
			}
		}
		v = a
		s.Topics = v
	}
	if isFlexible {
		SkipTags(&b)
	}
	return b.Complete()
}

type ListPartitionReassignmentsRequestTopic struct {
	// Topic is a topic to list in progress partition reassingments of.
	Topic string

	// Partitions are partitions to list in progress reassignments of.
	Partitions []int32
}

// ListPartitionReassignmentsRequest, proposed in KIP-455 and implemented in
// Kafka 2.4.0, is a request to list in progress partition reassignments.
//
// ACL wise, this requires DESCRIBE on CLUSTER.
type ListPartitionReassignmentsRequest struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	// TimeoutMillis is how long to wait for the response.
	TimeoutMillis int32

	// Topics are topics to list in progress partition reassignments of, or null
	// to list everything.
	Topics []ListPartitionReassignmentsRequestTopic
}

func (*ListPartitionReassignmentsRequest) Key() int16                 { return 46 }
func (*ListPartitionReassignmentsRequest) MaxVersion() int16          { return 0 }
func (v *ListPartitionReassignmentsRequest) SetVersion(version int16) { v.Version = version }
func (v *ListPartitionReassignmentsRequest) GetVersion() int16        { return v.Version }
func (v *ListPartitionReassignmentsRequest) IsFlexible() bool         { return v.Version >= 0 }
func (v *ListPartitionReassignmentsRequest) IsAdminRequest()          {}
func (v *ListPartitionReassignmentsRequest) ResponseKind() Response {
	return &ListPartitionReassignmentsResponse{Version: v.Version}
}

func (v *ListPartitionReassignmentsRequest) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	isFlexible := version >= 0
	_ = isFlexible
	{
		v := v.TimeoutMillis
		dst = kbin.AppendInt32(dst, v)
	}
	{
		v := v.Topics
		if isFlexible {
			dst = kbin.AppendCompactNullableArrayLen(dst, len(v), v == nil)
		} else {
			dst = kbin.AppendNullableArrayLen(dst, len(v), v == nil)
		}
		for i := range v {
			v := &v[i]
			{
				v := v.Topic
				if isFlexible {
					dst = kbin.AppendCompactString(dst, v)
				} else {
					dst = kbin.AppendString(dst, v)
				}
			}
			{
				v := v.Partitions
				if isFlexible {
					dst = kbin.AppendCompactArrayLen(dst, len(v))
				} else {
					dst = kbin.AppendArrayLen(dst, len(v))
				}
				for i := range v {
					v := v[i]
					dst = kbin.AppendInt32(dst, v)
				}
			}
			if isFlexible {
				dst = kbin.AppendUvarint(dst, 0)
			}
		}
	}
	if isFlexible {
		dst = kbin.AppendUvarint(dst, 0)
	}
	return dst
}
func (v *ListPartitionReassignmentsRequest) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	isFlexible := version >= 0
	_ = isFlexible
	b := kbin.Reader{Src: src}
	s := v
	{
		v := b.Int32()
		s.TimeoutMillis = v
	}
	{
		v := s.Topics
		a := v
		var l int32
		if isFlexible {
			l = b.CompactArrayLen()
		} else {
			l = b.ArrayLen()
		}
		if version < 0 || l == 0 {
			a = []ListPartitionReassignmentsRequestTopic{}
		}
		if !b.Ok() {
			return b.Complete()
		}
		if l > 0 {
			a = make([]ListPartitionReassignmentsRequestTopic, l)
		}
		for i := int32(0); i < l; i++ {
			v := &a[i]
			s := v
			{
				var v string
				if isFlexible {
					v = b.CompactString()
				} else {
					v = b.String()
				}
				s.Topic = v
			}
			{
				v := s.Partitions
				a := v
				var l int32
				if isFlexible {
					l = b.CompactArrayLen()
				} else {
					l = b.ArrayLen()
				}
				if !b.Ok() {
					return b.Complete()
				}
				if l > 0 {
					a = make([]int32, l)
				}
				for i := int32(0); i < l; i++ {
					v := b.Int32()
					a[i] = v
				}
				v = a
				s.Partitions = v
			}
			if isFlexible {
				SkipTags(&b)
			}
		}
		v = a
		s.Topics = v
	}
	if isFlexible {
		SkipTags(&b)
	}
	return b.Complete()
}

type ListPartitionReassignmentsResponseTopicPartition struct {
	// Partition is the partition being responded to.
	Partition int32

	// Replicas is the partition's current replicas.
	Replicas []int32

	// AddingReplicas are replicas currently being added to the partition.
	AddingReplicas []int32

	// RemovingReplicas are replicas currently being removed from the partition.
	RemovingReplicas []int32
}
type ListPartitionReassignmentsResponseTopic struct {
	// Topic is the topic being responded to.
	Topic string

	// Partitions contains responses for partitions.
	Partitions []ListPartitionReassignmentsResponseTopicPartition
}

// ListPartitionReassignmentsResponse is returned for a ListPartitionReassignmentsRequest.
type ListPartitionReassignmentsResponse struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	// ThrottleMillis is how long of a throttle Kafka will apply to the client
	// after responding to this request.
	ThrottleMillis int32

	// ErrorCode is the error code returned for listing reassignments.
	//
	// REQUEST_TIMED_OUT is returned if the request timed out.
	//
	// NOT_CONTROLLER is returned if the request was not issued to a Kafka
	// controller.
	//
	// CLUSTER_AUTHORIZATION_FAILED is returned if the client is not
	// authorized to reassign partitions.
	ErrorCode int16

	// ErrorMessage is any global (applied to all partitions) error message.
	ErrorMessage *string

	// Topics contains responses for each topic requested.
	Topics []ListPartitionReassignmentsResponseTopic
}

func (*ListPartitionReassignmentsResponse) Key() int16                 { return 46 }
func (*ListPartitionReassignmentsResponse) MaxVersion() int16          { return 0 }
func (v *ListPartitionReassignmentsResponse) SetVersion(version int16) { v.Version = version }
func (v *ListPartitionReassignmentsResponse) GetVersion() int16        { return v.Version }
func (v *ListPartitionReassignmentsResponse) IsFlexible() bool         { return v.Version >= 0 }
func (v *ListPartitionReassignmentsResponse) RequestKind() Request {
	return &ListPartitionReassignmentsRequest{Version: v.Version}
}

func (v *ListPartitionReassignmentsResponse) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	isFlexible := version >= 0
	_ = isFlexible
	{
		v := v.ThrottleMillis
		dst = kbin.AppendInt32(dst, v)
	}
	{
		v := v.ErrorCode
		dst = kbin.AppendInt16(dst, v)
	}
	{
		v := v.ErrorMessage
		if isFlexible {
			dst = kbin.AppendCompactNullableString(dst, v)
		} else {
			dst = kbin.AppendNullableString(dst, v)
		}
	}
	{
		v := v.Topics
		if isFlexible {
			dst = kbin.AppendCompactArrayLen(dst, len(v))
		} else {
			dst = kbin.AppendArrayLen(dst, len(v))
		}
		for i := range v {
			v := &v[i]
			{
				v := v.Topic
				if isFlexible {
					dst = kbin.AppendCompactString(dst, v)
				} else {
					dst = kbin.AppendString(dst, v)
				}
			}
			{
				v := v.Partitions
				if isFlexible {
					dst = kbin.AppendCompactArrayLen(dst, len(v))
				} else {
					dst = kbin.AppendArrayLen(dst, len(v))
				}
				for i := range v {
					v := &v[i]
					{
						v := v.Partition
						dst = kbin.AppendInt32(dst, v)
					}
					{
						v := v.Replicas
						if isFlexible {
							dst = kbin.AppendCompactArrayLen(dst, len(v))
						} else {
							dst = kbin.AppendArrayLen(dst, len(v))
						}
						for i := range v {
							v := v[i]
							dst = kbin.AppendInt32(dst, v)
						}
					}
					{
						v := v.AddingReplicas
						if isFlexible {
							dst = kbin.AppendCompactArrayLen(dst, len(v))
						} else {
							dst = kbin.AppendArrayLen(dst, len(v))
						}
						for i := range v {
							v := v[i]
							dst = kbin.AppendInt32(dst, v)
						}
					}
					{
						v := v.RemovingReplicas
						if isFlexible {
							dst = kbin.AppendCompactArrayLen(dst, len(v))
						} else {
							dst = kbin.AppendArrayLen(dst, len(v))
						}
						for i := range v {
							v := v[i]
							dst = kbin.AppendInt32(dst, v)
						}
					}
					if isFlexible {
						dst = kbin.AppendUvarint(dst, 0)
					}
				}
			}
			if isFlexible {
				dst = kbin.AppendUvarint(dst, 0)
			}
		}
	}
	if isFlexible {
		dst = kbin.AppendUvarint(dst, 0)
	}
	return dst
}
func (v *ListPartitionReassignmentsResponse) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	isFlexible := version >= 0
	_ = isFlexible
	b := kbin.Reader{Src: src}
	s := v
	{
		v := b.Int32()
		s.ThrottleMillis = v
	}
	{
		v := b.Int16()
		s.ErrorCode = v
	}
	{
		var v *string
		if isFlexible {
			v = b.CompactNullableString()
		} else {
			v = b.NullableString()
		}
		s.ErrorMessage = v
	}
	{
		v := s.Topics
		a := v
		var l int32
		if isFlexible {
			l = b.CompactArrayLen()
		} else {
			l = b.ArrayLen()
		}
		if !b.Ok() {
			return b.Complete()
		}
		if l > 0 {
			a = make([]ListPartitionReassignmentsResponseTopic, l)
		}
		for i := int32(0); i < l; i++ {
			v := &a[i]
			s := v
			{
				var v string
				if isFlexible {
					v = b.CompactString()
				} else {
					v = b.String()
				}
				s.Topic = v
			}
			{
				v := s.Partitions
				a := v
				var l int32
				if isFlexible {
					l = b.CompactArrayLen()
				} else {
					l = b.ArrayLen()
				}
				if !b.Ok() {
					return b.Complete()
				}
				if l > 0 {
					a = make([]ListPartitionReassignmentsResponseTopicPartition, l)
				}
				for i := int32(0); i < l; i++ {
					v := &a[i]
					s := v
					{
						v := b.Int32()
						s.Partition = v
					}
					{
						v := s.Replicas
						a := v
						var l int32
						if isFlexible {
							l = b.CompactArrayLen()
						} else {
							l = b.ArrayLen()
						}
						if !b.Ok() {
							return b.Complete()
						}
						if l > 0 {
							a = make([]int32, l)
						}
						for i := int32(0); i < l; i++ {
							v := b.Int32()
							a[i] = v
						}
						v = a
						s.Replicas = v
					}
					{
						v := s.AddingReplicas
						a := v
						var l int32
						if isFlexible {
							l = b.CompactArrayLen()
						} else {
							l = b.ArrayLen()
						}
						if !b.Ok() {
							return b.Complete()
						}
						if l > 0 {
							a = make([]int32, l)
						}
						for i := int32(0); i < l; i++ {
							v := b.Int32()
							a[i] = v
						}
						v = a
						s.AddingReplicas = v
					}
					{
						v := s.RemovingReplicas
						a := v
						var l int32
						if isFlexible {
							l = b.CompactArrayLen()
						} else {
							l = b.ArrayLen()
						}
						if !b.Ok() {
							return b.Complete()
						}
						if l > 0 {
							a = make([]int32, l)
						}
						for i := int32(0); i < l; i++ {
							v := b.Int32()
							a[i] = v
						}
						v = a
						s.RemovingReplicas = v
					}
					if isFlexible {
						SkipTags(&b)
					}
				}
				v = a
				s.Partitions = v
			}
			if isFlexible {
				SkipTags(&b)
			}
		}
		v = a
		s.Topics = v
	}
	if isFlexible {
		SkipTags(&b)
	}
	return b.Complete()
}

type OffsetDeleteRequestTopicPartition struct {
	// Partition is a partition to delete offsets for.
	Partition int32
}
type OffsetDeleteRequestTopic struct {
	// Topic is a topic to delete offsets in.
	Topic string

	// Partitions are partitions to delete offsets for.
	Partitions []OffsetDeleteRequestTopicPartition
}

// OffsetDeleteRequest, proposed in KIP-496 and implemented in Kafka 2.4.0, is
// a request to delete group offsets.
//
// ACL wise, this requires DELETE on GROUP for the group and READ on TOPIC for
// each topic.
type OffsetDeleteRequest struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	// Group is the group to delete offsets in.
	Group string

	// Topics are topics to delete offsets in.
	Topics []OffsetDeleteRequestTopic
}

func (*OffsetDeleteRequest) Key() int16                   { return 47 }
func (*OffsetDeleteRequest) MaxVersion() int16            { return 0 }
func (v *OffsetDeleteRequest) SetVersion(version int16)   { v.Version = version }
func (v *OffsetDeleteRequest) GetVersion() int16          { return v.Version }
func (v *OffsetDeleteRequest) IsFlexible() bool           { return false }
func (v *OffsetDeleteRequest) IsGroupCoordinatorRequest() {}
func (v *OffsetDeleteRequest) ResponseKind() Response {
	return &OffsetDeleteResponse{Version: v.Version}
}

func (v *OffsetDeleteRequest) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	{
		v := v.Group
		dst = kbin.AppendString(dst, v)
	}
	{
		v := v.Topics
		dst = kbin.AppendArrayLen(dst, len(v))
		for i := range v {
			v := &v[i]
			{
				v := v.Topic
				dst = kbin.AppendString(dst, v)
			}
			{
				v := v.Partitions
				dst = kbin.AppendArrayLen(dst, len(v))
				for i := range v {
					v := &v[i]
					{
						v := v.Partition
						dst = kbin.AppendInt32(dst, v)
					}
				}
			}
		}
	}
	return dst
}
func (v *OffsetDeleteRequest) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	b := kbin.Reader{Src: src}
	s := v
	{
		v := b.String()
		s.Group = v
	}
	{
		v := s.Topics
		a := v
		var l int32
		l = b.ArrayLen()
		if !b.Ok() {
			return b.Complete()
		}
		if l > 0 {
			a = make([]OffsetDeleteRequestTopic, l)
		}
		for i := int32(0); i < l; i++ {
			v := &a[i]
			s := v
			{
				v := b.String()
				s.Topic = v
			}
			{
				v := s.Partitions
				a := v
				var l int32
				l = b.ArrayLen()
				if !b.Ok() {
					return b.Complete()
				}
				if l > 0 {
					a = make([]OffsetDeleteRequestTopicPartition, l)
				}
				for i := int32(0); i < l; i++ {
					v := &a[i]
					s := v
					{
						v := b.Int32()
						s.Partition = v
					}
				}
				v = a
				s.Partitions = v
			}
		}
		v = a
		s.Topics = v
	}
	return b.Complete()
}

type OffsetDeleteResponseTopicPartition struct {
	// Partition is the partition being responded to.
	Partition int32

	// ErrorCode is any per partition error code.
	//
	// TOPIC_AUTHORIZATION_FAILED is returned if the client is not authorized
	// for the topic / partition.
	//
	// UNKNOWN_TOPIC_OR_PARTITION is returned if the broker does not know of
	// the requested topic.
	//
	// GROUP_SUBSCRIBED_TO_TOPIC is returned if the topic is still subscribed to.
	ErrorCode int16
}
type OffsetDeleteResponseTopic struct {
	// Topic is the topic being responded to.
	Topic string

	// Partitions are partitions being responded to.
	Partitions []OffsetDeleteResponseTopicPartition
}

// OffsetDeleteResponse is a response to an offset delete request.
type OffsetDeleteResponse struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	// ErrorCode is any group wide error.
	//
	// GROUP_AUTHORIZATION_FAILED is returned if the client is not authorized
	// for the group.
	//
	// INVALID_GROUP_ID is returned in the requested group ID is invalid.
	//
	// COORDINATOR_NOT_AVAILABLE is returned if the coordinator is not available.
	//
	// COORDINATOR_LOAD_IN_PROGRESS is returned if the group is loading.
	//
	// NOT_COORDINATOR is returned if the requested broker is not the coordinator
	// for the requested group.
	//
	// GROUP_ID_NOT_FOUND is returned if the group ID does not exist.
	ErrorCode int16

	// ThrottleMillis is how long of a throttle Kafka will apply to the client
	// after responding to this request.
	ThrottleMillis int32

	// Topics are responses to requested topics.
	Topics []OffsetDeleteResponseTopic
}

func (*OffsetDeleteResponse) Key() int16                 { return 47 }
func (*OffsetDeleteResponse) MaxVersion() int16          { return 0 }
func (v *OffsetDeleteResponse) SetVersion(version int16) { v.Version = version }
func (v *OffsetDeleteResponse) GetVersion() int16        { return v.Version }
func (v *OffsetDeleteResponse) IsFlexible() bool         { return false }
func (v *OffsetDeleteResponse) RequestKind() Request     { return &OffsetDeleteRequest{Version: v.Version} }

func (v *OffsetDeleteResponse) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	{
		v := v.ErrorCode
		dst = kbin.AppendInt16(dst, v)
	}
	{
		v := v.ThrottleMillis
		dst = kbin.AppendInt32(dst, v)
	}
	{
		v := v.Topics
		dst = kbin.AppendArrayLen(dst, len(v))
		for i := range v {
			v := &v[i]
			{
				v := v.Topic
				dst = kbin.AppendString(dst, v)
			}
			{
				v := v.Partitions
				dst = kbin.AppendArrayLen(dst, len(v))
				for i := range v {
					v := &v[i]
					{
						v := v.Partition
						dst = kbin.AppendInt32(dst, v)
					}
					{
						v := v.ErrorCode
						dst = kbin.AppendInt16(dst, v)
					}
				}
			}
		}
	}
	return dst
}
func (v *OffsetDeleteResponse) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	b := kbin.Reader{Src: src}
	s := v
	{
		v := b.Int16()
		s.ErrorCode = v
	}
	{
		v := b.Int32()
		s.ThrottleMillis = v
	}
	{
		v := s.Topics
		a := v
		var l int32
		l = b.ArrayLen()
		if !b.Ok() {
			return b.Complete()
		}
		if l > 0 {
			a = make([]OffsetDeleteResponseTopic, l)
		}
		for i := int32(0); i < l; i++ {
			v := &a[i]
			s := v
			{
				v := b.String()
				s.Topic = v
			}
			{
				v := s.Partitions
				a := v
				var l int32
				l = b.ArrayLen()
				if !b.Ok() {
					return b.Complete()
				}
				if l > 0 {
					a = make([]OffsetDeleteResponseTopicPartition, l)
				}
				for i := int32(0); i < l; i++ {
					v := &a[i]
					s := v
					{
						v := b.Int32()
						s.Partition = v
					}
					{
						v := b.Int16()
						s.ErrorCode = v
					}
				}
				v = a
				s.Partitions = v
			}
		}
		v = a
		s.Topics = v
	}
	return b.Complete()
}

type DescribeClientQuotasRequestComponent struct {
	// EntityType is the entity component type that this filter component
	// applies to; some possible values are "user" or "client-id".
	EntityType string

	// MatchType specifies how to match an entity,
	// with 0 meaning match on the name exactly,
	// 1 meaning match on the default name,
	// and 2 meaning any specified name.
	MatchType int8

	// Match is the string to match against, or null if unused for the given
	// match type.
	Match *string
}

// DescribeClientQuotasRequest, proposed in KIP-546 and introduced with Kafka 2.6.0,
// provides a way to describe client quotas.
type DescribeClientQuotasRequest struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	// Components is a list of match filters to apply for describing quota entities.
	Components []DescribeClientQuotasRequestComponent

	// Strict signifies whether matches are strict; if true, the response
	// excludes entities with unspecified entity types.
	Strict bool
}

func (*DescribeClientQuotasRequest) Key() int16                 { return 48 }
func (*DescribeClientQuotasRequest) MaxVersion() int16          { return 0 }
func (v *DescribeClientQuotasRequest) SetVersion(version int16) { v.Version = version }
func (v *DescribeClientQuotasRequest) GetVersion() int16        { return v.Version }
func (v *DescribeClientQuotasRequest) IsFlexible() bool         { return false }
func (v *DescribeClientQuotasRequest) ResponseKind() Response {
	return &DescribeClientQuotasResponse{Version: v.Version}
}

func (v *DescribeClientQuotasRequest) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	{
		v := v.Components
		dst = kbin.AppendArrayLen(dst, len(v))
		for i := range v {
			v := &v[i]
			{
				v := v.EntityType
				dst = kbin.AppendString(dst, v)
			}
			{
				v := v.MatchType
				dst = kbin.AppendInt8(dst, v)
			}
			{
				v := v.Match
				dst = kbin.AppendNullableString(dst, v)
			}
		}
	}
	{
		v := v.Strict
		dst = kbin.AppendBool(dst, v)
	}
	return dst
}
func (v *DescribeClientQuotasRequest) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	b := kbin.Reader{Src: src}
	s := v
	{
		v := s.Components
		a := v
		var l int32
		l = b.ArrayLen()
		if !b.Ok() {
			return b.Complete()
		}
		if l > 0 {
			a = make([]DescribeClientQuotasRequestComponent, l)
		}
		for i := int32(0); i < l; i++ {
			v := &a[i]
			s := v
			{
				v := b.String()
				s.EntityType = v
			}
			{
				v := b.Int8()
				s.MatchType = v
			}
			{
				v := b.NullableString()
				s.Match = v
			}
		}
		v = a
		s.Components = v
	}
	{
		v := b.Bool()
		s.Strict = v
	}
	return b.Complete()
}

type DescribeClientQuotasResponseEntryEntity struct {
	// Type is the entity type.
	Type string

	// Name is the entity name, or null if the default.
	Name *string
}
type DescribeClientQuotasResponseEntryValue struct {
	// Key is the quota configuration key.
	Key string

	// Value is the quota configuration value.
	Value float64
}
type DescribeClientQuotasResponseEntry struct {
	// Entity contains the quota entity components being described.
	Entity []DescribeClientQuotasResponseEntryEntity

	// Values are quota values for the entity.
	Values []DescribeClientQuotasResponseEntryValue
}

// DescribeClientQuotasResponse is a response for a DescribeClientQuotasRequest.
type DescribeClientQuotasResponse struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	// ThrottleMillis is how long of a throttle Kafka will apply to the client
	// after responding to this request.
	ThrottleMillis int32

	// ErrorCode is any error for the request.
	ErrorCode int16

	// ErrorMessage is an error message for the request, or null if the request succeeded.
	ErrorMessage *string

	// Entries contains entities that were matched.
	Entries []DescribeClientQuotasResponseEntry
}

func (*DescribeClientQuotasResponse) Key() int16                 { return 48 }
func (*DescribeClientQuotasResponse) MaxVersion() int16          { return 0 }
func (v *DescribeClientQuotasResponse) SetVersion(version int16) { v.Version = version }
func (v *DescribeClientQuotasResponse) GetVersion() int16        { return v.Version }
func (v *DescribeClientQuotasResponse) IsFlexible() bool         { return false }
func (v *DescribeClientQuotasResponse) RequestKind() Request {
	return &DescribeClientQuotasRequest{Version: v.Version}
}

func (v *DescribeClientQuotasResponse) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	{
		v := v.ThrottleMillis
		dst = kbin.AppendInt32(dst, v)
	}
	{
		v := v.ErrorCode
		dst = kbin.AppendInt16(dst, v)
	}
	{
		v := v.ErrorMessage
		dst = kbin.AppendNullableString(dst, v)
	}
	{
		v := v.Entries
		dst = kbin.AppendNullableArrayLen(dst, len(v), v == nil)
		for i := range v {
			v := &v[i]
			{
				v := v.Entity
				dst = kbin.AppendArrayLen(dst, len(v))
				for i := range v {
					v := &v[i]
					{
						v := v.Type
						dst = kbin.AppendString(dst, v)
					}
					{
						v := v.Name
						dst = kbin.AppendNullableString(dst, v)
					}
				}
			}
			{
				v := v.Values
				dst = kbin.AppendArrayLen(dst, len(v))
				for i := range v {
					v := &v[i]
					{
						v := v.Key
						dst = kbin.AppendString(dst, v)
					}
					{
						v := v.Value
						dst = kbin.AppendFloat64(dst, v)
					}
				}
			}
		}
	}
	return dst
}
func (v *DescribeClientQuotasResponse) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	b := kbin.Reader{Src: src}
	s := v
	{
		v := b.Int32()
		s.ThrottleMillis = v
	}
	{
		v := b.Int16()
		s.ErrorCode = v
	}
	{
		v := b.NullableString()
		s.ErrorMessage = v
	}
	{
		v := s.Entries
		a := v
		var l int32
		l = b.ArrayLen()
		if version < 0 || l == 0 {
			a = []DescribeClientQuotasResponseEntry{}
		}
		if !b.Ok() {
			return b.Complete()
		}
		if l > 0 {
			a = make([]DescribeClientQuotasResponseEntry, l)
		}
		for i := int32(0); i < l; i++ {
			v := &a[i]
			s := v
			{
				v := s.Entity
				a := v
				var l int32
				l = b.ArrayLen()
				if !b.Ok() {
					return b.Complete()
				}
				if l > 0 {
					a = make([]DescribeClientQuotasResponseEntryEntity, l)
				}
				for i := int32(0); i < l; i++ {
					v := &a[i]
					s := v
					{
						v := b.String()
						s.Type = v
					}
					{
						v := b.NullableString()
						s.Name = v
					}
				}
				v = a
				s.Entity = v
			}
			{
				v := s.Values
				a := v
				var l int32
				l = b.ArrayLen()
				if !b.Ok() {
					return b.Complete()
				}
				if l > 0 {
					a = make([]DescribeClientQuotasResponseEntryValue, l)
				}
				for i := int32(0); i < l; i++ {
					v := &a[i]
					s := v
					{
						v := b.String()
						s.Key = v
					}
					{
						v := b.Float64()
						s.Value = v
					}
				}
				v = a
				s.Values = v
			}
		}
		v = a
		s.Entries = v
	}
	return b.Complete()
}

type AlterClientQuotasRequestEntryEntity struct {
	// Type is the entity component's type; e.g. "client-id" or "user".
	Type string

	// Name is the name of the entity, or null for the default.
	Name *string
}
type AlterClientQuotasRequestEntryOp struct {
	// Key is the quota configuration key to alter.
	Key string

	// Value is the value to set; ignored if remove is true.
	Value float64

	// Remove is whether the quota configuration value should be removed or set.
	Remove bool
}
type AlterClientQuotasRequestEntry struct {
	// Entity contains the components of a quota entity to alter.
	Entity []AlterClientQuotasRequestEntryEntity

	// Ops contains quota configuration entries to alter.
	Ops []AlterClientQuotasRequestEntryOp
}

// AlterClientQuotaRequest, proposed in KIP-546 and introduced with Kafka 2.6.0,
// provides a way to alter client quotas.
type AlterClientQuotasRequest struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	// Entries are quota configuration entries to alter.
	Entries []AlterClientQuotasRequestEntry

	// ValidateOnly is makes this request a dry-run; the alteration is validated
	// but not performed.
	ValidateOnly bool
}

func (*AlterClientQuotasRequest) Key() int16                 { return 49 }
func (*AlterClientQuotasRequest) MaxVersion() int16          { return 0 }
func (v *AlterClientQuotasRequest) SetVersion(version int16) { v.Version = version }
func (v *AlterClientQuotasRequest) GetVersion() int16        { return v.Version }
func (v *AlterClientQuotasRequest) IsFlexible() bool         { return false }
func (v *AlterClientQuotasRequest) ResponseKind() Response {
	return &AlterClientQuotasResponse{Version: v.Version}
}

func (v *AlterClientQuotasRequest) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	{
		v := v.Entries
		dst = kbin.AppendArrayLen(dst, len(v))
		for i := range v {
			v := &v[i]
			{
				v := v.Entity
				dst = kbin.AppendArrayLen(dst, len(v))
				for i := range v {
					v := &v[i]
					{
						v := v.Type
						dst = kbin.AppendString(dst, v)
					}
					{
						v := v.Name
						dst = kbin.AppendNullableString(dst, v)
					}
				}
			}
			{
				v := v.Ops
				dst = kbin.AppendArrayLen(dst, len(v))
				for i := range v {
					v := &v[i]
					{
						v := v.Key
						dst = kbin.AppendString(dst, v)
					}
					{
						v := v.Value
						dst = kbin.AppendFloat64(dst, v)
					}
					{
						v := v.Remove
						dst = kbin.AppendBool(dst, v)
					}
				}
			}
		}
	}
	{
		v := v.ValidateOnly
		dst = kbin.AppendBool(dst, v)
	}
	return dst
}
func (v *AlterClientQuotasRequest) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	b := kbin.Reader{Src: src}
	s := v
	{
		v := s.Entries
		a := v
		var l int32
		l = b.ArrayLen()
		if !b.Ok() {
			return b.Complete()
		}
		if l > 0 {
			a = make([]AlterClientQuotasRequestEntry, l)
		}
		for i := int32(0); i < l; i++ {
			v := &a[i]
			s := v
			{
				v := s.Entity
				a := v
				var l int32
				l = b.ArrayLen()
				if !b.Ok() {
					return b.Complete()
				}
				if l > 0 {
					a = make([]AlterClientQuotasRequestEntryEntity, l)
				}
				for i := int32(0); i < l; i++ {
					v := &a[i]
					s := v
					{
						v := b.String()
						s.Type = v
					}
					{
						v := b.NullableString()
						s.Name = v
					}
				}
				v = a
				s.Entity = v
			}
			{
				v := s.Ops
				a := v
				var l int32
				l = b.ArrayLen()
				if !b.Ok() {
					return b.Complete()
				}
				if l > 0 {
					a = make([]AlterClientQuotasRequestEntryOp, l)
				}
				for i := int32(0); i < l; i++ {
					v := &a[i]
					s := v
					{
						v := b.String()
						s.Key = v
					}
					{
						v := b.Float64()
						s.Value = v
					}
					{
						v := b.Bool()
						s.Remove = v
					}
				}
				v = a
				s.Ops = v
			}
		}
		v = a
		s.Entries = v
	}
	{
		v := b.Bool()
		s.ValidateOnly = v
	}
	return b.Complete()
}

type AlterClientQuotasResponseEntryEntity struct {
	// Type is the entity component's type; e.g. "client-id" or "user".
	Type string

	// Name is the name of the entity, or null for the default.
	Name *string
}
type AlterClientQuotasResponseEntry struct {
	// ErrorCode is the error code for an alter on a matched entity.
	ErrorCode int16

	// ErrorMessage is an informative message if the alter on this entity failed.
	ErrorMessage *string

	// Entity contains the components of a matched entity.
	Entity []AlterClientQuotasResponseEntryEntity
}

// AlterClientQuotasResponse is a response to an AlterClientQuotasRequest.
type AlterClientQuotasResponse struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	// ThrottleMillis is how long of a throttle Kafka will apply to the client
	// after responding to this request.
	ThrottleMillis int32

	// Entries contains results for the alter request.
	Entries []AlterClientQuotasResponseEntry
}

func (*AlterClientQuotasResponse) Key() int16                 { return 49 }
func (*AlterClientQuotasResponse) MaxVersion() int16          { return 0 }
func (v *AlterClientQuotasResponse) SetVersion(version int16) { v.Version = version }
func (v *AlterClientQuotasResponse) GetVersion() int16        { return v.Version }
func (v *AlterClientQuotasResponse) IsFlexible() bool         { return false }
func (v *AlterClientQuotasResponse) RequestKind() Request {
	return &AlterClientQuotasRequest{Version: v.Version}
}

func (v *AlterClientQuotasResponse) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	{
		v := v.ThrottleMillis
		dst = kbin.AppendInt32(dst, v)
	}
	{
		v := v.Entries
		dst = kbin.AppendArrayLen(dst, len(v))
		for i := range v {
			v := &v[i]
			{
				v := v.ErrorCode
				dst = kbin.AppendInt16(dst, v)
			}
			{
				v := v.ErrorMessage
				dst = kbin.AppendNullableString(dst, v)
			}
			{
				v := v.Entity
				dst = kbin.AppendArrayLen(dst, len(v))
				for i := range v {
					v := &v[i]
					{
						v := v.Type
						dst = kbin.AppendString(dst, v)
					}
					{
						v := v.Name
						dst = kbin.AppendNullableString(dst, v)
					}
				}
			}
		}
	}
	return dst
}
func (v *AlterClientQuotasResponse) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	b := kbin.Reader{Src: src}
	s := v
	{
		v := b.Int32()
		s.ThrottleMillis = v
	}
	{
		v := s.Entries
		a := v
		var l int32
		l = b.ArrayLen()
		if !b.Ok() {
			return b.Complete()
		}
		if l > 0 {
			a = make([]AlterClientQuotasResponseEntry, l)
		}
		for i := int32(0); i < l; i++ {
			v := &a[i]
			s := v
			{
				v := b.Int16()
				s.ErrorCode = v
			}
			{
				v := b.NullableString()
				s.ErrorMessage = v
			}
			{
				v := s.Entity
				a := v
				var l int32
				l = b.ArrayLen()
				if !b.Ok() {
					return b.Complete()
				}
				if l > 0 {
					a = make([]AlterClientQuotasResponseEntryEntity, l)
				}
				for i := int32(0); i < l; i++ {
					v := &a[i]
					s := v
					{
						v := b.String()
						s.Type = v
					}
					{
						v := b.NullableString()
						s.Name = v
					}
				}
				v = a
				s.Entity = v
			}
		}
		v = a
		s.Entries = v
	}
	return b.Complete()
}

type DescribeUserSCRAMCredentialsRequestUser struct {
	// The user name.
	Name string
}

// DescribeUserSCRAMCredentialsRequest, proposed in KIP-554 and introduced
// with Kafka 2.7.0, describes user SCRAM credentials.
//
// This request was introduced as part of the overarching KIP-500 initiative,
// which is to remove Zookeeper as a dependency.
//
// This request requires DESCRIBE on CLUSTER.
type DescribeUserSCRAMCredentialsRequest struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	// The users to describe, or null to describe all.
	Users []DescribeUserSCRAMCredentialsRequestUser
}

func (*DescribeUserSCRAMCredentialsRequest) Key() int16                 { return 50 }
func (*DescribeUserSCRAMCredentialsRequest) MaxVersion() int16          { return 0 }
func (v *DescribeUserSCRAMCredentialsRequest) SetVersion(version int16) { v.Version = version }
func (v *DescribeUserSCRAMCredentialsRequest) GetVersion() int16        { return v.Version }
func (v *DescribeUserSCRAMCredentialsRequest) IsFlexible() bool         { return v.Version >= 0 }
func (v *DescribeUserSCRAMCredentialsRequest) ResponseKind() Response {
	return &DescribeUserSCRAMCredentialsResponse{Version: v.Version}
}

func (v *DescribeUserSCRAMCredentialsRequest) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	isFlexible := version >= 0
	_ = isFlexible
	{
		v := v.Users
		if isFlexible {
			dst = kbin.AppendCompactArrayLen(dst, len(v))
		} else {
			dst = kbin.AppendArrayLen(dst, len(v))
		}
		for i := range v {
			v := &v[i]
			{
				v := v.Name
				if isFlexible {
					dst = kbin.AppendCompactString(dst, v)
				} else {
					dst = kbin.AppendString(dst, v)
				}
			}
			if isFlexible {
				dst = kbin.AppendUvarint(dst, 0)
			}
		}
	}
	if isFlexible {
		dst = kbin.AppendUvarint(dst, 0)
	}
	return dst
}
func (v *DescribeUserSCRAMCredentialsRequest) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	isFlexible := version >= 0
	_ = isFlexible
	b := kbin.Reader{Src: src}
	s := v
	{
		v := s.Users
		a := v
		var l int32
		if isFlexible {
			l = b.CompactArrayLen()
		} else {
			l = b.ArrayLen()
		}
		if !b.Ok() {
			return b.Complete()
		}
		if l > 0 {
			a = make([]DescribeUserSCRAMCredentialsRequestUser, l)
		}
		for i := int32(0); i < l; i++ {
			v := &a[i]
			s := v
			{
				var v string
				if isFlexible {
					v = b.CompactString()
				} else {
					v = b.String()
				}
				s.Name = v
			}
			if isFlexible {
				SkipTags(&b)
			}
		}
		v = a
		s.Users = v
	}
	if isFlexible {
		SkipTags(&b)
	}
	return b.Complete()
}

type DescribeUserSCRAMCredentialsResponseResultCredentialInfo struct {
	// The SCRAM mechanism for this user, where 0 is UNKNOWN, 1 is SCRAM_SHA_256,
	// and 2 is SCRAM_SHA_512.
	Mechanism int8

	// The number of iterations used in the SCRAM credential.
	Iteractions int32
}
type DescribeUserSCRAMCredentialsResponseResult struct {
	// The name this result corresponds to.
	User string

	// The user-level error code.
	ErrorCode int16

	// The user-level error message, if any.
	ErrorMessage *string

	// Information about the SCRAM credentials for this user.
	CredentialInfos []DescribeUserSCRAMCredentialsResponseResultCredentialInfo
}

// DescribeUserSCRAMCredentialsResponse is a response for a
// DescribeUserSCRAMCredentialsRequest.
type DescribeUserSCRAMCredentialsResponse struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	// ThrottleMillis is how long of a throttle Kafka will apply to the client
	// after responding to this request.
	ThrottleMillis int32

	// The request-level error code. This is 0 except for user or infra issues.
	ErrorCode int16

	// The request-level error message, if any.
	ErrorMessage *string

	// Results for descriptions, one per user.
	Results []DescribeUserSCRAMCredentialsResponseResult
}

func (*DescribeUserSCRAMCredentialsResponse) Key() int16                 { return 50 }
func (*DescribeUserSCRAMCredentialsResponse) MaxVersion() int16          { return 0 }
func (v *DescribeUserSCRAMCredentialsResponse) SetVersion(version int16) { v.Version = version }
func (v *DescribeUserSCRAMCredentialsResponse) GetVersion() int16        { return v.Version }
func (v *DescribeUserSCRAMCredentialsResponse) IsFlexible() bool         { return v.Version >= 0 }
func (v *DescribeUserSCRAMCredentialsResponse) RequestKind() Request {
	return &DescribeUserSCRAMCredentialsRequest{Version: v.Version}
}

func (v *DescribeUserSCRAMCredentialsResponse) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	isFlexible := version >= 0
	_ = isFlexible
	{
		v := v.ThrottleMillis
		dst = kbin.AppendInt32(dst, v)
	}
	{
		v := v.ErrorCode
		dst = kbin.AppendInt16(dst, v)
	}
	{
		v := v.ErrorMessage
		if isFlexible {
			dst = kbin.AppendCompactNullableString(dst, v)
		} else {
			dst = kbin.AppendNullableString(dst, v)
		}
	}
	{
		v := v.Results
		if isFlexible {
			dst = kbin.AppendCompactArrayLen(dst, len(v))
		} else {
			dst = kbin.AppendArrayLen(dst, len(v))
		}
		for i := range v {
			v := &v[i]
			{
				v := v.User
				if isFlexible {
					dst = kbin.AppendCompactString(dst, v)
				} else {
					dst = kbin.AppendString(dst, v)
				}
			}
			{
				v := v.ErrorCode
				dst = kbin.AppendInt16(dst, v)
			}
			{
				v := v.ErrorMessage
				if isFlexible {
					dst = kbin.AppendCompactNullableString(dst, v)
				} else {
					dst = kbin.AppendNullableString(dst, v)
				}
			}
			{
				v := v.CredentialInfos
				if isFlexible {
					dst = kbin.AppendCompactArrayLen(dst, len(v))
				} else {
					dst = kbin.AppendArrayLen(dst, len(v))
				}
				for i := range v {
					v := &v[i]
					{
						v := v.Mechanism
						dst = kbin.AppendInt8(dst, v)
					}
					{
						v := v.Iteractions
						dst = kbin.AppendInt32(dst, v)
					}
					if isFlexible {
						dst = kbin.AppendUvarint(dst, 0)
					}
				}
			}
			if isFlexible {
				dst = kbin.AppendUvarint(dst, 0)
			}
		}
	}
	if isFlexible {
		dst = kbin.AppendUvarint(dst, 0)
	}
	return dst
}
func (v *DescribeUserSCRAMCredentialsResponse) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	isFlexible := version >= 0
	_ = isFlexible
	b := kbin.Reader{Src: src}
	s := v
	{
		v := b.Int32()
		s.ThrottleMillis = v
	}
	{
		v := b.Int16()
		s.ErrorCode = v
	}
	{
		var v *string
		if isFlexible {
			v = b.CompactNullableString()
		} else {
			v = b.NullableString()
		}
		s.ErrorMessage = v
	}
	{
		v := s.Results
		a := v
		var l int32
		if isFlexible {
			l = b.CompactArrayLen()
		} else {
			l = b.ArrayLen()
		}
		if !b.Ok() {
			return b.Complete()
		}
		if l > 0 {
			a = make([]DescribeUserSCRAMCredentialsResponseResult, l)
		}
		for i := int32(0); i < l; i++ {
			v := &a[i]
			s := v
			{
				var v string
				if isFlexible {
					v = b.CompactString()
				} else {
					v = b.String()
				}
				s.User = v
			}
			{
				v := b.Int16()
				s.ErrorCode = v
			}
			{
				var v *string
				if isFlexible {
					v = b.CompactNullableString()
				} else {
					v = b.NullableString()
				}
				s.ErrorMessage = v
			}
			{
				v := s.CredentialInfos
				a := v
				var l int32
				if isFlexible {
					l = b.CompactArrayLen()
				} else {
					l = b.ArrayLen()
				}
				if !b.Ok() {
					return b.Complete()
				}
				if l > 0 {
					a = make([]DescribeUserSCRAMCredentialsResponseResultCredentialInfo, l)
				}
				for i := int32(0); i < l; i++ {
					v := &a[i]
					s := v
					{
						v := b.Int8()
						s.Mechanism = v
					}
					{
						v := b.Int32()
						s.Iteractions = v
					}
					if isFlexible {
						SkipTags(&b)
					}
				}
				v = a
				s.CredentialInfos = v
			}
			if isFlexible {
				SkipTags(&b)
			}
		}
		v = a
		s.Results = v
	}
	if isFlexible {
		SkipTags(&b)
	}
	return b.Complete()
}

type AlterUserSCRAMCredentialsRequestDeletion struct {
	// The user name to match for removal.
	Name string

	// The mechanism for the user name to remove.
	Mechanism int8
}
type AlterUserSCRAMCredentialsRequestUpsertion struct {
	// The user name to use.
	Name string

	// The mechanism to use for creating. See
	// DescribeUserSCRAMCredentialsResponse for more information.
	Mechanism int8

	// The number of iterations to use. This must be more than the minimum for
	// the mechanism and cannot be more than 16384.
	Iterations int32

	// A random salt generated by the client.
	Salt []byte

	// The salted password to use.
	SaltedPassword []byte
}

// AlterUserSCRAMCredentialsRequest, proposed in KIP-554 and introduced
// with Kafka 2.7.0, alters or deletes user SCRAM credentials.
//
// This request was introduced as part of the overarching KIP-500 initiative,
// which is to remove Zookeeper as a dependency.
//
// This request requires ALTER on CLUSTER.
type AlterUserSCRAMCredentialsRequest struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	// The SCRAM credentials to remove.
	Deletions []AlterUserSCRAMCredentialsRequestDeletion

	// The SCRAM credentials to update or insert.
	Upsertions []AlterUserSCRAMCredentialsRequestUpsertion
}

func (*AlterUserSCRAMCredentialsRequest) Key() int16                 { return 51 }
func (*AlterUserSCRAMCredentialsRequest) MaxVersion() int16          { return 0 }
func (v *AlterUserSCRAMCredentialsRequest) SetVersion(version int16) { v.Version = version }
func (v *AlterUserSCRAMCredentialsRequest) GetVersion() int16        { return v.Version }
func (v *AlterUserSCRAMCredentialsRequest) IsFlexible() bool         { return v.Version >= 0 }
func (v *AlterUserSCRAMCredentialsRequest) IsAdminRequest()          {}
func (v *AlterUserSCRAMCredentialsRequest) ResponseKind() Response {
	return &AlterUserSCRAMCredentialsResponse{Version: v.Version}
}

func (v *AlterUserSCRAMCredentialsRequest) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	isFlexible := version >= 0
	_ = isFlexible
	{
		v := v.Deletions
		if isFlexible {
			dst = kbin.AppendCompactArrayLen(dst, len(v))
		} else {
			dst = kbin.AppendArrayLen(dst, len(v))
		}
		for i := range v {
			v := &v[i]
			{
				v := v.Name
				if isFlexible {
					dst = kbin.AppendCompactString(dst, v)
				} else {
					dst = kbin.AppendString(dst, v)
				}
			}
			{
				v := v.Mechanism
				dst = kbin.AppendInt8(dst, v)
			}
			if isFlexible {
				dst = kbin.AppendUvarint(dst, 0)
			}
		}
	}
	{
		v := v.Upsertions
		if isFlexible {
			dst = kbin.AppendCompactArrayLen(dst, len(v))
		} else {
			dst = kbin.AppendArrayLen(dst, len(v))
		}
		for i := range v {
			v := &v[i]
			{
				v := v.Name
				if isFlexible {
					dst = kbin.AppendCompactString(dst, v)
				} else {
					dst = kbin.AppendString(dst, v)
				}
			}
			{
				v := v.Mechanism
				dst = kbin.AppendInt8(dst, v)
			}
			{
				v := v.Iterations
				dst = kbin.AppendInt32(dst, v)
			}
			{
				v := v.Salt
				if isFlexible {
					dst = kbin.AppendCompactBytes(dst, v)
				} else {
					dst = kbin.AppendBytes(dst, v)
				}
			}
			{
				v := v.SaltedPassword
				if isFlexible {
					dst = kbin.AppendCompactBytes(dst, v)
				} else {
					dst = kbin.AppendBytes(dst, v)
				}
			}
			if isFlexible {
				dst = kbin.AppendUvarint(dst, 0)
			}
		}
	}
	if isFlexible {
		dst = kbin.AppendUvarint(dst, 0)
	}
	return dst
}
func (v *AlterUserSCRAMCredentialsRequest) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	isFlexible := version >= 0
	_ = isFlexible
	b := kbin.Reader{Src: src}
	s := v
	{
		v := s.Deletions
		a := v
		var l int32
		if isFlexible {
			l = b.CompactArrayLen()
		} else {
			l = b.ArrayLen()
		}
		if !b.Ok() {
			return b.Complete()
		}
		if l > 0 {
			a = make([]AlterUserSCRAMCredentialsRequestDeletion, l)
		}
		for i := int32(0); i < l; i++ {
			v := &a[i]
			s := v
			{
				var v string
				if isFlexible {
					v = b.CompactString()
				} else {
					v = b.String()
				}
				s.Name = v
			}
			{
				v := b.Int8()
				s.Mechanism = v
			}
			if isFlexible {
				SkipTags(&b)
			}
		}
		v = a
		s.Deletions = v
	}
	{
		v := s.Upsertions
		a := v
		var l int32
		if isFlexible {
			l = b.CompactArrayLen()
		} else {
			l = b.ArrayLen()
		}
		if !b.Ok() {
			return b.Complete()
		}
		if l > 0 {
			a = make([]AlterUserSCRAMCredentialsRequestUpsertion, l)
		}
		for i := int32(0); i < l; i++ {
			v := &a[i]
			s := v
			{
				var v string
				if isFlexible {
					v = b.CompactString()
				} else {
					v = b.String()
				}
				s.Name = v
			}
			{
				v := b.Int8()
				s.Mechanism = v
			}
			{
				v := b.Int32()
				s.Iterations = v
			}
			{
				var v []byte
				if isFlexible {
					v = b.CompactBytes()
				} else {
					v = b.Bytes()
				}
				s.Salt = v
			}
			{
				var v []byte
				if isFlexible {
					v = b.CompactBytes()
				} else {
					v = b.Bytes()
				}
				s.SaltedPassword = v
			}
			if isFlexible {
				SkipTags(&b)
			}
		}
		v = a
		s.Upsertions = v
	}
	if isFlexible {
		SkipTags(&b)
	}
	return b.Complete()
}

type AlterUserSCRAMCredentialsResponseResult struct {
	// The name this result corresponds to.
	User string

	// The user-level error code.
	ErrorCode int16

	// The user-level error message, if any.
	ErrorMessage *string
}

// AlterUserSCRAMCredentialsResponse is a response for an
// AlterUserSCRAMCredentialsRequest.
type AlterUserSCRAMCredentialsResponse struct {
	// Version is the version of this message used with a Kafka broker.
	Version int16

	// ThrottleMillis is how long of a throttle Kafka will apply to the client
	// after responding to this request.
	ThrottleMillis int32

	// The results for deletions and upsertions.
	Results []AlterUserSCRAMCredentialsResponseResult
}

func (*AlterUserSCRAMCredentialsResponse) Key() int16                 { return 51 }
func (*AlterUserSCRAMCredentialsResponse) MaxVersion() int16          { return 0 }
func (v *AlterUserSCRAMCredentialsResponse) SetVersion(version int16) { v.Version = version }
func (v *AlterUserSCRAMCredentialsResponse) GetVersion() int16        { return v.Version }
func (v *AlterUserSCRAMCredentialsResponse) IsFlexible() bool         { return v.Version >= 0 }
func (v *AlterUserSCRAMCredentialsResponse) RequestKind() Request {
	return &AlterUserSCRAMCredentialsRequest{Version: v.Version}
}

func (v *AlterUserSCRAMCredentialsResponse) AppendTo(dst []byte) []byte {
	version := v.Version
	_ = version
	isFlexible := version >= 0
	_ = isFlexible
	{
		v := v.ThrottleMillis
		dst = kbin.AppendInt32(dst, v)
	}
	{
		v := v.Results
		if isFlexible {
			dst = kbin.AppendCompactArrayLen(dst, len(v))
		} else {
			dst = kbin.AppendArrayLen(dst, len(v))
		}
		for i := range v {
			v := &v[i]
			{
				v := v.User
				if isFlexible {
					dst = kbin.AppendCompactString(dst, v)
				} else {
					dst = kbin.AppendString(dst, v)
				}
			}
			{
				v := v.ErrorCode
				dst = kbin.AppendInt16(dst, v)
			}
			{
				v := v.ErrorMessage
				if isFlexible {
					dst = kbin.AppendCompactNullableString(dst, v)
				} else {
					dst = kbin.AppendNullableString(dst, v)
				}
			}
			if isFlexible {
				dst = kbin.AppendUvarint(dst, 0)
			}
		}
	}
	if isFlexible {
		dst = kbin.AppendUvarint(dst, 0)
	}
	return dst
}
func (v *AlterUserSCRAMCredentialsResponse) ReadFrom(src []byte) error {
	version := v.Version
	_ = version
	isFlexible := version >= 0
	_ = isFlexible
	b := kbin.Reader{Src: src}
	s := v
	{
		v := b.Int32()
		s.ThrottleMillis = v
	}
	{
		v := s.Results
		a := v
		var l int32
		if isFlexible {
			l = b.CompactArrayLen()
		} else {
			l = b.ArrayLen()
		}
		if !b.Ok() {
			return b.Complete()
		}
		if l > 0 {
			a = make([]AlterUserSCRAMCredentialsResponseResult, l)
		}
		for i := int32(0); i < l; i++ {
			v := &a[i]
			s := v
			{
				var v string
				if isFlexible {
					v = b.CompactString()
				} else {
					v = b.String()
				}
				s.User = v
			}
			{
				v := b.Int16()
				s.ErrorCode = v
			}
			{
				var v *string
				if isFlexible {
					v = b.CompactNullableString()
				} else {
					v = b.NullableString()
				}
				s.ErrorMessage = v
			}
			if isFlexible {
				SkipTags(&b)
			}
		}
		v = a
		s.Results = v
	}
	if isFlexible {
		SkipTags(&b)
	}
	return b.Complete()
}

// RequestForKey returns the request corresponding to the given request key
// or nil if the key is unknown.
func RequestForKey(key int16) Request {
	switch key {
	default:
		return nil
	case 0:
		return new(ProduceRequest)
	case 1:
		return new(FetchRequest)
	case 2:
		return new(ListOffsetsRequest)
	case 3:
		return new(MetadataRequest)
	case 4:
		return new(LeaderAndISRRequest)
	case 5:
		return new(StopReplicaRequest)
	case 6:
		return new(UpdateMetadataRequest)
	case 7:
		return new(ControlledShutdownRequest)
	case 8:
		return new(OffsetCommitRequest)
	case 9:
		return new(OffsetFetchRequest)
	case 10:
		return new(FindCoordinatorRequest)
	case 11:
		return new(JoinGroupRequest)
	case 12:
		return new(HeartbeatRequest)
	case 13:
		return new(LeaveGroupRequest)
	case 14:
		return new(SyncGroupRequest)
	case 15:
		return new(DescribeGroupsRequest)
	case 16:
		return new(ListGroupsRequest)
	case 17:
		return new(SASLHandshakeRequest)
	case 18:
		return new(ApiVersionsRequest)
	case 19:
		return new(CreateTopicsRequest)
	case 20:
		return new(DeleteTopicsRequest)
	case 21:
		return new(DeleteRecordsRequest)
	case 22:
		return new(InitProducerIDRequest)
	case 23:
		return new(OffsetForLeaderEpochRequest)
	case 24:
		return new(AddPartitionsToTxnRequest)
	case 25:
		return new(AddOffsetsToTxnRequest)
	case 26:
		return new(EndTxnRequest)
	case 27:
		return new(WriteTxnMarkersRequest)
	case 28:
		return new(TxnOffsetCommitRequest)
	case 29:
		return new(DescribeACLsRequest)
	case 30:
		return new(CreateACLsRequest)
	case 31:
		return new(DeleteACLsRequest)
	case 32:
		return new(DescribeConfigsRequest)
	case 33:
		return new(AlterConfigsRequest)
	case 34:
		return new(AlterReplicaLogDirsRequest)
	case 35:
		return new(DescribeLogDirsRequest)
	case 36:
		return new(SASLAuthenticateRequest)
	case 37:
		return new(CreatePartitionsRequest)
	case 38:
		return new(CreateDelegationTokenRequest)
	case 39:
		return new(RenewDelegationTokenRequest)
	case 40:
		return new(ExpireDelegationTokenRequest)
	case 41:
		return new(DescribeDelegationTokenRequest)
	case 42:
		return new(DeleteGroupsRequest)
	case 43:
		return new(ElectLeadersRequest)
	case 44:
		return new(IncrementalAlterConfigsRequest)
	case 45:
		return new(AlterPartitionAssignmentsRequest)
	case 46:
		return new(ListPartitionReassignmentsRequest)
	case 47:
		return new(OffsetDeleteRequest)
	case 48:
		return new(DescribeClientQuotasRequest)
	case 49:
		return new(AlterClientQuotasRequest)
	case 50:
		return new(DescribeUserSCRAMCredentialsRequest)
	case 51:
		return new(AlterUserSCRAMCredentialsRequest)
	}
}

// ResponseForKey returns the response corresponding to the given request key
// or nil if the key is unknown.
func ResponseForKey(key int16) Response {
	switch key {
	default:
		return nil
	case 0:
		return new(ProduceResponse)
	case 1:
		return new(FetchResponse)
	case 2:
		return new(ListOffsetsResponse)
	case 3:
		return new(MetadataResponse)
	case 4:
		return new(LeaderAndISRResponse)
	case 5:
		return new(StopReplicaResponse)
	case 6:
		return new(UpdateMetadataResponse)
	case 7:
		return new(ControlledShutdownResponse)
	case 8:
		return new(OffsetCommitResponse)
	case 9:
		return new(OffsetFetchResponse)
	case 10:
		return new(FindCoordinatorResponse)
	case 11:
		return new(JoinGroupResponse)
	case 12:
		return new(HeartbeatResponse)
	case 13:
		return new(LeaveGroupResponse)
	case 14:
		return new(SyncGroupResponse)
	case 15:
		return new(DescribeGroupsResponse)
	case 16:
		return new(ListGroupsResponse)
	case 17:
		return new(SASLHandshakeResponse)
	case 18:
		return new(ApiVersionsResponse)
	case 19:
		return new(CreateTopicsResponse)
	case 20:
		return new(DeleteTopicsResponse)
	case 21:
		return new(DeleteRecordsResponse)
	case 22:
		return new(InitProducerIDResponse)
	case 23:
		return new(OffsetForLeaderEpochResponse)
	case 24:
		return new(AddPartitionsToTxnResponse)
	case 25:
		return new(AddOffsetsToTxnResponse)
	case 26:
		return new(EndTxnResponse)
	case 27:
		return new(WriteTxnMarkersResponse)
	case 28:
		return new(TxnOffsetCommitResponse)
	case 29:
		return new(DescribeACLsResponse)
	case 30:
		return new(CreateACLsResponse)
	case 31:
		return new(DeleteACLsResponse)
	case 32:
		return new(DescribeConfigsResponse)
	case 33:
		return new(AlterConfigsResponse)
	case 34:
		return new(AlterReplicaLogDirsResponse)
	case 35:
		return new(DescribeLogDirsResponse)
	case 36:
		return new(SASLAuthenticateResponse)
	case 37:
		return new(CreatePartitionsResponse)
	case 38:
		return new(CreateDelegationTokenResponse)
	case 39:
		return new(RenewDelegationTokenResponse)
	case 40:
		return new(ExpireDelegationTokenResponse)
	case 41:
		return new(DescribeDelegationTokenResponse)
	case 42:
		return new(DeleteGroupsResponse)
	case 43:
		return new(ElectLeadersResponse)
	case 44:
		return new(IncrementalAlterConfigsResponse)
	case 45:
		return new(AlterPartitionAssignmentsResponse)
	case 46:
		return new(ListPartitionReassignmentsResponse)
	case 47:
		return new(OffsetDeleteResponse)
	case 48:
		return new(DescribeClientQuotasResponse)
	case 49:
		return new(AlterClientQuotasResponse)
	case 50:
		return new(DescribeUserSCRAMCredentialsResponse)
	case 51:
		return new(AlterUserSCRAMCredentialsResponse)
	}
}

// NameForKey returns the name (e.g., "Fetch") corresponding to a given request key
// or "" if the key is unknown.
func NameForKey(key int16) string {
	switch key {
	default:
		return ""
	case 0:
		return "Produce"
	case 1:
		return "Fetch"
	case 2:
		return "ListOffsets"
	case 3:
		return "Metadata"
	case 4:
		return "LeaderAndISR"
	case 5:
		return "StopReplica"
	case 6:
		return "UpdateMetadata"
	case 7:
		return "ControlledShutdown"
	case 8:
		return "OffsetCommit"
	case 9:
		return "OffsetFetch"
	case 10:
		return "FindCoordinator"
	case 11:
		return "JoinGroup"
	case 12:
		return "Heartbeat"
	case 13:
		return "LeaveGroup"
	case 14:
		return "SyncGroup"
	case 15:
		return "DescribeGroups"
	case 16:
		return "ListGroups"
	case 17:
		return "SASLHandshake"
	case 18:
		return "ApiVersions"
	case 19:
		return "CreateTopics"
	case 20:
		return "DeleteTopics"
	case 21:
		return "DeleteRecords"
	case 22:
		return "InitProducerID"
	case 23:
		return "OffsetForLeaderEpoch"
	case 24:
		return "AddPartitionsToTxn"
	case 25:
		return "AddOffsetsToTxn"
	case 26:
		return "EndTxn"
	case 27:
		return "WriteTxnMarkers"
	case 28:
		return "TxnOffsetCommit"
	case 29:
		return "DescribeACLs"
	case 30:
		return "CreateACLs"
	case 31:
		return "DeleteACLs"
	case 32:
		return "DescribeConfigs"
	case 33:
		return "AlterConfigs"
	case 34:
		return "AlterReplicaLogDirs"
	case 35:
		return "DescribeLogDirs"
	case 36:
		return "SASLAuthenticate"
	case 37:
		return "CreatePartitions"
	case 38:
		return "CreateDelegationToken"
	case 39:
		return "RenewDelegationToken"
	case 40:
		return "ExpireDelegationToken"
	case 41:
		return "DescribeDelegationToken"
	case 42:
		return "DeleteGroups"
	case 43:
		return "ElectLeaders"
	case 44:
		return "IncrementalAlterConfigs"
	case 45:
		return "AlterPartitionAssignments"
	case 46:
		return "ListPartitionReassignments"
	case 47:
		return "OffsetDelete"
	case 48:
		return "DescribeClientQuotas"
	case 49:
		return "AlterClientQuotas"
	case 50:
		return "DescribeUserSCRAMCredentials"
	case 51:
		return "AlterUserSCRAMCredentials"
	}
}
